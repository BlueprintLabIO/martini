{
  "__metadata": {
    "version": "0.1.1",
    "gitSha": "f1549779589acd3f93c438c1f52f47ee081cd70a",
    "gitBranch": "main",
    "buildTime": "2025-11-30T12:56:19.330Z"
  },
  "/node_modules/@martini-kit/core/GameRuntime.ts": "/**\n * GameRuntime - Host-authoritative game state manager\n *\n * v2: Simplified, no determinism, no prediction, no rollback.\n * The host runs the game, clients mirror the state.\n */\n\nimport type { GameDefinition } from './defineGame.js';\nimport type { Transport, WireMessage, RuntimeConfig } from './transport.js';\nimport { generateDiff, applyPatch, deepClone, type Patch } from './sync.js';\nimport { SeededRandom } from './SeededRandom.js';\nimport type { LobbyState, GamePhase, PhaseChangeContext, PlayerPresence } from './lobby.js';\n\ntype StateChangeCallback<TState> = (state: TState) => void;\ntype EventCallback = (senderId: string, eventName: string, payload: any) => void;\n\n/**\n * Extended runtime configuration with strict mode\n */\nexport interface GameRuntimeConfig extends RuntimeConfig {\n  /** Throw errors instead of warnings (recommended for development) */\n  strict?: boolean;\n\n  /**\n   * Validate that all playerIds are initialized in setup()\n   * Throws an error if strictPlayerInit is true, warns otherwise\n   * @default false\n   */\n  strictPlayerInit?: boolean;\n\n  /**\n   * Key in state where players are stored (for validation)\n   * @default 'players'\n   */\n  playersKey?: string;\n}\n\nexport class GameRuntime<TState = any> {\n  private state: TState = {} as TState;\n  private previousState: TState = {} as TState;\n  private _isHost: boolean;\n  private syncIntervalId: any = null;\n  private syncTickerId: any = null;\n  private unsubscribes: Array<() => void> = [];\n  private strict: boolean;\n  private actionCounter: number = 100000; // For seeding action random (start high to avoid LCG collisions)\n\n  // Lobby system state\n  private lobbyTimeoutId: any = null;\n  private hasLobby: boolean = false;\n\n  private stateChangeCallbacks: StateChangeCallback<TState>[] = [];\n  private eventCallbacks: Map<string, EventCallback[]> = new Map();\n  private patchListeners: Array<(patches: Patch[]) => void> = [];\n  private lastSyncSent: number = Date.now();\n  private readonly heartbeatIntervalMs = 100;\n\n  constructor(\n    private gameDef: GameDefinition<TState>,\n    private transport: Transport,\n    private config: GameRuntimeConfig\n  ) {\n    this._isHost = config.isHost;\n    this.strict = config.strict ?? false;\n\n    // Initialize state\n    const initialPlayerIds = config.playerIds || [];\n    if (gameDef.setup) {\n      // Create deterministic random for setup (same seed for all clients)\n      const setupRandom = new SeededRandom(12345);\n      this.state = gameDef.setup({ playerIds: initialPlayerIds, random: setupRandom });\n    }\n    this.previousState = deepClone(this.state);\n\n    // Validate player initialization (dev mode)\n    if (process.env.NODE_ENV !== 'production' && initialPlayerIds.length > 0) {\n      this.validatePlayerInitialization(initialPlayerIds);\n    }\n\n    // Initialize lobby system if configured\n    if (gameDef.lobby) {\n      this.hasLobby = true;\n      this.injectLobbyState();\n      this.injectLobbyActions();\n      this.startLobbyPhase();\n    }\n\n    // Setup transport listeners\n    this.setupTransport();\n\n    // Start sync loop if host\n    if (this._isHost) {\n      const syncInterval = config.syncInterval || 13; // ~75 FPS default for smoother arrivals\n      this.startSyncLoop(syncInterval);\n    }\n  }\n\n  /**\n   * Get current state (read-only, typed)\n   */\n  getState(): TState {\n    return this.state;\n  }\n\n  /**\n   * Check if this runtime is the host\n   */\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  /**\n   * Get the current player's ID\n   *\n   * @returns The unique player ID for this client\n   *\n   * @example\n   * ```ts\n   * const myId = runtime.getMyPlayerId();\n   * console.log('My player ID:', myId);\n   * ```\n   */\n  getMyPlayerId(): string {\n    return this.transport.getPlayerId();\n  }\n\n  /**\n   * Get transport (for adapters to check isHost, getPlayerId, etc)\n   * @internal\n   */\n  getTransport(): Transport {\n    return this.transport;\n  }\n\n  /**\n   * Directly mutate state (for adapters only - bypasses actions)\n   * Only the host should call this\n   * @internal\n   */\n  mutateState(mutator: (state: TState) => void): void {\n    if (!this._isHost) {\n      this.handleError('mutateState called on non-host - ignoring');\n      return;\n    }\n    mutator(this.state);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Execute an action (validates input, applies to state, broadcasts)\n   * @param actionName - Name of the action to execute\n   * @param input - Action payload/input data\n   * @param targetId - Optional target player ID (defaults to caller's ID)\n   */\n  submitAction(actionName: string, input: any, targetId?: string): void {\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined in game');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      const suggestion = this.findClosestMatch(actionName, availableActions);\n\n      let errorMsg = `Action \"${actionName}\" not found.`;\n\n      if (availableActions.length > 0) {\n        errorMsg += `\\n\\nAvailable actions: ${availableActions.join(', ')}`;\n        if (suggestion) {\n          errorMsg += `\\n\\nDid you mean \"${suggestion}\"?`;\n        }\n      } else {\n        errorMsg += '\\n\\nNo actions are defined in your game.';\n      }\n\n      this.handleError(errorMsg);\n      return;\n    }\n\n    const playerId = this.transport.getPlayerId();\n\n    // Create deterministic random for this action\n    const actionSeed = this.actionCounter++;\n    const actionRandom = new SeededRandom(actionSeed);\n\n    const context = {\n      playerId,                          // Who called submitAction\n      targetId: targetId || playerId,    // Who is affected (defaults to caller)\n      isHost: this._isHost,\n      random: actionRandom\n    };\n\n    // If we're the host, apply immediately\n    if (this._isHost) {\n      action.apply(this.state, context, input);\n      this.notifyStateChange();\n    }\n\n    // Broadcast action to all peers (include actionSeed for determinism)\n    this.transport.send({\n      type: 'action',\n      payload: { actionName, input, context, actionSeed },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcastEvent(eventName: string, payload: any): void {\n    const playerId = this.transport.getPlayerId();\n    this.transport.send({\n      type: 'event',\n      payload: { eventName, payload },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Listen for custom events\n   */\n  onEvent(eventName: string, callback: EventCallback): () => void {\n    if (!this.eventCallbacks.has(eventName)) {\n      this.eventCallbacks.set(eventName, []);\n    }\n    this.eventCallbacks.get(eventName)!.push(callback);\n\n    return () => {\n      const callbacks = this.eventCallbacks.get(eventName);\n      if (callbacks) {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Wait until the desired number of players (including self) are present.\n   * Helpful for P2P transports where peers join asynchronously.\n   *\n   * @deprecated Use the lobby system instead for better player coordination:\n   * ```ts\n   * defineGame({\n   *   lobby: {\n   *     minPlayers: 2,\n   *     requireAllReady: true\n   *   }\n   * })\n   * ```\n   * This method is automatically skipped when lobby system is enabled.\n   */\n  async waitForPlayers(minPlayers: number, options: { timeoutMs?: number; includeSelf?: boolean } = {}): Promise<void> {\n    // Warn if lobby system is enabled\n    if (this.hasLobby) {\n      console.warn(\n        '[GameRuntime] waitForPlayers() is deprecated when using the lobby system. ' +\n        'The lobby automatically manages player coordination via minPlayers config.'\n      );\n      return;\n    }\n\n    const includeSelf = options.includeSelf !== false;\n    const target = Math.max(1, minPlayers);\n    const getCount = () => (includeSelf ? 1 : 0) + this.transport.getPeerIds().length;\n\n    if (getCount() >= target) return;\n\n    // Attempt transport-level readiness if available (e.g., Trystero waitForReady)\n    const maybeWaitForReady = (this.transport as any).waitForReady;\n    if (typeof maybeWaitForReady === 'function') {\n      try {\n        await maybeWaitForReady.call(this.transport);\n      } catch {\n        // Ignore readiness errors here; onPeerJoin may still fire.\n      }\n      if (getCount() >= target) return;\n    }\n\n    await new Promise<void>((resolve, reject) => {\n      let resolved = false;\n      const timeout =\n        options.timeoutMs && options.timeoutMs > 0\n          ? setTimeout(() => {\n              if (!resolved) {\n                resolved = true;\n                reject(new Error(`Timed out waiting for ${target} players`));\n              }\n            }, options.timeoutMs)\n          : null;\n\n      const unsubscribe = this.transport.onPeerJoin(() => {\n        if (getCount() >= target && !resolved) {\n          resolved = true;\n          if (timeout) clearTimeout(timeout);\n          unsubscribe();\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Listen for state changes (typed)\n   */\n  onChange(callback: StateChangeCallback<TState>): () => void {\n    this.stateChangeCallbacks.push(callback);\n    return () => {\n      const index = this.stateChangeCallbacks.indexOf(callback);\n      if (index !== -1) this.stateChangeCallbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * Subscribe to state patches as they're generated\n   * This allows DevTools to reuse the patches that GameRuntime already computed\n   * instead of re-cloning and re-diffing the state\n   */\n  onPatch(listener: (patches: Patch[]) => void): () => void {\n    this.patchListeners.push(listener);\n\n    return () => {\n      const index = this.patchListeners.indexOf(listener);\n      if (index !== -1) {\n        this.patchListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    if (this.syncTickerId && typeof (globalThis as any).cancelAnimationFrame === 'function') {\n      (globalThis as any).cancelAnimationFrame(this.syncTickerId);\n    }\n    this.unsubscribes.forEach(unsub => unsub());\n    this.unsubscribes = [];\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  private setupTransport(): void {\n    // Listen for incoming messages\n    this.unsubscribes.push(\n      this.transport.onMessage((msg, senderId) => {\n        this.handleMessage(msg, senderId);\n      })\n    );\n\n    // Listen for peer join\n    this.unsubscribes.push(\n      this.transport.onPeerJoin((peerId) => {\n        // Use lobby handler if lobby system enabled\n        if (this.hasLobby) {\n          this.handlePeerJoinWithLobby(peerId);\n        } else {\n          // Legacy behavior (no lobby)\n          if (this.gameDef.onPlayerJoin) {\n            this.gameDef.onPlayerJoin(this.state, peerId);\n          }\n        }\n\n        // If we're the host, send full state to new peer\n        if (this._isHost) {\n          this.transport.send({\n            type: 'state_sync',\n            payload: { fullState: this.state }\n          }, peerId);\n        }\n      })\n    );\n\n    // Listen for peer leave\n    this.unsubscribes.push(\n      this.transport.onPeerLeave((peerId) => {\n        // Use lobby handler if lobby system enabled\n        if (this.hasLobby) {\n          this.handlePeerLeaveWithLobby(peerId);\n        } else {\n          // Legacy behavior (no lobby)\n          if (this.gameDef.onPlayerLeave) {\n            this.gameDef.onPlayerLeave(this.state, peerId);\n          }\n        }\n      })\n    );\n  }\n\n  private handleMessage(msg: WireMessage, senderId: string): void {\n    switch (msg.type) {\n      case 'state_sync':\n        // Only clients should receive state syncs\n        if (!this._isHost) {\n          this.handleStateSync(msg.payload);\n        }\n        break;\n\n      case 'heartbeat':\n        // Lightweight keep-alive to keep arrival cadence stable (clients only)\n        if (!this._isHost) {\n          this.notifyStateChange();\n        }\n        break;\n\n      case 'action':\n        // Only host processes actions from clients\n        if (this._isHost && senderId !== this.transport.getPlayerId()) {\n          this.handleActionFromClient(msg.payload);\n        }\n        break;\n\n      case 'event':\n        this.handleEvent(senderId, msg.payload);\n        break;\n    }\n  }\n\n  private handleStateSync(payload: any): void {\n    if (payload.fullState) {\n      // Full state replacement - generate patches from old → new\n      this.state = payload.fullState;\n      this.notifyStateChange(); // Will generate patches internally\n    } else if (payload.patches) {\n      // Apply patches and reuse them for listeners (zero-copy optimization)\n      for (const patch of payload.patches) {\n        applyPatch(this.state, patch);\n      }\n      this.notifyStateChange(payload.patches); // Reuse host-computed patches\n    } else if (payload?.heartbeat) {\n      // Keep arrival cadence stable even when no state diff\n      this.notifyStateChange();\n    }\n  }\n\n  private handleActionFromClient(payload: any): void {\n    const { actionName, input, context, actionSeed } = payload;\n\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      this.handleError(\n        `Unknown action from client: ${actionName}. Available: ${availableActions.join(', ')}`\n      );\n      return;\n    }\n\n    // Recreate the same random from the actionSeed for determinism\n    const contextWithRandom = {\n      ...context,\n      random: new SeededRandom(actionSeed)\n    };\n\n    // Apply action to state with context\n    action.apply(this.state, contextWithRandom, input);\n    this.notifyStateChange();\n  }\n\n  private handleEvent(senderId: string, payload: any): void {\n    const { eventName, payload: eventPayload } = payload;\n    const callbacks = this.eventCallbacks.get(eventName) || [];\n\n    for (const callback of callbacks) {\n      callback(senderId, eventName, eventPayload);\n    }\n  }\n\n  private syncState(now: number = Date.now()): void {\n    if (!this._isHost) return;\n\n    // Generate diff from last sync\n    const patches = generateDiff(this.previousState, this.state);\n\n    if (patches.length > 0) {\n      // Broadcast patches to all clients\n      this.transport.send({\n        type: 'state_sync',\n        payload: { patches }\n      });\n\n      // Notify all listeners (Inspector + state change callbacks)\n      this.notifyStateChange(patches);\n\n      this.lastSyncSent = now;\n    }\n\n    // Update baseline for next sync (even if no patches this time)\n    // This captures all mutations that happened since last sync\n    this.previousState = deepClone(this.state);\n\n    // Heartbeat to keep arrival cadence stable when idle\n    if (patches.length === 0 && now - this.lastSyncSent >= this.heartbeatIntervalMs) {\n      this.transport.send({\n        type: 'heartbeat',\n        payload: { heartbeat: true }\n      });\n      this.notifyStateChange();\n      this.lastSyncSent = now;\n    }\n  }\n\n  /**\n   * Start a jitter-resistant sync loop.\n   * Prefer requestAnimationFrame with an accumulator; fall back to setInterval when rAF is unavailable.\n   */\n  private startSyncLoop(intervalMs: number): void {\n    // Clear any existing loop\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n    if (this.syncTickerId && typeof (globalThis as any).cancelAnimationFrame === 'function') {\n      (globalThis as any).cancelAnimationFrame(this.syncTickerId);\n      this.syncTickerId = null;\n    }\n\n    const raf = (globalThis as any).requestAnimationFrame as\n      | ((cb: (time: number) => void) => number)\n      | undefined;\n    const useRaf = typeof raf === 'function';\n\n    if (useRaf) {\n      let last = performance.now();\n      const tick = (now: number) => {\n        if (!this._isHost) return; // bail if role changes\n        const elapsed = now - last;\n        if (elapsed >= intervalMs - 0.5) {\n          this.syncState(now);\n          last = now;\n        }\n        this.syncTickerId = raf!(tick) as any;\n      };\n      this.syncTickerId = raf(tick) as any;\n    } else {\n      this.syncIntervalId = setInterval(() => this.syncState(), intervalMs);\n    }\n  }\n\n  /**\n   * Unified state change notification - ensures all listeners are notified consistently\n   * @param patches - Optional pre-computed patches (e.g., from host sync). If not provided, generates them.\n   *\n   * Note: This does NOT update previousState. Only syncState() updates it (once per sync interval).\n   * This ensures optimal performance - we only clone state 20 times/sec (at sync) instead of\n   * on every action/mutation which could be 100+ times/sec.\n   */\n  private notifyStateChange(patches?: Patch[]): void {\n    // 1. Generate patches if not provided (and we have listeners that need them)\n    let computedPatches: Patch[] | null = null;\n    if (this.patchListeners.length > 0) {\n      computedPatches = patches ?? generateDiff(this.previousState, this.state);\n\n      // 2. Emit to patch listeners (Inspector)\n      if (computedPatches.length > 0) {\n        this.patchListeners.forEach(listener => {\n          try {\n            listener(computedPatches!);\n          } catch (error) {\n            console.error('Error in patch listener:', error);\n          }\n        });\n      }\n    }\n\n    // 3. Emit to state change listeners\n    for (const callback of this.stateChangeCallbacks) {\n      callback(this.state);\n    }\n\n    // Note: previousState is NOT updated here - only in syncState() for optimal performance\n  }\n\n  /**\n   * Handle errors with strict mode support\n   */\n  private handleError(message: string): void {\n    if (this.strict) {\n      throw new Error(`[martini-kit] ${message}`);\n    } else {\n      console.warn(`[martini-kit] ${message}`);\n    }\n  }\n\n  /**\n   * Find closest string match (for typo suggestions)\n   */\n  private findClosestMatch(input: string, options: string[]): string | null {\n    if (options.length === 0) return null;\n\n    let minDistance = Infinity;\n    let closest: string | null = null;\n\n    for (const option of options) {\n      const distance = this.levenshteinDistance(input.toLowerCase(), option.toLowerCase());\n      if (distance < minDistance && distance <= 3) { // Max 3 character difference\n        minDistance = distance;\n        closest = option;\n      }\n    }\n\n    return closest;\n  }\n\n  /**\n   * Calculate Levenshtein distance for typo detection\n   */\n  private levenshteinDistance(str1: string, str2: string): number {\n    const m = str1.length;\n    const n = str2.length;\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (str1[i - 1] === str2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = Math.min(\n            dp[i - 1][j] + 1,    // deletion\n            dp[i][j - 1] + 1,    // insertion\n            dp[i - 1][j - 1] + 1 // substitution\n          );\n        }\n      }\n    }\n\n    return dp[m][n];\n  }\n\n  /**\n   * Validate that all playerIds are initialized in state.players\n   * Emits warning or throws error based on configuration\n   */\n  private validatePlayerInitialization(playerIds: string[]): void {\n    const playersKey = this.config.playersKey || 'players';\n    const players = (this.state as any)[playersKey];\n\n    // Check if players key exists\n    if (!players || typeof players !== 'object') {\n      const message = [\n        `⚠️  Player initialization issue detected:`,\n        ``,\n        `Expected state.${playersKey} to be an object, but got: ${typeof players}`,\n        ``,\n        `Fix: Initialize players in setup():`,\n        `  setup: ({ playerIds }) => ({`,\n        `    ${playersKey}: Object.fromEntries(`,\n        `      playerIds.map(id => [id, { x: 100, y: 100 }])`,\n        `    )`,\n        `  })`\n      ].join('\\n');\n\n      if (this.config.strictPlayerInit) {\n        throw new Error(message);\n      } else {\n        console.warn(message);\n      }\n      return;\n    }\n\n    // Check if all playerIds are initialized\n    const missingPlayers = playerIds.filter(id => !(id in players));\n\n    if (missingPlayers.length > 0) {\n      const message = [\n        `⚠️  Player initialization issue detected:`,\n        ``,\n        `Expected ${playerIds.length} players, but ${missingPlayers.length} missing from state.${playersKey}`,\n        `Missing player IDs: ${missingPlayers.join(', ')}`,\n        ``,\n        `Fix: Initialize all players in setup():`,\n        `  setup: ({ playerIds }) => ({`,\n        `    ${playersKey}: Object.fromEntries(`,\n        `      playerIds.map((id, index) => [id, {`,\n        `        x: index * 100,`,\n        `        y: 100,`,\n        `        score: 0`,\n        `      }])`,\n        `    )`,\n        `  })`,\n        ``,\n        `Or use the createPlayers helper:`,\n        `  import { createPlayers } from '@martini-kit/core';`,\n        ``,\n        `  setup: ({ playerIds }) => ({`,\n        `    ${playersKey}: createPlayers(playerIds, (id, index) => ({`,\n        `      x: index * 100, y: 100, score: 0`,\n        `    }))`,\n        `  })`\n      ].join('\\n');\n\n      if (this.config.strictPlayerInit) {\n        throw new Error(message);\n      } else {\n        console.warn(message);\n      }\n    }\n  }\n\n  // ============================================================================\n  // Lobby System (Private methods)\n  // ============================================================================\n\n  /**\n   * Inject lobby metadata into state\n   */\n  private injectLobbyState(): void {\n    const myId = this.transport.getPlayerId();\n\n    (this.state as any).__lobby = {\n      phase: 'lobby' as GamePhase,\n      players: {\n        [myId]: {\n          playerId: myId,\n          ready: false,\n          joinedAt: Date.now()\n        } as PlayerPresence\n      },\n      config: this.gameDef.lobby!,\n      startedAt: undefined,\n      endedAt: undefined\n    } as LobbyState;\n  }\n\n  /**\n   * Inject built-in lobby actions\n   */\n  private injectLobbyActions(): void {\n    if (!this.gameDef.actions) {\n      this.gameDef.actions = {};\n    }\n\n    // Add internal lobby actions (prefixed with __)\n    this.gameDef.actions.__lobbyReady = {\n      apply: (state, context, input: { ready: boolean }) => {\n        this.handleLobbyReady(state, context, input);\n      }\n    };\n\n    this.gameDef.actions.__lobbyStart = {\n      apply: (state, context) => {\n        this.handleLobbyStart(state, context);\n      }\n    };\n\n    this.gameDef.actions.__lobbyEnd = {\n      apply: (state, context) => {\n        this.handleLobbyEnd(state, context);\n      }\n    };\n  }\n\n  /**\n   * Start lobby phase with auto-start timer\n   */\n  private startLobbyPhase(): void {\n    const lobbyConfig = this.gameDef.lobby!;\n\n    if (lobbyConfig.autoStartTimeout && lobbyConfig.autoStartTimeout > 0) {\n      this.lobbyTimeoutId = setTimeout(() => {\n        const lobbyState = (this.state as any).__lobby as LobbyState;\n        const playerCount = Object.keys(lobbyState.players).length;\n\n        if (playerCount >= lobbyConfig.minPlayers && lobbyState.phase === 'lobby') {\n          this.transitionPhase(this.state, 'playing', 'timeout');\n        }\n      }, lobbyConfig.autoStartTimeout);\n    }\n  }\n\n  /**\n   * Handle __lobbyReady action\n   */\n  private handleLobbyReady(state: TState, context: any, input: { ready: boolean }): void {\n    const lobbyState = (state as any).__lobby as LobbyState;\n    const presence = lobbyState.players[context.targetId];\n\n    if (!presence) return;\n\n    presence.ready = input.ready;\n\n    // Trigger callback\n    if (this.gameDef.onPlayerReady) {\n      this.gameDef.onPlayerReady(state, context.targetId, input.ready);\n    }\n\n    // Check if all players ready\n    this.checkLobbyStartConditions(state);\n  }\n\n  /**\n   * Handle __lobbyStart action\n   */\n  private handleLobbyStart(state: TState, context: any): void {\n    const lobbyState = (state as any).__lobby as LobbyState;\n    const lobbyConfig = this.gameDef.lobby!;\n\n    // Only host or all-ready can force start\n    if (!context.isHost && lobbyConfig.requireAllReady && !this.allPlayersReady(state)) {\n      return; // Ignore non-host start attempts if all-ready required\n    }\n\n    this.transitionPhase(state, 'playing', 'manual');\n  }\n\n  /**\n   * Handle __lobbyEnd action\n   */\n  private handleLobbyEnd(state: TState, _context: any): void {\n    this.transitionPhase(state, 'ended', 'manual');\n  }\n\n  /**\n   * Transition between phases\n   */\n  private transitionPhase(\n    state: TState,\n    newPhase: GamePhase,\n    reason: PhaseChangeContext['reason']\n  ): void {\n    const lobbyState = (state as any).__lobby as LobbyState;\n    const oldPhase = lobbyState.phase;\n\n    if (oldPhase === newPhase) return;\n\n    lobbyState.phase = newPhase;\n\n    if (newPhase === 'playing') {\n      lobbyState.startedAt = Date.now();\n      // Clear auto-start timeout\n      if (this.lobbyTimeoutId) {\n        clearTimeout(this.lobbyTimeoutId);\n        this.lobbyTimeoutId = null;\n      }\n      // Lock room (prevent late joins if configured)\n      if (!this.gameDef.lobby!.allowLateJoin) {\n        this.lockRoom();\n      }\n    } else if (newPhase === 'ended') {\n      lobbyState.endedAt = Date.now();\n    }\n\n    // Trigger callback\n    if (this.gameDef.onPhaseChange) {\n      this.gameDef.onPhaseChange(state, {\n        from: oldPhase,\n        to: newPhase,\n        reason,\n        timestamp: Date.now()\n      });\n    }\n\n    this.notifyStateChange();\n  }\n\n  /**\n   * Check if lobby can transition to playing\n   */\n  private checkLobbyStartConditions(state: TState): void {\n    const lobbyState = (state as any).__lobby as LobbyState;\n    const lobbyConfig = this.gameDef.lobby!;\n\n    if (lobbyState.phase !== 'lobby') return;\n\n    const players = Object.values(lobbyState.players) as PlayerPresence[];\n    const readyCount = players.filter(p => p.ready).length;\n\n    // Auto-start conditions\n    const hasMinPlayers = players.length >= lobbyConfig.minPlayers;\n    const allReady = lobbyConfig.requireAllReady ? readyCount === players.length : true;\n\n    if (hasMinPlayers && allReady) {\n      this.transitionPhase(state, 'playing', 'all_ready');\n    }\n  }\n\n  /**\n   * Check if all players are ready\n   */\n  private allPlayersReady(state: TState): boolean {\n    const lobbyState = (state as any).__lobby as LobbyState;\n    const players = Object.values(lobbyState.players) as PlayerPresence[];\n    return players.length > 0 && players.every(p => p.ready);\n  }\n\n  /**\n   * Handle peer join with lobby presence\n   */\n  private handlePeerJoinWithLobby(peerId: string): void {\n    const lobbyState = (this.state as any).__lobby as LobbyState;\n    const lobbyConfig = this.gameDef.lobby!;\n\n    // Check max players\n    if (lobbyConfig.maxPlayers && Object.keys(lobbyState.players).length >= lobbyConfig.maxPlayers) {\n      console.warn(`[Lobby] Max players (${lobbyConfig.maxPlayers}) reached, rejecting ${peerId}`);\n      // TODO: Implement transport.reject(peerId) when available\n      return;\n    }\n\n    // Check late join\n    if (lobbyState.phase === 'playing' && !lobbyConfig.allowLateJoin) {\n      console.warn(`[Lobby] Game in progress, late join disabled, rejecting ${peerId}`);\n      // TODO: Implement transport.reject(peerId) when available\n      return;\n    }\n\n    // Add player presence\n    lobbyState.players[peerId] = {\n      playerId: peerId,\n      ready: false,\n      joinedAt: Date.now()\n    };\n\n    // Call user's onPlayerJoin\n    if (this.gameDef.onPlayerJoin) {\n      this.gameDef.onPlayerJoin(this.state, peerId);\n    }\n\n    // Check if ready to start\n    this.checkLobbyStartConditions(this.state);\n  }\n\n  /**\n   * Handle peer leave with lobby cleanup\n   */\n  private handlePeerLeaveWithLobby(peerId: string): void {\n    const lobbyState = (this.state as any).__lobby as LobbyState;\n\n    // Remove player presence\n    delete lobbyState.players[peerId];\n\n    // Call user's onPlayerLeave\n    if (this.gameDef.onPlayerLeave) {\n      this.gameDef.onPlayerLeave(this.state, peerId);\n    }\n\n    // Check if game should end due to insufficient players\n    const lobbyConfig = this.gameDef.lobby!;\n    if (lobbyState.phase === 'playing') {\n      const remaining = Object.keys(lobbyState.players).length;\n      if (remaining < lobbyConfig.minPlayers) {\n        this.transitionPhase(this.state, 'ended', 'player_left');\n      }\n    }\n  }\n\n  /**\n   * Lock room (prevent new joins)\n   */\n  private lockRoom(): void {\n    const transport = this.transport as any;\n    if (typeof transport.lock === 'function') {\n      transport.lock();\n    } else {\n      // Warn if lock not implemented\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('[Lobby] Transport does not implement lock() - late joins cannot be prevented');\n      }\n    }\n  }\n}\n",
  "/node_modules/@martini-kit/core/Logger.ts": "/**\n * Logger - Unity-inspired logging system for martini-kit\n *\n * Provides structured logging with channels, levels, assertions, and DevTools integration.\n * Inspired by Unity's Debug class and browser console API.\n */\n\nexport type LogLevel = 'log' | 'warn' | 'error';\n\nexport interface LogEntry {\n\tlevel: LogLevel;\n\tchannel: string;\n\tmessage: string;\n\tdata: any[];\n\ttimestamp: number;\n\tcontext?: Record<string, any>;\n\tstack?: string;\n}\n\nexport type LogListener = (entry: LogEntry) => void;\n\nexport class Logger {\n\tprivate channelName: string;\n\tprivate listeners: LogListener[] = [];\n\tprivate enabled: boolean = true;\n\tprivate minLevel: LogLevel = 'log';\n\tprivate context?: Record<string, any>;\n\tprivate parentContext?: Record<string, any>;\n\tprivate includeStack: boolean = false;\n\tprivate timers: Map<string, number> = new Map();\n\n\tprivate static readonly LEVEL_PRIORITY: Record<LogLevel, number> = {\n\t\tlog: 0,\n\t\twarn: 1,\n\t\terror: 2\n\t};\n\n\tconstructor(channel: string = '', parentContext?: Record<string, any>) {\n\t\tthis.channelName = channel;\n\t\tthis.parentContext = parentContext;\n\t}\n\n\t/**\n\t * Log an informational message\n\t */\n\tlog(message: string, ...data: any[]): void {\n\t\tthis.writeLog('log', message, data);\n\t}\n\n\t/**\n\t * Log a warning message\n\t */\n\twarn(message: string, ...data: any[]): void {\n\t\tthis.writeLog('warn', message, data);\n\t}\n\n\t/**\n\t * Log an error message\n\t */\n\terror(message: string, ...data: any[]): void {\n\t\tthis.writeLog('error', message, data);\n\t}\n\n\t/**\n\t * Create a collapsible group in the console\n\t */\n\tgroup(label: string): void {\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(label);\n\t\t\tconsole.group(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * End the current group\n\t */\n\tgroupEnd(): void {\n\t\tif (this.enabled) {\n\t\t\tconsole.groupEnd();\n\t\t}\n\t}\n\n\t/**\n\t * Assert a condition, log error if false\n\t */\n\tassert(condition: boolean, message?: string): void {\n\t\tif (!condition) {\n\t\t\tconst assertMessage = message ? `Assertion failed: ${message}` : 'Assertion failed';\n\t\t\tthis.writeLog('error', assertMessage, []);\n\t\t}\n\t}\n\n\t/**\n\t * Start a performance timer\n\t */\n\ttime(label: string): void {\n\t\tthis.timers.set(label, performance.now());\n\t}\n\n\t/**\n\t * End a performance timer and log the duration\n\t */\n\ttimeEnd(label: string): void {\n\t\tconst startTime = this.timers.get(label);\n\n\t\tif (startTime === undefined) {\n\t\t\tthis.warn(`Timer \"${label}\" does not exist`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst duration = performance.now() - startTime;\n\t\tthis.timers.delete(label);\n\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(`${label}: ${duration.toFixed(2)}ms`);\n\t\t\tconsole.log(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * Create a child logger with a nested channel name\n\t */\n\tchannel(name: string): Logger {\n\t\tconst childChannel = this.channelName ? `${this.channelName}:${name}` : name;\n\t\tconst mergedContext = this.getMergedContext();\n\t\tconst child = new Logger(childChannel, mergedContext);\n\t\tchild.enabled = this.enabled;\n\t\tchild.minLevel = this.minLevel;\n\t\tchild.includeStack = this.includeStack;\n\t\treturn child;\n\t}\n\n\t/**\n\t * Register a listener for log entries (used by DevTools)\n\t */\n\tonLog(listener: LogListener): () => void {\n\t\tthis.listeners.push(listener);\n\n\t\t// Return unsubscribe function\n\t\treturn () => {\n\t\t\tconst index = this.listeners.indexOf(listener);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.listeners.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Enable or disable console output\n\t * Note: Listeners are still notified when disabled (for DevTools)\n\t */\n\tsetEnabled(enabled: boolean): void {\n\t\tthis.enabled = enabled;\n\t}\n\n\t/**\n\t * Set minimum log level (filters out lower priority logs)\n\t */\n\tsetMinLevel(level: LogLevel): void {\n\t\tthis.minLevel = level;\n\t}\n\n\t/**\n\t * Attach context data to all log entries\n\t */\n\tsetContext(context: Record<string, any> | undefined): void {\n\t\tthis.context = context;\n\t}\n\n\t/**\n\t * Include stack traces in all log entries\n\t */\n\tsetIncludeStack(include: boolean): void {\n\t\tthis.includeStack = include;\n\t}\n\n\t/**\n\t * Internal: Write a log entry\n\t */\n\tprivate writeLog(level: LogLevel, message: string, data: any[]): void {\n\t\t// Check if this level should be logged\n\t\tif (!this.shouldLog(level)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entry: LogEntry = {\n\t\t\tlevel,\n\t\t\tchannel: this.channelName,\n\t\t\tmessage,\n\t\t\tdata,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontext: this.getMergedContext()\n\t\t};\n\n\t\t// Add stack trace if needed\n\t\tif (this.includeStack || level === 'error') {\n\t\t\tentry.stack = this.captureStack();\n\t\t}\n\n\t\t// Notify listeners (even if console is disabled)\n\t\tthis.notifyListeners(entry);\n\n\t\t// Write to console if enabled\n\t\tif (this.enabled) {\n\t\t\tthis.writeToConsole(level, message, data);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a log level should be output\n\t */\n\tprivate shouldLog(level: LogLevel): boolean {\n\t\tconst levelPriority = Logger.LEVEL_PRIORITY[level];\n\t\tconst minPriority = Logger.LEVEL_PRIORITY[this.minLevel];\n\t\treturn levelPriority >= minPriority;\n\t}\n\n\t/**\n\t * Format message with channel prefix\n\t */\n\tprivate formatMessage(message: string): string {\n\t\tif (this.channelName) {\n\t\t\treturn `[${this.channelName}] ${message}`;\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Write to browser console\n\t */\n\tprivate writeToConsole(level: LogLevel, message: string, data: any[]): void {\n\t\tconst formatted = this.formatMessage(message);\n\n\t\tswitch (level) {\n\t\t\tcase 'log':\n\t\t\t\tconsole.log(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'warn':\n\t\t\t\tconsole.warn(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'error':\n\t\t\t\tconsole.error(formatted, ...data);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Notify all listeners\n\t */\n\tprivate notifyListeners(entry: LogEntry): void {\n\t\tfor (const listener of this.listeners) {\n\t\t\ttry {\n\t\t\t\tlistener(entry);\n\t\t\t} catch (err) {\n\t\t\t\t// Don't let listener errors break logging\n\t\t\t\tconsole.error('Error in log listener:', err);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Merge parent and local context\n\t */\n\tprivate getMergedContext(): Record<string, any> | undefined {\n\t\tif (!this.parentContext && !this.context) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\t...this.parentContext,\n\t\t\t...this.context\n\t\t};\n\t}\n\n\t/**\n\t * Capture current stack trace\n\t */\n\tprivate captureStack(): string {\n\t\tconst error = new Error();\n\t\tif (error.stack) {\n\t\t\t// Remove the first few lines (Error constructor, this function, writeLog)\n\t\t\tconst lines = error.stack.split('\\n');\n\t\t\treturn lines.slice(3).join('\\n');\n\t\t}\n\t\treturn '';\n\t}\n}\n\n/**\n * Default logger instance\n */\nexport const logger = new Logger('martini-kit');\n",
  "/node_modules/@martini-kit/core/PlayerManager.ts": "/**\n * PlayerManager - Unified player lifecycle management\n *\n * Prevents bugs by ensuring both initial players (in setup) and\n * late-joining players use the same factory logic.\n *\n * @example\n * ```ts\n * const playerManager = createPlayerManager({\n *   roles: ['fire', 'ice'],\n *   factory: (playerId, index) => ({\n *     x: index === 0 ? 200 : 600,\n *     y: 400,\n *     role: index === 0 ? 'fire' : 'ice',\n *   })\n * });\n *\n * export const game = defineGame({\n *   setup: ({ playerIds }) => ({\n *     players: playerManager.initialize(playerIds),\n *     inputs: {}\n *   }),\n *\n *   onPlayerJoin: (state, playerId) => {\n *     playerManager.handleJoin(state.players, playerId);\n *   },\n *\n *   onPlayerLeave: (state, playerId) => {\n *     playerManager.handleLeave(state.players, playerId);\n *   }\n * });\n * ```\n */\n\nimport type { GameDefinition, SetupContext } from './defineGame.js';\n\nexport interface PlayerFactory<TPlayer = any> {\n  /**\n   * Creates a player's initial state\n   *\n   * @param playerId - Unique player identifier\n   * @param index - Player index (0 for first player, 1 for second, etc.)\n   * @returns Player state object\n   */\n  (playerId: string, index: number): TPlayer;\n}\n\nexport interface PlayerManagerConfig<TPlayer = any> {\n  /**\n   * Factory function to create player state\n   */\n  factory: PlayerFactory<TPlayer>;\n\n  /**\n   * Optional: Role names for type-safe role assignment\n   * If provided, ensures roles are assigned in order\n   */\n  roles?: readonly string[];\n\n  /**\n   * Optional: Spawn points for each player index\n   * If provided, automatically sets x/y coordinates\n   */\n  spawnPoints?: Array<{ x: number; y: number; [key: string]: any }>;\n\n  /**\n   * Optional: World bounds for spawn clamping\n   * Prevents players from spawning outside the playable area\n   * Automatically clamps x/y coordinates returned by factory\n   *\n   * @example\n   * ```ts\n   * createPlayerManager({\n   *   worldBounds: { width: 800, height: 600 },\n   *   factory: (playerId, index) => ({\n   *     x: index * 1000, // Would spawn off-screen\n   *     y: 300\n   *   })\n   *   // Result: x is automatically clamped to 0-800\n   * });\n   * ```\n   */\n  worldBounds?: { width: number; height: number };\n}\n\nexport interface PlayerManager<TPlayer = any> {\n  /**\n   * Initialize all players for setup()\n   *\n   * @param playerIds - Array of player IDs from setup context\n   * @returns Record of player ID to player state\n   */\n  initialize(playerIds: string[]): Record<string, TPlayer>;\n\n  /**\n   * Handle a player joining mid-game\n   *\n   * @param players - Current players record from state\n   * @param playerId - ID of joining player\n   */\n  handleJoin(players: Record<string, TPlayer>, playerId: string): void;\n\n  /**\n   * Handle a player leaving\n   *\n   * @param players - Current players record from state\n   * @param playerId - ID of leaving player\n   */\n  handleLeave(players: Record<string, TPlayer>, playerId: string): void;\n\n  /**\n   * Get the configuration for a specific player index\n   * Useful for determining roles, spawn points, etc.\n   *\n   * @param index - Player index\n   */\n  getConfig(index: number): { role?: string; spawn?: { x: number; y: number } };\n\n  /**\n   * Create game definition handlers (setup, onPlayerJoin, onPlayerLeave)\n   *\n   * @returns Partial game definition with lifecycle handlers\n   *\n   * @example\n   * ```ts\n   * export const game = defineGame({\n   *   ...playerManager.createHandlers(),\n   *   actions: { ... }\n   * });\n   * ```\n   */\n  createHandlers<TState extends { players: Record<string, TPlayer> }>(): Pick<\n    GameDefinition<TState>,\n    'setup' | 'onPlayerJoin' | 'onPlayerLeave'\n  >;\n}\n\n/**\n * Create a PlayerManager instance\n *\n * @param config - Configuration for player management\n * @returns PlayerManager instance\n */\nexport function createPlayerManager<TPlayer = any>(\n  config: PlayerManagerConfig<TPlayer>\n): PlayerManager<TPlayer> {\n  const { factory, roles, spawnPoints, worldBounds } = config;\n\n  // Track current player count for role/spawn assignment\n  let playerCount = 0;\n\n  const createPlayer = (playerId: string, index: number): TPlayer => {\n    let player = factory(playerId, index);\n\n    // Auto-assign spawn point if provided\n    if (spawnPoints && spawnPoints[index]) {\n      player = { ...player, ...spawnPoints[index] };\n    }\n\n    // Auto-assign role if roles are defined\n    if (roles && roles[index]) {\n      player = { ...player, role: roles[index] } as TPlayer;\n    }\n\n    // Clamp spawn position to world bounds (if worldBounds provided and player has x/y)\n    if (worldBounds) {\n      const clamped = player as any;\n      if (typeof clamped.x === 'number') {\n        clamped.x = Math.max(0, Math.min(worldBounds.width, clamped.x));\n      }\n      if (typeof clamped.y === 'number') {\n        clamped.y = Math.max(0, Math.min(worldBounds.height, clamped.y));\n      }\n    }\n\n    return player;\n  };\n\n  return {\n    initialize(playerIds: string[]): Record<string, TPlayer> {\n      playerCount = playerIds.length;\n      return Object.fromEntries(\n        playerIds.map((id, index) => [id, createPlayer(id, index)])\n      );\n    },\n\n    handleJoin(players: Record<string, TPlayer>, playerId: string): void {\n      const currentCount = Object.keys(players).length;\n      players[playerId] = createPlayer(playerId, currentCount);\n      playerCount = currentCount + 1;\n    },\n\n    handleLeave(players: Record<string, TPlayer>, playerId: string): void {\n      delete players[playerId];\n      playerCount = Object.keys(players).length;\n    },\n\n    getConfig(index: number) {\n      return {\n        role: roles?.[index],\n        spawn: spawnPoints?.[index]\n      };\n    },\n\n    createHandlers<TState extends { players: Record<string, TPlayer> }>() {\n      const manager = this;\n      return {\n        setup: ({ playerIds }: SetupContext) => {\n          return {\n            players: manager.initialize(playerIds)\n          } as TState;\n        },\n\n        onPlayerJoin: (state: TState, playerId: string) => {\n          manager.handleJoin(state.players, playerId);\n        },\n\n        onPlayerLeave: (state: TState, playerId: string) => {\n          manager.handleLeave(state.players, playerId);\n        }\n      };\n    }\n  };\n}\n",
  "/node_modules/@martini-kit/core/SeededRandom.ts": "/**\n * SeededRandom - Deterministic Pseudo-Random Number Generator\n *\n * Provides a deterministic PRNG that produces the same sequence of\n * random numbers given the same seed. This ensures all clients in a\n * multiplayer game generate identical random values during setup and gameplay.\n *\n * Uses a simple Linear Congruential Generator (LCG) algorithm which is\n * fast, deterministic, and sufficient for game randomness (not cryptography).\n *\n * @example\n * ```typescript\n * const rng = new SeededRandom(12345);\n *\n * // Generate random numbers\n * rng.next();              // 0.0 to 1.0\n * rng.range(10, 20);       // 10 to 19 (integer)\n * rng.float(0, 100);       // 0.0 to 100.0 (float)\n * rng.choice(['a', 'b']);  // Random element\n * rng.shuffle([1, 2, 3]);  // Shuffled array\n * rng.boolean(0.7);        // 70% chance of true\n * ```\n */\n\nexport class SeededRandom {\n  private state: number;\n\n  // LCG parameters (from Numerical Recipes)\n  private readonly m = 0x80000000; // 2^31\n  private readonly a = 1103515245;\n  private readonly c = 12345;\n\n  /**\n   * Creates a new SeededRandom instance\n   *\n   * @param seed - Initial seed value (any integer)\n   */\n  constructor(seed: number) {\n    // Ensure seed is a positive integer\n    this.state = Math.abs(Math.floor(seed)) % this.m;\n    if (this.state === 0) this.state = 1;\n  }\n\n  /**\n   * Generate next random number in sequence\n   *\n   * @returns Random float in range [0, 1)\n   */\n  next(): number {\n    this.state = (this.a * this.state + this.c) % this.m;\n    return this.state / this.m;\n  }\n\n  /**\n   * Generate random integer in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random integer in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.range(0, 10);   // 0-9\n   * rng.range(10, 20);  // 10-19\n   * rng.range(-5, 5);   // -5 to 4\n   * ```\n   */\n  range(min: number, max: number): number {\n    if (min === max) return min;\n    return Math.floor(this.next() * (max - min)) + min;\n  }\n\n  /**\n   * Generate random float in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random float in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.float(0, 1);      // 0.0 to 0.999...\n   * rng.float(0, 100);    // 0.0 to 99.999...\n   * rng.float(-1, 1);     // -1.0 to 0.999...\n   * ```\n   */\n  float(min: number, max: number): number {\n    return this.next() * (max - min) + min;\n  }\n\n  /**\n   * Choose random element from array\n   *\n   * @param array - Array to choose from\n   * @returns Random element from array\n   * @throws Error if array is empty\n   *\n   * @example\n   * ```typescript\n   * rng.choice(['red', 'blue', 'green']);\n   * rng.choice([1, 2, 3, 4, 5]);\n   * ```\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.range(0, array.length)];\n  }\n\n  /**\n   * Shuffle array (Fisher-Yates algorithm)\n   * Returns a new shuffled array without modifying the original\n   *\n   * @param array - Array to shuffle\n   * @returns New shuffled array\n   *\n   * @example\n   * ```typescript\n   * const cards = ['A', 'K', 'Q', 'J'];\n   * const shuffled = rng.shuffle(cards);\n   * // cards is unchanged, shuffled is randomized\n   * ```\n   */\n  shuffle<T>(array: T[]): T[] {\n    if (array.length <= 1) return [...array];\n\n    const result = [...array];\n\n    // Fisher-Yates shuffle\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = this.range(0, i + 1);\n      [result[i], result[j]] = [result[j], result[i]];\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate random boolean with optional probability\n   *\n   * @param probability - Probability of returning true (0.0 to 1.0, default 0.5)\n   * @returns true or false based on probability\n   *\n   * @example\n   * ```typescript\n   * rng.boolean();      // 50% chance of true\n   * rng.boolean(0.7);   // 70% chance of true\n   * rng.boolean(1.0);   // Always true\n   * rng.boolean(0.0);   // Always false\n   * ```\n   */\n  boolean(probability = 0.5): boolean {\n    return this.next() < probability;\n  }\n}\n",
  "/node_modules/@martini-kit/core/defineGame.ts": "/**\n * High-level API for defining multiplayer games (v2)\n *\n * Host-authoritative: the host runs the game, others mirror the state.\n */\n\nimport type { SeededRandom } from './SeededRandom.js';\nimport type { LobbyConfig, PhaseChangeContext } from './lobby.js';\n\n/**\n * Setup context - provides initial player list and deterministic random\n */\nexport interface SetupContext {\n  /** Initial player IDs */\n  playerIds: string[];\n\n  /** Deterministic random number generator (seeded, same across all clients) */\n  random: SeededRandom;\n}\n\n/**\n * Action context - provides information about who submitted the action\n *\n * ⚠️ **IMPORTANT:** Use `targetId` (not `playerId`) for state mutations!\n *\n * @example Correct usage:\n * ```ts\n * actions: {\n *   move: {\n *     apply: (state, context, input) => {\n *       // ✅ CORRECT: Use targetId to identify which player to affect\n *       state.players[context.targetId].x += input.dx;\n *     }\n *   }\n * }\n * ```\n *\n * @example Incorrect usage:\n * ```ts\n * actions: {\n *   move: {\n *     apply: (state, context, input) => {\n *       // ❌ WRONG: playerId is who pressed the key, not who to affect\n *       state.players[context.playerId].x += input.dx;\n *     }\n *   }\n * }\n * ```\n *\n * @example When they differ:\n * ```ts\n * // Player A controls Player B's character:\n * runtime.submitAction('move', { dx: 10 }, 'player-B'); // targetId = 'player-B'\n *\n * // In the action:\n * apply: (state, context, input) => {\n *   console.log(context.playerId);  // 'player-A' (who submitted)\n *   console.log(context.targetId);  // 'player-B' (who to affect)\n * }\n * ```\n */\nexport interface ActionContext {\n  /**\n   * ID of the player who called submitAction()\n   *\n   * ⚠️ **Rarely needed in actions!** Most actions should use `targetId` instead.\n   *\n   * Use this for:\n   * - Logging who triggered an action\n   * - Checking permissions (e.g., \"can this player do this action?\")\n   * - Recording action history\n   *\n   * Do NOT use this for:\n   * - Modifying player state (use `targetId` instead)\n   * - Storing input data (use `targetId` instead)\n   */\n  playerId: string;\n\n  /**\n   * ID of the player who should be affected by this action\n   *\n   * ✅ **Use this for state mutations!**\n   *\n   * Defaults to `playerId` when no targetId is specified in submitAction().\n   *\n   * @example\n   * ```ts\n   * // Store input for the affected player\n   * state.inputs[context.targetId] = input;\n   *\n   * // Update the affected player's position\n   * state.players[context.targetId].x = input.x;\n   * ```\n   */\n  targetId: string;\n\n  /** Whether this action is being applied on the host */\n  isHost: boolean;\n\n  /** Deterministic random number generator (seeded per action) */\n  random: SeededRandom;\n}\n\n/**\n * Action definition with typed state and input\n */\nexport interface ActionDefinition<TState = any, TInput = any> {\n  /** Input validation schema (optional) */\n  input?: any;\n\n  /** Apply function - modifies state directly */\n  apply: (state: TState, context: ActionContext, input: TInput) => void;\n}\n\n/**\n * Game definition with typed state\n */\nexport interface GameDefinition<TState = any> {\n  /** Initial state factory */\n  setup?: (context: SetupContext) => TState;\n\n  /** Actions - only way to modify state (optional - sprite syncing is automatic) */\n  actions?: Record<string, ActionDefinition<TState, any>>;\n\n  /** Called when a player joins mid-game */\n  onPlayerJoin?: (state: TState, playerId: string) => void;\n\n  /** Called when a player leaves */\n  onPlayerLeave?: (state: TState, playerId: string) => void;\n\n  // ============ Lobby System (Optional) ============\n\n  /**\n   * Lobby configuration - enables multiplayer lifecycle management\n   *\n   * When provided, GameRuntime automatically:\n   * - Injects `__lobby` state with phase tracking\n   * - Provides `__lobbyReady`, `__lobbyStart`, `__lobbyEnd` actions\n   * - Enforces minPlayers/maxPlayers restrictions\n   * - Manages ready-up coordination\n   *\n   * @example\n   * ```ts\n   * export const game = defineGame({\n   *   lobby: {\n   *     minPlayers: 2,\n   *     maxPlayers: 4,\n   *     requireAllReady: true,\n   *     autoStartTimeout: 30000\n   *   },\n   *   // ... rest of definition\n   * });\n   * ```\n   */\n  lobby?: LobbyConfig;\n\n  /**\n   * Called when game phase changes\n   *\n   * Phases: 'lobby' → 'playing' → 'ended'\n   *\n   * Use this to reset game state, show/hide UI, etc.\n   *\n   * @example\n   * ```ts\n   * onPhaseChange: (state, { from, to, reason }) => {\n   *   console.log(`${from} → ${to} (${reason})`);\n   *\n   *   if (to === 'playing') {\n   *     // Reset ball, start timer, etc.\n   *   }\n   * }\n   * ```\n   */\n  onPhaseChange?: (state: TState, context: PhaseChangeContext) => void;\n\n  /**\n   * Called when a player changes ready state\n   *\n   * Use this to show ready indicators in lobby UI.\n   *\n   * @param state - Current game state\n   * @param playerId - Player who changed ready state\n   * @param ready - New ready state (true = ready, false = not ready)\n   *\n   * @example\n   * ```ts\n   * onPlayerReady: (state, playerId, ready) => {\n   *   console.log(`${playerId} is ${ready ? 'ready' : 'not ready'}`);\n   * }\n   * ```\n   */\n  onPlayerReady?: (state: TState, playerId: string, ready: boolean) => void;\n}\n\n/**\n * Define a multiplayer game with full TypeScript type safety\n *\n * @example\n * ```ts\n * interface GameState {\n *   players: Record<string, { x: number; y: number; score: number }>;\n * }\n *\n * const game = defineGame<GameState>({\n *   setup: ({ playerIds, random }) => ({\n *     players: Object.fromEntries(\n *       playerIds.map(id => [id, {\n *         x: random.range(0, 800),  // ✅ Deterministic!\n *         y: random.range(0, 600),\n *         score: 0\n *       }])\n *     )\n *   }),\n *\n *   actions: {\n *     move: {\n *       input: { x: 'number', y: 'number' },\n *       apply(state, context, input) {\n *         // ✅ Full type safety - autocomplete works!\n *         state.players[context.targetId].x = input.x;\n *         state.players[context.targetId].y = input.y;\n *       }\n *     }\n *   }\n * });\n * ```\n */\nexport function defineGame<TState = any>(\n  definition: GameDefinition<TState>\n): GameDefinition<TState> {\n  // Basic validation\n  if (!definition.actions) {\n    definition.actions = {};\n  }\n\n  // Validate actions if they exist\n  for (const [name, action] of Object.entries(definition.actions)) {\n    if (typeof action.apply !== 'function') {\n      throw new Error(`Action \"${name}\" must have an apply function`);\n    }\n  }\n\n  return definition;\n}\n",
  "/node_modules/@martini-kit/core/helpers.ts": "/**\n * SDK Helper Functions\n *\n * Utilities to reduce boilerplate and prevent common mistakes\n */\n\nimport type { ActionDefinition, ActionContext } from './defineGame.js';\n\n/**\n * Create a players record from player IDs\n *\n * Type-safe helper that ensures all players are initialized.\n *\n * @param playerIds - Array of player IDs\n * @param factory - Function to create each player's state\n * @returns Record mapping player IDs to player state\n *\n * @example\n * ```ts\n * setup: ({ playerIds }) => ({\n *   players: createPlayers(playerIds, (id, index) => ({\n *     x: index * 100,\n *     y: 400,\n *     score: 0\n *   }))\n * })\n * ```\n */\nexport function createPlayers<TPlayer>(\n  playerIds: string[],\n  factory: (playerId: string, index: number) => TPlayer\n): Record<string, TPlayer> {\n  return Object.fromEntries(playerIds.map((id, index) => [id, factory(id, index)]));\n}\n\n/**\n * Create a multi-type collision check function\n *\n * Combines multiple collision checks and warns if only one type is specified.\n * This helps prevent the common mistake of checking only blocks and forgetting\n * about bombs, enemies, or other obstacles.\n *\n * ⚠️ PREVENTS BUG: Forgetting to check multiple collision types\n * In grid-based games, you typically need to check:\n * - Blocks (walls, obstacles)\n * - Bombs (placed by players)\n * - Enemies (NPCs, other players)\n * - Hazards (traps, environmental dangers)\n *\n * @param checks - Array of named collision check functions\n * @returns Combined collision check function\n *\n * @example\n * ```ts\n * // ❌ BAD - Only checks blocks, players can walk through bombs!\n * collisionCheck: (x, y) => hasBlock(state.blocks, x, y)\n *\n * // ✅ GOOD - Checks all obstacle types\n * collisionCheck: createMultiCollisionCheck(\n *   { name: 'hard-blocks', fn: (x, y) => hasHardBlock(state.blocks, x, y) },\n *   { name: 'soft-blocks', fn: (x, y) => hasSoftBlock(state.blocks, x, y) },\n *   { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n * )\n * ```\n */\nexport function createMultiCollisionCheck(\n  ...checks: Array<{ name: string; fn: (x: number, y: number) => boolean }>\n): (x: number, y: number) => boolean {\n  if (checks.length === 0) {\n    console.warn(\n      '⚠️ createMultiCollisionCheck: No collision checks provided. ' +\n      'Entities will pass through everything!'\n    );\n    return () => false;\n  }\n\n  if (checks.length === 1) {\n    console.warn(\n      `⚠️ createMultiCollisionCheck: Only checking '${checks[0].name}'. ` +\n      `Did you forget to check: bombs? enemies? hazards?`\n    );\n  }\n\n  return (x: number, y: number) => checks.some(c => c.fn(x, y));\n}\n\n\n/**\n * Create a standard input action\n *\n * Returns an action definition that stores input in state[stateKey][context.targetId]\n *\n * @param stateKey - Key in state where inputs are stored (default: 'inputs')\n * @param options - Optional validation and callbacks\n * @returns Action definition\n *\n * @example\n * ```ts\n * actions: {\n *   move: createInputAction('inputs'),\n *\n *   shoot: createInputAction('inputs', {\n *     validate: (input) => input.angle !== undefined,\n *     onApply: (state, context, input) => {\n *       state.players[context.targetId].lastShot = Date.now();\n *     }\n *   })\n * }\n * ```\n */\nexport function createInputAction<TState = any, TInput = any>(\n  stateKey: string = 'inputs',\n  options?: {\n    /**\n     * Validate input before storing\n     * Return false to reject the input\n     */\n    validate?: (input: TInput) => boolean;\n\n    /**\n     * Called after input is stored\n     * Use for side effects or additional state updates\n     */\n    onApply?: (state: TState, context: ActionContext, input: TInput) => void;\n  }\n): ActionDefinition<TState, TInput> {\n  return {\n    apply: (state: TState, context: ActionContext, input: TInput) => {\n      // Validate input if validator provided\n      if (options?.validate && !options.validate(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`[${stateKey}] Invalid input rejected:`, input);\n        }\n        return;\n      }\n\n      // Initialize inputs object if needed\n      if (!(state as any)[stateKey]) {\n        (state as any)[stateKey] = {};\n      }\n\n      // Store input using targetId (NOT playerId!)\n      (state as any)[stateKey][context.targetId] = input;\n\n      // Call optional callback\n      options?.onApply?.(state, context, input);\n    }\n  };\n}\n\n/**\n * Create a host-only tick action\n *\n * Wraps game loop logic to only run on the host.\n * Useful for physics, AI, collision detection, etc.\n *\n * @param tickFn - Function to run each tick (host only)\n * @returns Action definition that only runs on host\n *\n * @example\n * ```ts\n * actions: {\n *   tick: createTickAction((state, delta, context) => {\n *     // This only runs on the host\n *     updatePhysics(state, delta);\n *     checkCollisions(state);\n *   })\n * }\n * ```\n */\nexport function createTickAction<TState = any, TInput = { delta: number }>(\n  tickFn: (state: TState, delta: number, context: ActionContext) => void\n): ActionDefinition<TState, TInput> {\n  return {\n    apply: (state: TState, context: ActionContext, input: TInput) => {\n      // Only run on host\n      if (!context.isHost) return;\n\n      const delta = (input as any).delta || 0;\n      tickFn(state, delta, context);\n    }\n  };\n}\n\n/**\n * Iterate over all player inputs in the state\n *\n * Eliminates the boilerplate `for (const [playerId, player] of Object.entries(state.players))`\n * loop and automatically handles missing inputs.\n *\n * @param state - Game state\n * @param callback - Function called for each player with input\n * @param options - Optional configuration\n *\n * @example\n * ```ts\n * tick: createTickAction((state, delta) => {\n *   forEachPlayerInput(state, (player, input, playerId) => {\n *     // Move player based on input\n *     const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);\n *     const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);\n *     player.x += dx * 150 * (delta / 1000);\n *     player.y += dy * 150 * (delta / 1000);\n *   });\n * })\n * ```\n *\n * @example With custom keys and filter\n * ```ts\n * forEachPlayerInput(state, (player, input) => {\n *   // Process movement for alive players only\n *   updateMovement(player, input);\n * }, {\n *   playersKey: 'characters',\n *   inputsKey: 'controls',\n *   filter: (player) => player.alive\n * });\n * ```\n */\nexport function forEachPlayerInput<\n  TState = any,\n  TPlayer = any,\n  TInput = any\n>(\n  state: TState,\n  callback: (player: TPlayer, input: TInput, playerId: string) => void,\n  options?: {\n    /** Key in state where players are stored (default: 'players') */\n    playersKey?: string;\n    /** Key in state where inputs are stored (default: 'inputs') */\n    inputsKey?: string;\n    /** Optional filter function to skip certain players */\n    filter?: (player: TPlayer, playerId: string) => boolean;\n  }\n): void {\n  const playersKey = options?.playersKey || 'players';\n  const inputsKey = options?.inputsKey || 'inputs';\n  const filter = options?.filter;\n\n  const players = (state as any)[playersKey];\n  const inputs = (state as any)[inputsKey];\n\n  if (!players || !inputs) return;\n\n  for (const [playerId, player] of Object.entries(players)) {\n    // Skip if filter rejects this player\n    if (filter && !filter(player as TPlayer, playerId)) {\n      continue;\n    }\n\n    const input = inputs[playerId];\n    if (!input) continue; // Skip if no input for this player\n\n    callback(player as TPlayer, input as TInput, playerId);\n  }\n}\n",
  "/node_modules/@martini-kit/core/index.ts": "/**\n * @martini-kit/core v2 - Engine-agnostic multiplayer SDK\n *\n * Host-authoritative state synchronization. Simple, clean, works with any engine.\n *\n * @packageDocumentation\n */\n\n// Core API\nexport { defineGame } from './defineGame.js';\nexport type { GameDefinition, ActionDefinition, ActionContext, SetupContext } from './defineGame.js';\n\n// Runtime\nexport { GameRuntime } from './GameRuntime.js';\nexport type { GameRuntimeConfig } from './GameRuntime.js';\nexport type {\n  Transport,\n  WireMessage,\n  RuntimeConfig,\n  TransportMetrics,\n  ConnectionState,\n  MessageStats\n} from './transport.js';\n\n// Utilities (kept from v1 for state sync)\nexport { generateDiff, applyPatch } from './sync.js';\nexport type { Patch } from './sync.js';\n\n// Deterministic Random\nexport { SeededRandom } from './SeededRandom.js';\n\n// Logger\nexport { Logger, logger } from './Logger.js';\nexport type { LogLevel, LogEntry, LogListener } from './Logger.js';\n\n// Lobby System\nexport type {\n  GamePhase,\n  PlayerPresence,\n  LobbyConfig,\n  LobbyState,\n  PhaseChangeContext,\n  WithLobby\n} from './lobby.js';\n\n// Helpers (Phase 1 - Bug Prevention)\nexport { createPlayerManager } from './PlayerManager.js';\nexport type { PlayerManager, PlayerManagerConfig, PlayerFactory } from './PlayerManager.js';\nexport { createPlayers, createMultiCollisionCheck, createInputAction, createTickAction, forEachPlayerInput } from './helpers.js';\n",
  "/node_modules/@martini-kit/core/lobby.ts": "/**\n * Lobby System - Production-grade multiplayer lifecycle management\n *\n * Inspired by industry standards:\n * - Photon PUN: OnJoinedLobby, OnConnectedToMaster callbacks\n * - Colyseus: Room.lock(), onCreate/onJoin/onLeave lifecycle\n * - PlayFab: Ready confirmation with timeout enforcement\n *\n * @module @martini-kit/core/lobby\n */\n\n/**\n * Game phase lifecycle\n *\n * - `lobby`: Players joining, getting ready\n * - `playing`: Active gameplay\n * - `ended`: Game finished, showing results\n */\nexport type GamePhase = 'lobby' | 'playing' | 'ended';\n\n/**\n * Player presence metadata (for lobby state)\n *\n * Automatically tracked by GameRuntime when lobby system is enabled.\n */\nexport interface PlayerPresence {\n  /** Unique player identifier */\n  playerId: string;\n\n  /** Whether player has confirmed ready */\n  ready: boolean;\n\n  /** Timestamp when player joined (ms since epoch) */\n  joinedAt: number;\n\n  /** Optional custom metadata (team, character, etc.) */\n  metadata?: Record<string, any>;\n}\n\n/**\n * Lobby configuration\n *\n * Add this to your GameDefinition to enable the lobby system.\n *\n * @example\n * ```ts\n * export const game = defineGame({\n *   lobby: {\n *     minPlayers: 2,\n *     maxPlayers: 4,\n *     requireAllReady: true,\n *     autoStartTimeout: 30000 // 30 seconds\n *   },\n *   // ... rest of game definition\n * });\n * ```\n */\nexport interface LobbyConfig {\n  /**\n   * Minimum players required to start the game\n   *\n   * Game cannot transition to 'playing' phase until this many players have joined.\n   */\n  minPlayers: number;\n\n  /**\n   * Maximum players allowed in the lobby\n   *\n   * Additional join attempts will be rejected once this limit is reached.\n   *\n   * @default Infinity (no limit)\n   */\n  maxPlayers?: number;\n\n  /**\n   * Require all players to ready-up before starting\n   *\n   * If true, game only starts when ALL players call `runtime.submitAction('__lobbyReady', { ready: true })`\n   * If false, host can force-start once minPlayers is met\n   *\n   * @default false\n   */\n  requireAllReady?: boolean;\n\n  /**\n   * Auto-start timeout (milliseconds)\n   *\n   * If set, game automatically transitions to 'playing' after this duration,\n   * provided minPlayers requirement is met.\n   *\n   * Useful fallback if some players forget to ready-up.\n   *\n   * @default undefined (no auto-start)\n   */\n  autoStartTimeout?: number;\n\n  /**\n   * Allow players to join mid-game\n   *\n   * If false, room is locked when transitioning to 'playing' phase.\n   * Late join attempts will be rejected.\n   *\n   * @default false\n   */\n  allowLateJoin?: boolean;\n}\n\n/**\n * Phase change context\n *\n * Provided to onPhaseChange callback with details about the transition.\n */\nexport interface PhaseChangeContext {\n  /** Previous phase */\n  from: GamePhase;\n\n  /** New phase */\n  to: GamePhase;\n\n  /**\n   * Reason for the phase change\n   *\n   * - `manual`: Host called __lobbyStart or __lobbyEnd\n   * - `timeout`: autoStartTimeout elapsed\n   * - `all_ready`: All players ready (requireAllReady mode)\n   * - `player_left`: Player left, causing insufficient players\n   */\n  reason: 'manual' | 'timeout' | 'all_ready' | 'player_left';\n\n  /** Timestamp of the transition (ms since epoch) */\n  timestamp: number;\n}\n\n/**\n * Auto-injected lobby state (when lobby config is present)\n *\n * GameRuntime automatically injects this into your game state as `state.__lobby`\n *\n * @example\n * ```ts\n * // In your scene\n * const state = runtime.getState();\n * const lobbyState = (state as any).__lobby;\n *\n * if (lobbyState.phase === 'lobby') {\n *   // Show lobby UI\n * } else if (lobbyState.phase === 'playing') {\n *   // Show gameplay\n * }\n * ```\n */\nexport interface LobbyState {\n  /** Current game phase */\n  phase: GamePhase;\n\n  /** Player presence tracking */\n  players: Record<string, PlayerPresence>;\n\n  /** Copy of lobby config (read-only) */\n  config: LobbyConfig;\n\n  /** Timestamp when 'playing' phase started */\n  startedAt?: number;\n\n  /** Timestamp when 'ended' phase started */\n  endedAt?: number;\n}\n\n/**\n * Helper type for user state augmented with lobby\n *\n * Use this for type-safe access to __lobby\n *\n * @example\n * ```ts\n * interface MyGameState {\n *   players: Record<string, { x: number; y: number }>;\n * }\n *\n * const state = runtime.getState() as WithLobby<MyGameState>;\n * console.log(state.__lobby.phase); // ✅ Type-safe\n * ```\n */\nexport type WithLobby<TState> = TState & {\n  __lobby: LobbyState;\n};\n",
  "/node_modules/@martini-kit/core/sync.ts": "/**\n * State synchronization using diffs/patches\n * Kept from v1 because it's efficient and engine-agnostic\n */\n\nexport interface Patch {\n  op: 'replace' | 'add' | 'remove';\n  path: string[];\n  value?: any;\n}\n\n/**\n * Generate a minimal diff between two states\n */\nexport function generateDiff(oldState: any, newState: any): Patch[] {\n  const patches: Patch[] = [];\n\n  function diff(oldVal: any, newVal: any, path: string[] = []) {\n    // Type change or primitive difference\n    if (typeof oldVal !== typeof newVal || oldVal === null || newVal === null) {\n      if (oldVal !== newVal) {\n        patches.push({ op: 'replace', path, value: newVal });\n      }\n      return;\n    }\n\n    // Array handling\n    if (Array.isArray(newVal)) {\n      if (!Array.isArray(oldVal) || oldVal.length !== newVal.length) {\n        patches.push({ op: 'replace', path, value: newVal });\n        return;\n      }\n\n      for (let i = 0; i < newVal.length; i++) {\n        diff(oldVal[i], newVal[i], [...path, String(i)]);\n      }\n      return;\n    }\n\n    // Object handling\n    if (typeof newVal === 'object') {\n      const oldKeys = Object.keys(oldVal || {});\n      const newKeys = Object.keys(newVal || {});\n\n      // Check removed keys\n      for (const key of oldKeys) {\n        if (!(key in newVal)) {\n          patches.push({ op: 'remove', path: [...path, key] });\n        }\n      }\n\n      // Check added/changed keys\n      for (const key of newKeys) {\n        if (!(key in oldVal)) {\n          patches.push({ op: 'add', path: [...path, key], value: newVal[key] });\n        } else {\n          diff(oldVal[key], newVal[key], [...path, key]);\n        }\n      }\n      return;\n    }\n\n    // Primitive comparison\n    if (oldVal !== newVal) {\n      patches.push({ op: 'replace', path, value: newVal });\n    }\n  }\n\n  diff(oldState, newState);\n  return patches;\n}\n\n/**\n * Apply a patch to state (mutates state)\n */\nexport function applyPatch(state: any, patch: Patch): void {\n  const { op, path, value } = patch;\n\n  if (path.length === 0) {\n    throw new Error('Cannot patch root - path must have at least one element');\n  }\n\n  // Navigate to parent\n  let current = state;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (!(key in current)) {\n      current[key] = {};\n    }\n    current = current[key];\n  }\n\n  const finalKey = path[path.length - 1];\n\n  switch (op) {\n    case 'add':\n    case 'replace':\n      current[finalKey] = value;\n      break;\n\n    case 'remove':\n      if (Array.isArray(current)) {\n        current.splice(Number(finalKey), 1);\n      } else {\n        delete current[finalKey];\n      }\n      break;\n  }\n}\n\n/**\n * Deep clone an object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as any;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n\n  const cloned: any = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n",
  "/node_modules/@martini-kit/core/transport.ts": "/**\n * Transport interface - how messages flow between peers\n */\n\nexport interface WireMessage {\n  type: 'state_sync' | 'action' | 'player_join' | 'player_leave' | 'event' | 'heartbeat' | 'host_migration' | 'host_query' | 'host_announce';\n  payload?: any;\n  senderId?: string;\n  timestamp?: number;\n  sessionId?: string; // for heartbeat messages\n  newHost?: string; // for host migration\n  hostId?: string; // for host announce\n  [key: string]: any; // allow additional properties\n}\n\n/**\n * Connection state for transport observability\n */\nexport type ConnectionState = 'disconnected' | 'connecting' | 'connected';\n\n/**\n * Message statistics for transport metrics\n */\nexport interface MessageStats {\n  sent: number;\n  received: number;\n  errors: number;\n}\n\n/**\n * TransportMetrics - Optional interface for transport observability\n *\n * Inspired by libp2p's StatTransport and WebRTC's getStats() API.\n * Transports can optionally implement this interface to expose metrics\n * for debugging, monitoring, and DevTools integration.\n *\n * @example\n * ```typescript\n * const transport = new LocalTransport(config);\n * if (transport.metrics) {\n *   console.log('Connection state:', transport.metrics.getConnectionState());\n *\n *   transport.metrics.onConnectionChange((state) => {\n *     console.log('Connection changed:', state);\n *   });\n * }\n * ```\n */\nexport interface TransportMetrics {\n  /**\n   * Get current connection state\n   * @returns Current state: disconnected, connecting, or connected\n   */\n  getConnectionState(): ConnectionState;\n\n  /**\n   * Listen for connection state changes\n   * @param callback Function called when connection state changes\n   * @returns Unsubscribe function\n   */\n  onConnectionChange(callback: (state: ConnectionState) => void): () => void;\n\n  /**\n   * Get number of connected peers (excluding self)\n   * @returns Count of active peer connections\n   */\n  getPeerCount(): number;\n\n  /**\n   * Get message statistics (counters)\n   * @returns Object with sent/received/error counts\n   */\n  getMessageStats(): MessageStats;\n\n  /**\n   * Get round-trip latency in milliseconds (optional, transport-dependent)\n   * @returns Latency in ms, or undefined if not supported\n   */\n  getLatencyMs?(): number | undefined;\n\n  /**\n   * Reset all metrics counters (useful for testing)\n   */\n  resetStats?(): void;\n}\n\nexport interface Transport {\n  /** Send a message to specific peer or broadcast to all */\n  send(message: WireMessage, targetId?: string): void;\n\n  /** Listen for incoming messages */\n  onMessage(handler: (message: WireMessage, senderId: string) => void): () => void;\n\n  /** Listen for peer joining */\n  onPeerJoin(handler: (peerId: string) => void): () => void;\n\n  /** Listen for peer leaving */\n  onPeerLeave(handler: (peerId: string) => void): () => void;\n\n  /** Get current peer ID */\n  getPlayerId(): string;\n\n  /** Get all connected peer IDs */\n  getPeerIds(): string[];\n\n  /** Is this peer the host */\n  isHost(): boolean;\n\n  /**\n   * Lock the room - prevent new peers from joining\n   *\n   * Optional method for lobby system. When the game transitions from\n   * 'lobby' to 'playing' phase, this is called if `allowLateJoin: false`.\n   *\n   * Transports that don't implement this will emit a warning in development.\n   *\n   * @example\n   * ```typescript\n   * // In transport implementation (optional)\n   * lock() {\n   *   this.isLocked = true;\n   *   // Reject new connection attempts\n   * }\n   * ```\n   */\n  lock?(): void;\n\n  /**\n   * Optional metrics interface for observability\n   * Transports can implement this to expose connection state,\n   * message statistics, and other debugging information.\n   */\n  metrics?: TransportMetrics;\n}\n\nexport interface RuntimeConfig {\n  /** Is this instance the host (runs authoritative simulation) */\n  isHost: boolean;\n\n  /** Initial player IDs (optional, can be added dynamically) */\n  playerIds?: string[];\n\n  /** How often to sync state (ms) - default 16ms (60 FPS) */\n  syncInterval?: number;\n}\n",
  "/node_modules/@martini-kit/core/package.json": "{\n  \"name\": \"@martini-kit/core\",\n  \"version\": \"0.1.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}"
}