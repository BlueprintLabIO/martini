{
  "__metadata": {
    "version": "2.0.0-alpha.1",
    "gitSha": "aaf8286986fdd233c574cdee625d8c52f09f1caf",
    "gitBranch": "main",
    "buildTime": "2025-11-14T08:33:11.491Z"
  },
  "/node_modules/@martini-kit/core/GameRuntime.ts": "/**\n * GameRuntime - Host-authoritative game state manager\n *\n * v2: Simplified, no determinism, no prediction, no rollback.\n * The host runs the game, clients mirror the state.\n */\n\nimport type { GameDefinition } from './defineGame.js';\nimport type { Transport, WireMessage, RuntimeConfig } from './transport.js';\nimport { generateDiff, applyPatch, deepClone, type Patch } from './sync.js';\nimport { SeededRandom } from './SeededRandom.js';\n\ntype StateChangeCallback<TState> = (state: TState) => void;\ntype EventCallback = (senderId: string, eventName: string, payload: any) => void;\n\n/**\n * Extended runtime configuration with strict mode\n */\nexport interface GameRuntimeConfig extends RuntimeConfig {\n  /** Throw errors instead of warnings (recommended for development) */\n  strict?: boolean;\n}\n\nexport class GameRuntime<TState = any> {\n  private state: TState = {} as TState;\n  private previousState: TState = {} as TState;\n  private _isHost: boolean;\n  private syncIntervalId: any = null;\n  private unsubscribes: Array<() => void> = [];\n  private strict: boolean;\n  private actionCounter: number = 100000; // For seeding action random (start high to avoid LCG collisions)\n\n  private stateChangeCallbacks: StateChangeCallback<TState>[] = [];\n  private eventCallbacks: Map<string, EventCallback[]> = new Map();\n\n  constructor(\n    private gameDef: GameDefinition<TState>,\n    private transport: Transport,\n    private config: GameRuntimeConfig\n  ) {\n    this._isHost = config.isHost;\n    this.strict = config.strict ?? false;\n\n    // Initialize state\n    const initialPlayerIds = config.playerIds || [];\n    if (gameDef.setup) {\n      // Create deterministic random for setup (same seed for all clients)\n      const setupRandom = new SeededRandom(12345);\n      this.state = gameDef.setup({ playerIds: initialPlayerIds, random: setupRandom });\n    }\n    this.previousState = deepClone(this.state);\n\n    // Setup transport listeners\n    this.setupTransport();\n\n    // Start sync loop if host\n    if (this._isHost) {\n      const syncInterval = config.syncInterval || 50; // 20 FPS default\n      this.syncIntervalId = setInterval(() => this.syncState(), syncInterval);\n    }\n  }\n\n  /**\n   * Get current state (read-only, typed)\n   */\n  getState(): TState {\n    return this.state;\n  }\n\n  /**\n   * Check if this runtime is the host\n   */\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  /**\n   * Get transport (for adapters to check isHost, getPlayerId, etc)\n   * @internal\n   */\n  getTransport(): Transport {\n    return this.transport;\n  }\n\n  /**\n   * Directly mutate state (for adapters only - bypasses actions)\n   * Only the host should call this\n   * @internal\n   */\n  mutateState(mutator: (state: TState) => void): void {\n    if (!this._isHost) {\n      this.handleError('mutateState called on non-host - ignoring');\n      return;\n    }\n    mutator(this.state);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Execute an action (validates input, applies to state, broadcasts)\n   * @param actionName - Name of the action to execute\n   * @param input - Action payload/input data\n   * @param targetId - Optional target player ID (defaults to caller's ID)\n   */\n  submitAction(actionName: string, input: any, targetId?: string): void {\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined in game');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      const suggestion = this.findClosestMatch(actionName, availableActions);\n\n      let errorMsg = `Action \"${actionName}\" not found.`;\n\n      if (availableActions.length > 0) {\n        errorMsg += `\\n\\nAvailable actions: ${availableActions.join(', ')}`;\n        if (suggestion) {\n          errorMsg += `\\n\\nDid you mean \"${suggestion}\"?`;\n        }\n      } else {\n        errorMsg += '\\n\\nNo actions are defined in your game.';\n      }\n\n      this.handleError(errorMsg);\n      return;\n    }\n\n    const playerId = this.transport.getPlayerId();\n\n    // Create deterministic random for this action\n    const actionSeed = this.actionCounter++;\n    const actionRandom = new SeededRandom(actionSeed);\n\n    const context = {\n      playerId,                          // Who called submitAction\n      targetId: targetId || playerId,    // Who is affected (defaults to caller)\n      isHost: this._isHost,\n      random: actionRandom\n    };\n\n    // If we're the host, apply immediately\n    if (this._isHost) {\n      action.apply(this.state, context, input);\n      this.notifyStateChange();\n    }\n\n    // Broadcast action to all peers (include actionSeed for determinism)\n    this.transport.send({\n      type: 'action',\n      payload: { actionName, input, context, actionSeed },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcastEvent(eventName: string, payload: any): void {\n    const playerId = this.transport.getPlayerId();\n    this.transport.send({\n      type: 'event',\n      payload: { eventName, payload },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Listen for custom events\n   */\n  onEvent(eventName: string, callback: EventCallback): () => void {\n    if (!this.eventCallbacks.has(eventName)) {\n      this.eventCallbacks.set(eventName, []);\n    }\n    this.eventCallbacks.get(eventName)!.push(callback);\n\n    return () => {\n      const callbacks = this.eventCallbacks.get(eventName);\n      if (callbacks) {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Listen for state changes (typed)\n   */\n  onChange(callback: StateChangeCallback<TState>): () => void {\n    this.stateChangeCallbacks.push(callback);\n    return () => {\n      const index = this.stateChangeCallbacks.indexOf(callback);\n      if (index !== -1) this.stateChangeCallbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.unsubscribes.forEach(unsub => unsub());\n    this.unsubscribes = [];\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  private setupTransport(): void {\n    // Listen for incoming messages\n    this.unsubscribes.push(\n      this.transport.onMessage((msg, senderId) => {\n        this.handleMessage(msg, senderId);\n      })\n    );\n\n    // Listen for peer join\n    this.unsubscribes.push(\n      this.transport.onPeerJoin((peerId) => {\n        if (this.gameDef.onPlayerJoin) {\n          this.gameDef.onPlayerJoin(this.state, peerId);\n        }\n\n        // If we're the host, send full state to new peer\n        if (this._isHost) {\n          this.transport.send({\n            type: 'state_sync',\n            payload: { fullState: this.state }\n          }, peerId);\n        }\n      })\n    );\n\n    // Listen for peer leave\n    this.unsubscribes.push(\n      this.transport.onPeerLeave((peerId) => {\n        if (this.gameDef.onPlayerLeave) {\n          this.gameDef.onPlayerLeave(this.state, peerId);\n        }\n      })\n    );\n  }\n\n  private handleMessage(msg: WireMessage, senderId: string): void {\n    switch (msg.type) {\n      case 'state_sync':\n        // Only clients should receive state syncs\n        if (!this._isHost) {\n          this.handleStateSync(msg.payload);\n        }\n        break;\n\n      case 'action':\n        // Only host processes actions from clients\n        if (this._isHost && senderId !== this.transport.getPlayerId()) {\n          this.handleActionFromClient(msg.payload);\n        }\n        break;\n\n      case 'event':\n        this.handleEvent(senderId, msg.payload);\n        break;\n    }\n  }\n\n  private handleStateSync(payload: any): void {\n    if (payload.fullState) {\n      // Full state replacement\n      this.state = payload.fullState;\n      this.notifyStateChange();\n    } else if (payload.patches) {\n      // Apply patches\n      for (const patch of payload.patches) {\n        applyPatch(this.state, patch);\n      }\n      this.notifyStateChange();\n    }\n  }\n\n  private handleActionFromClient(payload: any): void {\n    const { actionName, input, context, actionSeed } = payload;\n\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      this.handleError(\n        `Unknown action from client: ${actionName}. Available: ${availableActions.join(', ')}`\n      );\n      return;\n    }\n\n    // Recreate the same random from the actionSeed for determinism\n    const contextWithRandom = {\n      ...context,\n      random: new SeededRandom(actionSeed)\n    };\n\n    // Apply action to state with context\n    action.apply(this.state, contextWithRandom, input);\n    this.notifyStateChange();\n  }\n\n  private handleEvent(senderId: string, payload: any): void {\n    const { eventName, payload: eventPayload } = payload;\n    const callbacks = this.eventCallbacks.get(eventName) || [];\n\n    for (const callback of callbacks) {\n      callback(senderId, eventName, eventPayload);\n    }\n  }\n\n  private syncState(): void {\n    if (!this._isHost) return;\n\n    // Generate diff\n    const patches = generateDiff(this.previousState, this.state);\n\n    if (patches.length > 0) {\n      // Broadcast patches to all clients\n      this.transport.send({\n        type: 'state_sync',\n        payload: { patches }\n      });\n\n      // Update previous state\n      this.previousState = deepClone(this.state);\n    }\n  }\n\n  private notifyStateChange(): void {\n    for (const callback of this.stateChangeCallbacks) {\n      callback(this.state);\n    }\n  }\n\n  /**\n   * Handle errors with strict mode support\n   */\n  private handleError(message: string): void {\n    if (this.strict) {\n      throw new Error(`[martini-kit] ${message}`);\n    } else {\n      console.warn(`[martini-kit] ${message}`);\n    }\n  }\n\n  /**\n   * Find closest string match (for typo suggestions)\n   */\n  private findClosestMatch(input: string, options: string[]): string | null {\n    if (options.length === 0) return null;\n\n    let minDistance = Infinity;\n    let closest: string | null = null;\n\n    for (const option of options) {\n      const distance = this.levenshteinDistance(input.toLowerCase(), option.toLowerCase());\n      if (distance < minDistance && distance <= 3) { // Max 3 character difference\n        minDistance = distance;\n        closest = option;\n      }\n    }\n\n    return closest;\n  }\n\n  /**\n   * Calculate Levenshtein distance for typo detection\n   */\n  private levenshteinDistance(str1: string, str2: string): number {\n    const m = str1.length;\n    const n = str2.length;\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (str1[i - 1] === str2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = Math.min(\n            dp[i - 1][j] + 1,    // deletion\n            dp[i][j - 1] + 1,    // insertion\n            dp[i - 1][j - 1] + 1 // substitution\n          );\n        }\n      }\n    }\n\n    return dp[m][n];\n  }\n}\n",
  "/node_modules/@martini-kit/core/Logger.ts": "/**\n * Logger - Unity-inspired logging system for martini-kit\n *\n * Provides structured logging with channels, levels, assertions, and DevTools integration.\n * Inspired by Unity's Debug class and browser console API.\n */\n\nexport type LogLevel = 'log' | 'warn' | 'error';\n\nexport interface LogEntry {\n\tlevel: LogLevel;\n\tchannel: string;\n\tmessage: string;\n\tdata: any[];\n\ttimestamp: number;\n\tcontext?: Record<string, any>;\n\tstack?: string;\n}\n\nexport type LogListener = (entry: LogEntry) => void;\n\nexport class Logger {\n\tprivate channelName: string;\n\tprivate listeners: LogListener[] = [];\n\tprivate enabled: boolean = true;\n\tprivate minLevel: LogLevel = 'log';\n\tprivate context?: Record<string, any>;\n\tprivate parentContext?: Record<string, any>;\n\tprivate includeStack: boolean = false;\n\tprivate timers: Map<string, number> = new Map();\n\n\tprivate static readonly LEVEL_PRIORITY: Record<LogLevel, number> = {\n\t\tlog: 0,\n\t\twarn: 1,\n\t\terror: 2\n\t};\n\n\tconstructor(channel: string = '', parentContext?: Record<string, any>) {\n\t\tthis.channelName = channel;\n\t\tthis.parentContext = parentContext;\n\t}\n\n\t/**\n\t * Log an informational message\n\t */\n\tlog(message: string, ...data: any[]): void {\n\t\tthis.writeLog('log', message, data);\n\t}\n\n\t/**\n\t * Log a warning message\n\t */\n\twarn(message: string, ...data: any[]): void {\n\t\tthis.writeLog('warn', message, data);\n\t}\n\n\t/**\n\t * Log an error message\n\t */\n\terror(message: string, ...data: any[]): void {\n\t\tthis.writeLog('error', message, data);\n\t}\n\n\t/**\n\t * Create a collapsible group in the console\n\t */\n\tgroup(label: string): void {\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(label);\n\t\t\tconsole.group(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * End the current group\n\t */\n\tgroupEnd(): void {\n\t\tif (this.enabled) {\n\t\t\tconsole.groupEnd();\n\t\t}\n\t}\n\n\t/**\n\t * Assert a condition, log error if false\n\t */\n\tassert(condition: boolean, message?: string): void {\n\t\tif (!condition) {\n\t\t\tconst assertMessage = message ? `Assertion failed: ${message}` : 'Assertion failed';\n\t\t\tthis.writeLog('error', assertMessage, []);\n\t\t}\n\t}\n\n\t/**\n\t * Start a performance timer\n\t */\n\ttime(label: string): void {\n\t\tthis.timers.set(label, performance.now());\n\t}\n\n\t/**\n\t * End a performance timer and log the duration\n\t */\n\ttimeEnd(label: string): void {\n\t\tconst startTime = this.timers.get(label);\n\n\t\tif (startTime === undefined) {\n\t\t\tthis.warn(`Timer \"${label}\" does not exist`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst duration = performance.now() - startTime;\n\t\tthis.timers.delete(label);\n\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(`${label}: ${duration.toFixed(2)}ms`);\n\t\t\tconsole.log(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * Create a child logger with a nested channel name\n\t */\n\tchannel(name: string): Logger {\n\t\tconst childChannel = this.channelName ? `${this.channelName}:${name}` : name;\n\t\tconst mergedContext = this.getMergedContext();\n\t\tconst child = new Logger(childChannel, mergedContext);\n\t\tchild.enabled = this.enabled;\n\t\tchild.minLevel = this.minLevel;\n\t\tchild.includeStack = this.includeStack;\n\t\treturn child;\n\t}\n\n\t/**\n\t * Register a listener for log entries (used by DevTools)\n\t */\n\tonLog(listener: LogListener): () => void {\n\t\tthis.listeners.push(listener);\n\n\t\t// Return unsubscribe function\n\t\treturn () => {\n\t\t\tconst index = this.listeners.indexOf(listener);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.listeners.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Enable or disable console output\n\t * Note: Listeners are still notified when disabled (for DevTools)\n\t */\n\tsetEnabled(enabled: boolean): void {\n\t\tthis.enabled = enabled;\n\t}\n\n\t/**\n\t * Set minimum log level (filters out lower priority logs)\n\t */\n\tsetMinLevel(level: LogLevel): void {\n\t\tthis.minLevel = level;\n\t}\n\n\t/**\n\t * Attach context data to all log entries\n\t */\n\tsetContext(context: Record<string, any> | undefined): void {\n\t\tthis.context = context;\n\t}\n\n\t/**\n\t * Include stack traces in all log entries\n\t */\n\tsetIncludeStack(include: boolean): void {\n\t\tthis.includeStack = include;\n\t}\n\n\t/**\n\t * Internal: Write a log entry\n\t */\n\tprivate writeLog(level: LogLevel, message: string, data: any[]): void {\n\t\t// Check if this level should be logged\n\t\tif (!this.shouldLog(level)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entry: LogEntry = {\n\t\t\tlevel,\n\t\t\tchannel: this.channelName,\n\t\t\tmessage,\n\t\t\tdata,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontext: this.getMergedContext()\n\t\t};\n\n\t\t// Add stack trace if needed\n\t\tif (this.includeStack || level === 'error') {\n\t\t\tentry.stack = this.captureStack();\n\t\t}\n\n\t\t// Notify listeners (even if console is disabled)\n\t\tthis.notifyListeners(entry);\n\n\t\t// Write to console if enabled\n\t\tif (this.enabled) {\n\t\t\tthis.writeToConsole(level, message, data);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a log level should be output\n\t */\n\tprivate shouldLog(level: LogLevel): boolean {\n\t\tconst levelPriority = Logger.LEVEL_PRIORITY[level];\n\t\tconst minPriority = Logger.LEVEL_PRIORITY[this.minLevel];\n\t\treturn levelPriority >= minPriority;\n\t}\n\n\t/**\n\t * Format message with channel prefix\n\t */\n\tprivate formatMessage(message: string): string {\n\t\tif (this.channelName) {\n\t\t\treturn `[${this.channelName}] ${message}`;\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Write to browser console\n\t */\n\tprivate writeToConsole(level: LogLevel, message: string, data: any[]): void {\n\t\tconst formatted = this.formatMessage(message);\n\n\t\tswitch (level) {\n\t\t\tcase 'log':\n\t\t\t\tconsole.log(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'warn':\n\t\t\t\tconsole.warn(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'error':\n\t\t\t\tconsole.error(formatted, ...data);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Notify all listeners\n\t */\n\tprivate notifyListeners(entry: LogEntry): void {\n\t\tfor (const listener of this.listeners) {\n\t\t\ttry {\n\t\t\t\tlistener(entry);\n\t\t\t} catch (err) {\n\t\t\t\t// Don't let listener errors break logging\n\t\t\t\tconsole.error('Error in log listener:', err);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Merge parent and local context\n\t */\n\tprivate getMergedContext(): Record<string, any> | undefined {\n\t\tif (!this.parentContext && !this.context) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\t...this.parentContext,\n\t\t\t...this.context\n\t\t};\n\t}\n\n\t/**\n\t * Capture current stack trace\n\t */\n\tprivate captureStack(): string {\n\t\tconst error = new Error();\n\t\tif (error.stack) {\n\t\t\t// Remove the first few lines (Error constructor, this function, writeLog)\n\t\t\tconst lines = error.stack.split('\\n');\n\t\t\treturn lines.slice(3).join('\\n');\n\t\t}\n\t\treturn '';\n\t}\n}\n\n/**\n * Default logger instance\n */\nexport const logger = new Logger('martini-kit');\n",
  "/node_modules/@martini-kit/core/SeededRandom.ts": "/**\n * SeededRandom - Deterministic Pseudo-Random Number Generator\n *\n * Provides a deterministic PRNG that produces the same sequence of\n * random numbers given the same seed. This ensures all clients in a\n * multiplayer game generate identical random values during setup and gameplay.\n *\n * Uses a simple Linear Congruential Generator (LCG) algorithm which is\n * fast, deterministic, and sufficient for game randomness (not cryptography).\n *\n * @example\n * ```typescript\n * const rng = new SeededRandom(12345);\n *\n * // Generate random numbers\n * rng.next();              // 0.0 to 1.0\n * rng.range(10, 20);       // 10 to 19 (integer)\n * rng.float(0, 100);       // 0.0 to 100.0 (float)\n * rng.choice(['a', 'b']);  // Random element\n * rng.shuffle([1, 2, 3]);  // Shuffled array\n * rng.boolean(0.7);        // 70% chance of true\n * ```\n */\n\nexport class SeededRandom {\n  private state: number;\n\n  // LCG parameters (from Numerical Recipes)\n  private readonly m = 0x80000000; // 2^31\n  private readonly a = 1103515245;\n  private readonly c = 12345;\n\n  /**\n   * Creates a new SeededRandom instance\n   *\n   * @param seed - Initial seed value (any integer)\n   */\n  constructor(seed: number) {\n    // Ensure seed is a positive integer\n    this.state = Math.abs(Math.floor(seed)) % this.m;\n    if (this.state === 0) this.state = 1;\n  }\n\n  /**\n   * Generate next random number in sequence\n   *\n   * @returns Random float in range [0, 1)\n   */\n  next(): number {\n    this.state = (this.a * this.state + this.c) % this.m;\n    return this.state / this.m;\n  }\n\n  /**\n   * Generate random integer in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random integer in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.range(0, 10);   // 0-9\n   * rng.range(10, 20);  // 10-19\n   * rng.range(-5, 5);   // -5 to 4\n   * ```\n   */\n  range(min: number, max: number): number {\n    if (min === max) return min;\n    return Math.floor(this.next() * (max - min)) + min;\n  }\n\n  /**\n   * Generate random float in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random float in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.float(0, 1);      // 0.0 to 0.999...\n   * rng.float(0, 100);    // 0.0 to 99.999...\n   * rng.float(-1, 1);     // -1.0 to 0.999...\n   * ```\n   */\n  float(min: number, max: number): number {\n    return this.next() * (max - min) + min;\n  }\n\n  /**\n   * Choose random element from array\n   *\n   * @param array - Array to choose from\n   * @returns Random element from array\n   * @throws Error if array is empty\n   *\n   * @example\n   * ```typescript\n   * rng.choice(['red', 'blue', 'green']);\n   * rng.choice([1, 2, 3, 4, 5]);\n   * ```\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.range(0, array.length)];\n  }\n\n  /**\n   * Shuffle array (Fisher-Yates algorithm)\n   * Returns a new shuffled array without modifying the original\n   *\n   * @param array - Array to shuffle\n   * @returns New shuffled array\n   *\n   * @example\n   * ```typescript\n   * const cards = ['A', 'K', 'Q', 'J'];\n   * const shuffled = rng.shuffle(cards);\n   * // cards is unchanged, shuffled is randomized\n   * ```\n   */\n  shuffle<T>(array: T[]): T[] {\n    if (array.length <= 1) return [...array];\n\n    const result = [...array];\n\n    // Fisher-Yates shuffle\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = this.range(0, i + 1);\n      [result[i], result[j]] = [result[j], result[i]];\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate random boolean with optional probability\n   *\n   * @param probability - Probability of returning true (0.0 to 1.0, default 0.5)\n   * @returns true or false based on probability\n   *\n   * @example\n   * ```typescript\n   * rng.boolean();      // 50% chance of true\n   * rng.boolean(0.7);   // 70% chance of true\n   * rng.boolean(1.0);   // Always true\n   * rng.boolean(0.0);   // Always false\n   * ```\n   */\n  boolean(probability = 0.5): boolean {\n    return this.next() < probability;\n  }\n}\n",
  "/node_modules/@martini-kit/core/defineGame.ts": "/**\n * High-level API for defining multiplayer games (v2)\n *\n * Host-authoritative: the host runs the game, others mirror the state.\n */\n\nimport type { SeededRandom } from './SeededRandom.js';\n\n/**\n * Setup context - provides initial player list and deterministic random\n */\nexport interface SetupContext {\n  /** Initial player IDs */\n  playerIds: string[];\n\n  /** Deterministic random number generator (seeded, same across all clients) */\n  random: SeededRandom;\n}\n\n/**\n * Action context - provides information about who submitted the action\n */\nexport interface ActionContext {\n  /** ID of the player who called submitAction */\n  playerId: string;\n\n  /** ID of the player being affected (defaults to playerId) */\n  targetId: string;\n\n  /** Whether this action is being applied on the host */\n  isHost: boolean;\n\n  /** Deterministic random number generator (seeded per action) */\n  random: SeededRandom;\n}\n\n/**\n * Action definition with typed state and input\n */\nexport interface ActionDefinition<TState = any, TInput = any> {\n  /** Input validation schema (optional) */\n  input?: any;\n\n  /** Apply function - modifies state directly */\n  apply: (state: TState, context: ActionContext, input: TInput) => void;\n}\n\n/**\n * Game definition with typed state\n */\nexport interface GameDefinition<TState = any> {\n  /** Initial state factory */\n  setup?: (context: SetupContext) => TState;\n\n  /** Actions - only way to modify state (optional - sprite syncing is automatic) */\n  actions?: Record<string, ActionDefinition<TState, any>>;\n\n  /** Called when a player joins mid-game */\n  onPlayerJoin?: (state: TState, playerId: string) => void;\n\n  /** Called when a player leaves */\n  onPlayerLeave?: (state: TState, playerId: string) => void;\n}\n\n/**\n * Define a multiplayer game with full TypeScript type safety\n *\n * @example\n * ```ts\n * interface GameState {\n *   players: Record<string, { x: number; y: number; score: number }>;\n * }\n *\n * const game = defineGame<GameState>({\n *   setup: ({ playerIds, random }) => ({\n *     players: Object.fromEntries(\n *       playerIds.map(id => [id, {\n *         x: random.range(0, 800),  // ✅ Deterministic!\n *         y: random.range(0, 600),\n *         score: 0\n *       }])\n *     )\n *   }),\n *\n *   actions: {\n *     move: {\n *       input: { x: 'number', y: 'number' },\n *       apply(state, context, input) {\n *         // ✅ Full type safety - autocomplete works!\n *         state.players[context.targetId].x = input.x;\n *         state.players[context.targetId].y = input.y;\n *       }\n *     }\n *   }\n * });\n * ```\n */\nexport function defineGame<TState = any>(\n  definition: GameDefinition<TState>\n): GameDefinition<TState> {\n  // Basic validation\n  if (!definition.actions) {\n    definition.actions = {};\n  }\n\n  // Validate actions if they exist\n  for (const [name, action] of Object.entries(definition.actions)) {\n    if (typeof action.apply !== 'function') {\n      throw new Error(`Action \"${name}\" must have an apply function`);\n    }\n  }\n\n  return definition;\n}\n",
  "/node_modules/@martini-kit/core/index.ts": "/**\n * @martini-kit/core v2 - Engine-agnostic multiplayer SDK\n *\n * Host-authoritative state synchronization. Simple, clean, works with any engine.\n *\n * @packageDocumentation\n */\n\n// Core API\nexport { defineGame } from './defineGame.js';\nexport type { GameDefinition, ActionDefinition, ActionContext, SetupContext } from './defineGame.js';\n\n// Runtime\nexport { GameRuntime } from './GameRuntime.js';\nexport type { GameRuntimeConfig } from './GameRuntime.js';\nexport type {\n  Transport,\n  WireMessage,\n  RuntimeConfig,\n  TransportMetrics,\n  ConnectionState,\n  MessageStats\n} from './transport.js';\n\n// Utilities (kept from v1 for state sync)\nexport { generateDiff, applyPatch } from './sync.js';\nexport type { Patch } from './sync.js';\n\n// Deterministic Random\nexport { SeededRandom } from './SeededRandom.js';\n\n// Logger\nexport { Logger, logger } from './Logger.js';\nexport type { LogLevel, LogEntry, LogListener } from './Logger.js';\n",
  "/node_modules/@martini-kit/core/sync.ts": "/**\n * State synchronization using diffs/patches\n * Kept from v1 because it's efficient and engine-agnostic\n */\n\nexport interface Patch {\n  op: 'replace' | 'add' | 'remove';\n  path: string[];\n  value?: any;\n}\n\n/**\n * Generate a minimal diff between two states\n */\nexport function generateDiff(oldState: any, newState: any): Patch[] {\n  const patches: Patch[] = [];\n\n  function diff(oldVal: any, newVal: any, path: string[] = []) {\n    // Type change or primitive difference\n    if (typeof oldVal !== typeof newVal || oldVal === null || newVal === null) {\n      if (oldVal !== newVal) {\n        patches.push({ op: 'replace', path, value: newVal });\n      }\n      return;\n    }\n\n    // Array handling\n    if (Array.isArray(newVal)) {\n      if (!Array.isArray(oldVal) || oldVal.length !== newVal.length) {\n        patches.push({ op: 'replace', path, value: newVal });\n        return;\n      }\n\n      for (let i = 0; i < newVal.length; i++) {\n        diff(oldVal[i], newVal[i], [...path, String(i)]);\n      }\n      return;\n    }\n\n    // Object handling\n    if (typeof newVal === 'object') {\n      const oldKeys = Object.keys(oldVal || {});\n      const newKeys = Object.keys(newVal || {});\n\n      // Check removed keys\n      for (const key of oldKeys) {\n        if (!(key in newVal)) {\n          patches.push({ op: 'remove', path: [...path, key] });\n        }\n      }\n\n      // Check added/changed keys\n      for (const key of newKeys) {\n        if (!(key in oldVal)) {\n          patches.push({ op: 'add', path: [...path, key], value: newVal[key] });\n        } else {\n          diff(oldVal[key], newVal[key], [...path, key]);\n        }\n      }\n      return;\n    }\n\n    // Primitive comparison\n    if (oldVal !== newVal) {\n      patches.push({ op: 'replace', path, value: newVal });\n    }\n  }\n\n  diff(oldState, newState);\n  return patches;\n}\n\n/**\n * Apply a patch to state (mutates state)\n */\nexport function applyPatch(state: any, patch: Patch): void {\n  const { op, path, value } = patch;\n\n  if (path.length === 0) {\n    throw new Error('Cannot patch root - path must have at least one element');\n  }\n\n  // Navigate to parent\n  let current = state;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (!(key in current)) {\n      current[key] = {};\n    }\n    current = current[key];\n  }\n\n  const finalKey = path[path.length - 1];\n\n  switch (op) {\n    case 'add':\n    case 'replace':\n      current[finalKey] = value;\n      break;\n\n    case 'remove':\n      if (Array.isArray(current)) {\n        current.splice(Number(finalKey), 1);\n      } else {\n        delete current[finalKey];\n      }\n      break;\n  }\n}\n\n/**\n * Deep clone an object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as any;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n\n  const cloned: any = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n",
  "/node_modules/@martini-kit/core/transport.ts": "/**\n * Transport interface - how messages flow between peers\n */\n\nexport interface WireMessage {\n  type: 'state_sync' | 'action' | 'player_join' | 'player_leave' | 'event' | 'heartbeat' | 'host_migration' | 'host_query' | 'host_announce';\n  payload?: any;\n  senderId?: string;\n  timestamp?: number;\n  sessionId?: string; // for heartbeat messages\n  newHost?: string; // for host migration\n  hostId?: string; // for host announce\n  [key: string]: any; // allow additional properties\n}\n\n/**\n * Connection state for transport observability\n */\nexport type ConnectionState = 'disconnected' | 'connecting' | 'connected';\n\n/**\n * Message statistics for transport metrics\n */\nexport interface MessageStats {\n  sent: number;\n  received: number;\n  errors: number;\n}\n\n/**\n * TransportMetrics - Optional interface for transport observability\n *\n * Inspired by libp2p's StatTransport and WebRTC's getStats() API.\n * Transports can optionally implement this interface to expose metrics\n * for debugging, monitoring, and DevTools integration.\n *\n * @example\n * ```typescript\n * const transport = new LocalTransport(config);\n * if (transport.metrics) {\n *   console.log('Connection state:', transport.metrics.getConnectionState());\n *\n *   transport.metrics.onConnectionChange((state) => {\n *     console.log('Connection changed:', state);\n *   });\n * }\n * ```\n */\nexport interface TransportMetrics {\n  /**\n   * Get current connection state\n   * @returns Current state: disconnected, connecting, or connected\n   */\n  getConnectionState(): ConnectionState;\n\n  /**\n   * Listen for connection state changes\n   * @param callback Function called when connection state changes\n   * @returns Unsubscribe function\n   */\n  onConnectionChange(callback: (state: ConnectionState) => void): () => void;\n\n  /**\n   * Get number of connected peers (excluding self)\n   * @returns Count of active peer connections\n   */\n  getPeerCount(): number;\n\n  /**\n   * Get message statistics (counters)\n   * @returns Object with sent/received/error counts\n   */\n  getMessageStats(): MessageStats;\n\n  /**\n   * Get round-trip latency in milliseconds (optional, transport-dependent)\n   * @returns Latency in ms, or undefined if not supported\n   */\n  getLatencyMs?(): number | undefined;\n\n  /**\n   * Reset all metrics counters (useful for testing)\n   */\n  resetStats?(): void;\n}\n\nexport interface Transport {\n  /** Send a message to specific peer or broadcast to all */\n  send(message: WireMessage, targetId?: string): void;\n\n  /** Listen for incoming messages */\n  onMessage(handler: (message: WireMessage, senderId: string) => void): () => void;\n\n  /** Listen for peer joining */\n  onPeerJoin(handler: (peerId: string) => void): () => void;\n\n  /** Listen for peer leaving */\n  onPeerLeave(handler: (peerId: string) => void): () => void;\n\n  /** Get current peer ID */\n  getPlayerId(): string;\n\n  /** Get all connected peer IDs */\n  getPeerIds(): string[];\n\n  /** Is this peer the host */\n  isHost(): boolean;\n\n  /**\n   * Optional metrics interface for observability\n   * Transports can implement this to expose connection state,\n   * message statistics, and other debugging information.\n   */\n  metrics?: TransportMetrics;\n}\n\nexport interface RuntimeConfig {\n  /** Is this instance the host (runs authoritative simulation) */\n  isHost: boolean;\n\n  /** Initial player IDs (optional, can be added dynamically) */\n  playerIds?: string[];\n\n  /** How often to sync state (ms) - default 50ms (20 FPS) */\n  syncInterval?: number;\n}\n",
  "/node_modules/@martini-kit/core/package.json": "{\n  \"name\": \"@martini-kit/core\",\n  \"version\": \"2.0.0-alpha.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}"
}