{
  "__metadata": {
    "version": "0.1.1",
    "gitSha": "787cdd6b4ec6f5ef8bee112ce2620e5dc7069710",
    "gitBranch": "main",
    "buildTime": "2025-11-30T09:33:22.596Z"
  },
  "/node_modules/@martini-kit/transport-iframe-bridge/IframeBridgeRelay.ts": "/**\n * IframeBridgeRelay - Parent window coordinator for iframe-based multiplayer\n *\n * Runs in the parent window and relays messages between sandboxed iframes.\n * Acts as a message hub - receives messages from one iframe and forwards to others.\n *\n * @example\n * ```typescript\n * // In parent window (IDE component)\n * const relay = new IframeBridgeRelay();\n *\n * // When iframes are created\n * relay.registerIframe('host-player-123', hostIframeElement);\n * relay.registerIframe('client-player-456', clientIframeElement);\n *\n * // Cleanup when done\n * relay.destroy();\n * ```\n */\n\nimport type { BridgeMessage } from './IframeBridgeTransport.js';\n\nexport interface PeerInfo {\n  playerId: string;\n  roomId: string;\n  iframe: HTMLIFrameElement;\n  isHost: boolean;\n  lastHeartbeat: number; // Timestamp of last activity\n}\n\nexport class IframeBridgeRelay {\n  private peers: Map<string, PeerInfo> = new Map();\n  private rooms: Map<string, Set<string>> = new Map(); // roomId → Set<playerId>\n  private messageHandler: ((event: MessageEvent) => void) | null = null;\n  private heartbeatInterval: ReturnType<typeof setInterval> | null = null;\n  private readonly HEARTBEAT_CHECK_MS = 5000; // Check every 5 seconds\n  private readonly PEER_TIMEOUT_MS = 60000; // Remove peers inactive for 60 seconds (accounts for browser throttling)\n\n  constructor() {\n    this.setupMessageListener();\n    this.startHeartbeatMonitor();\n  }\n\n  /**\n   * Set up listener for messages from iframes\n   */\n  private setupMessageListener(): void {\n    this.messageHandler = (event: MessageEvent) => {\n      const data = event.data as BridgeMessage;\n\n      // Ignore non-bridge messages\n      if (!data || !data.type || !data.type.startsWith('BRIDGE_')) {\n        return;\n      }\n\n      switch (data.type) {\n        case 'BRIDGE_REGISTER':\n          this.handleRegister(data, event.source as Window);\n          break;\n\n        case 'BRIDGE_SEND':\n          this.handleSend(data, event.source as Window);\n          break;\n\n        case 'BRIDGE_HEARTBEAT':\n          this.handleHeartbeat(data);\n          break;\n\n        case 'BRIDGE_PEER_LEAVE':\n          this.handlePeerLeave(data);\n          break;\n      }\n    };\n\n    window.addEventListener('message', this.messageHandler);\n  }\n\n  /**\n   * Handle peer registration\n   */\n  private handleRegister(data: BridgeMessage, source: Window): void {\n    const { playerId, roomId } = data;\n\n    // Find the iframe that sent this message\n    const iframe = Array.from(document.querySelectorAll('iframe')).find(\n      (iframe) => iframe.contentWindow === source\n    );\n\n    if (!iframe) {\n      console.warn('[IframeBridgeRelay] Could not find iframe for registration:', playerId);\n      return;\n    }\n\n    const existingPeer = this.peers.get(playerId);\n    if (existingPeer) {\n      existingPeer.iframe = iframe;\n      existingPeer.roomId = roomId;\n      existingPeer.lastHeartbeat = Date.now();\n      if (!this.rooms.has(roomId)) {\n        this.rooms.set(roomId, new Set());\n      }\n      this.rooms.get(roomId)!.add(playerId);\n      return;\n    }\n\n    // Determine if this is the host (first peer in room)\n    const room = this.rooms.get(roomId);\n    const isHost = !room || room.size === 0;\n\n    // Register peer with current timestamp as heartbeat\n    this.peers.set(playerId, {\n      playerId,\n      roomId,\n      iframe,\n      isHost,\n      lastHeartbeat: Date.now()\n    });\n\n    // Add to room\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n    this.rooms.get(roomId)!.add(playerId);\n\n    // Notify existing peers about new peer\n    const existingPeers = this.getPeersInRoom(roomId).filter(p => p.playerId !== playerId);\n    for (const peer of existingPeers) {\n      this.sendToIframe(peer.iframe, {\n        type: 'BRIDGE_PEER_JOIN',\n        roomId,\n        playerId: peer.playerId,\n        payload: { peerId: playerId }\n      });\n    }\n\n    // Notify new peer about existing peers\n    for (const peer of existingPeers) {\n      this.sendToIframe(iframe, {\n        type: 'BRIDGE_PEER_JOIN',\n        roomId,\n        playerId,\n        payload: { peerId: peer.playerId }\n      });\n    }\n  }\n\n  /**\n   * Handle message send from a peer\n   */\n  private handleSend(data: BridgeMessage, source: Window): void {\n    const { playerId, roomId, payload } = data;\n\n    if (!payload?.message) {\n      console.warn('[IframeBridgeRelay] No message in BRIDGE_SEND');\n      return;\n    }\n\n    const sender = this.peers.get(playerId);\n    if (!sender) {\n      console.warn('[IframeBridgeRelay] Unknown sender:', playerId);\n\n      // Find the iframe that sent this message and notify it to reconnect\n      const iframe = Array.from(document.querySelectorAll('iframe')).find(\n        (iframe) => iframe.contentWindow === source\n      );\n\n      if (iframe?.contentWindow) {\n        iframe.contentWindow.postMessage({\n          type: 'BRIDGE_ERROR',\n          roomId,\n          playerId,\n          payload: { error: 'unknown_sender' }\n        }, '*');\n      }\n      return;\n    }\n\n    // Update heartbeat on any activity\n    sender.lastHeartbeat = Date.now();\n\n    // Get target peer(s)\n    const targets = payload.targetId\n      ? [this.peers.get(payload.targetId)].filter(Boolean) as PeerInfo[]\n      : this.getPeersInRoom(roomId).filter(p => p.playerId !== playerId);\n\n    // Deliver message to target(s)\n    for (const target of targets) {\n      this.sendToIframe(target.iframe, {\n        type: 'BRIDGE_DELIVER',\n        roomId,\n        playerId, // Original sender ID\n        payload: { message: payload.message }\n      });\n    }\n  }\n\n  /**\n   * Handle heartbeat from peers\n   */\n  private handleHeartbeat(data: BridgeMessage): void {\n    const { playerId } = data;\n    const peer = this.peers.get(playerId);\n\n    if (!peer) {\n      console.warn('[IframeBridgeRelay] Unknown heartbeat sender:', playerId);\n      return;\n    }\n\n    peer.lastHeartbeat = Date.now();\n  }\n\n  /**\n   * Handle peer leaving\n   */\n  private handlePeerLeave(data: BridgeMessage): void {\n    const { playerId, roomId, payload } = data;\n\n    const peer = this.peers.get(playerId);\n    if (!peer) return;\n\n    // Remove from tracking\n    this.peers.delete(playerId);\n    const room = this.rooms.get(roomId);\n    if (room) {\n      room.delete(playerId);\n      if (room.size === 0) {\n        this.rooms.delete(roomId);\n      }\n    }\n\n    console.log(`[IframeBridgeRelay] Peer ${playerId} left room ${roomId}`);\n\n    // Notify remaining peers\n    const remainingPeers = this.getPeersInRoom(roomId);\n    for (const otherPeer of remainingPeers) {\n      this.sendToIframe(otherPeer.iframe, {\n        type: 'BRIDGE_PEER_LEAVE',\n        roomId,\n        playerId: otherPeer.playerId,\n        payload: {\n          peerId: playerId,\n          wasHost: payload?.wasHost || false\n        }\n      });\n    }\n\n    // If host left, notify about host disconnect\n    if (peer.isHost) {\n      for (const otherPeer of remainingPeers) {\n        this.sendToIframe(otherPeer.iframe, {\n          type: 'BRIDGE_HOST_DISCONNECT',\n          roomId,\n          playerId: otherPeer.playerId,\n          payload: { wasHost: true }\n        });\n      }\n    }\n  }\n\n  /**\n   * Start heartbeat monitor to detect stale peers\n   * Checks every 5 seconds and removes peers inactive for 10+ seconds\n   */\n  private startHeartbeatMonitor(): void {\n    this.heartbeatInterval = setInterval(() => {\n      const now = Date.now();\n      const stalePeers: string[] = [];\n\n      // Find stale peers\n      for (const [playerId, peer] of this.peers) {\n        if (now - peer.lastHeartbeat > this.PEER_TIMEOUT_MS) {\n          console.warn(`[IframeBridgeRelay] Removing stale peer: ${playerId} (inactive for ${now - peer.lastHeartbeat}ms)`);\n          stalePeers.push(playerId);\n        }\n      }\n\n      // Remove stale peers\n      for (const playerId of stalePeers) {\n        const peer = this.peers.get(playerId);\n        if (peer) {\n          this.handlePeerLeave({\n            type: 'BRIDGE_PEER_LEAVE',\n            playerId,\n            roomId: peer.roomId,\n            payload: { peerId: playerId }\n          });\n        }\n      }\n    }, this.HEARTBEAT_CHECK_MS);\n  }\n\n  /**\n   * Get all peers in a room\n   */\n  private getPeersInRoom(roomId: string): PeerInfo[] {\n    const room = this.rooms.get(roomId);\n    if (!room) return [];\n\n    return Array.from(room)\n      .map(playerId => this.peers.get(playerId))\n      .filter(Boolean) as PeerInfo[];\n  }\n\n  /**\n   * Send message to an iframe\n   */\n  private sendToIframe(iframe: HTMLIFrameElement, message: BridgeMessage): void {\n    if (!iframe.contentWindow) {\n      console.warn('[IframeBridgeRelay] Iframe has no contentWindow');\n      return;\n    }\n\n    iframe.contentWindow.postMessage(message, '*');\n  }\n\n  /**\n   * Manually register an iframe (useful for testing or explicit control)\n   */\n  registerIframe(playerId: string, roomId: string, iframe: HTMLIFrameElement, isHost: boolean): void {\n    this.peers.set(playerId, {\n      playerId,\n      roomId,\n      iframe,\n      isHost,\n      lastHeartbeat: Date.now()\n    });\n\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n    this.rooms.get(roomId)!.add(playerId);\n\n    console.log(`[IframeBridgeRelay] Manually registered ${playerId} in ${roomId}`);\n  }\n\n  /**\n   * Get info about registered peers\n   */\n  getPeers(): PeerInfo[] {\n    return Array.from(this.peers.values());\n  }\n\n  /**\n   * Get peers in a specific room\n   */\n  getPeersInRoomById(roomId: string): PeerInfo[] {\n    return this.getPeersInRoom(roomId);\n  }\n\n  /**\n   * Clean up\n   */\n  destroy(): void {\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n      this.messageHandler = null;\n    }\n\n    // Stop heartbeat monitor\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n\n    this.peers.clear();\n    this.rooms.clear();\n  }\n}\n",
  "/node_modules/@martini-kit/transport-iframe-bridge/IframeBridgeTransport.ts": "/**\n * IframeBridgeTransport - Iframe-based transport for sandboxed multiplayer\n *\n * Perfect for:\n * - IDE dual-view local testing (sandboxed iframes)\n * - Any scenario where peers are in separate sandboxed iframes\n * - Testing with iframe isolation\n *\n * Architecture:\n * - Parent window runs IframeBridgeRelay (message hub)\n * - Each iframe has IframeBridgeTransport instance\n * - Messages flow: iframe → parent relay → other iframes\n *\n * @example\n * ```typescript\n * // In parent window\n * const relay = new IframeBridgeRelay();\n * relay.registerIframe('host', hostIframe);\n * relay.registerIframe('client', clientIframe);\n *\n * // In host iframe\n * const transport = new IframeBridgeTransport({ roomId: 'room-1', isHost: true });\n *\n * // In client iframe\n * const transport = new IframeBridgeTransport({ roomId: 'room-1', isHost: false });\n * ```\n */\n\nimport type { Transport, WireMessage, TransportMetrics, ConnectionState, MessageStats } from '@martini-kit/core';\n\ntype ConnectionChangeHandler = (state: ConnectionState) => void;\n\nexport interface IframeBridgeConfig {\n  /** Unique room identifier */\n  roomId: string;\n\n  /** Player ID (auto-generated if not provided) */\n  playerId?: string;\n\n  /** Whether this instance is the host */\n  isHost: boolean;\n}\n\n/**\n * Message types for iframe ↔ parent communication\n */\nexport interface BridgeMessage {\n  type: 'BRIDGE_REGISTER' | 'BRIDGE_SEND' | 'BRIDGE_DELIVER' | 'BRIDGE_PEER_JOIN' | 'BRIDGE_PEER_LEAVE' | 'BRIDGE_HOST_DISCONNECT' | 'BRIDGE_HEARTBEAT' | 'BRIDGE_ERROR';\n  roomId: string;\n  playerId: string;\n  payload?: {\n    message?: WireMessage;\n    targetId?: string;\n    peerId?: string;\n    wasHost?: boolean;\n    error?: string;\n  };\n}\n\n/**\n * Metrics implementation for IframeBridgeTransport\n */\nclass IframeBridgeTransportMetrics implements TransportMetrics {\n  private connectionState: ConnectionState = 'connecting';\n  private connectionChangeHandlers: ConnectionChangeHandler[] = [];\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private messagesErrored = 0;\n\n  constructor(private transport: IframeBridgeTransport) {\n    // Start as 'connecting', will change to 'connected' when relay responds\n  }\n\n  getConnectionState(): ConnectionState {\n    return this.connectionState;\n  }\n\n  onConnectionChange(callback: ConnectionChangeHandler): () => void {\n    this.connectionChangeHandlers.push(callback);\n    return () => {\n      const idx = this.connectionChangeHandlers.indexOf(callback);\n      if (idx >= 0) this.connectionChangeHandlers.splice(idx, 1);\n    };\n  }\n\n  getPeerCount(): number {\n    return this.transport.getPeerIds().length;\n  }\n\n  getMessageStats(): MessageStats {\n    return {\n      sent: this.messagesSent,\n      received: this.messagesReceived,\n      errors: this.messagesErrored\n    };\n  }\n\n  resetStats(): void {\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.messagesErrored = 0;\n  }\n\n  /** @internal */\n  trackMessageSent(): void {\n    this.messagesSent++;\n  }\n\n  /** @internal */\n  trackMessageReceived(): void {\n    this.messagesReceived++;\n  }\n\n  /** @internal */\n  trackMessageError(): void {\n    this.messagesErrored++;\n  }\n\n  /** @internal */\n  setConnected(): void {\n    if (this.connectionState !== 'connected') {\n      this.connectionState = 'connected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  /** @internal */\n  setDisconnected(): void {\n    if (this.connectionState !== 'disconnected') {\n      this.connectionState = 'disconnected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  private notifyConnectionChange(): void {\n    this.connectionChangeHandlers.forEach(h => {\n      try {\n        h(this.connectionState);\n      } catch (error) {\n        console.error('Error in connection change handler:', error);\n      }\n    });\n  }\n}\n\nexport class IframeBridgeTransport implements Transport {\n  public readonly playerId: string;\n  private readonly roomId: string;\n  private readonly _isHost: boolean;\n  public readonly metrics: TransportMetrics;\n  private readonly HEARTBEAT_INTERVAL_MS = 3000;\n\n  private messageHandlers: Array<(msg: WireMessage, senderId: string) => void> = [];\n  private peerJoinHandlers: Array<(peerId: string) => void> = [];\n  private peerLeaveHandlers: Array<(peerId: string) => void> = [];\n  private hostDisconnectHandlers: Array<() => void> = [];\n\n  private peerIds: Set<string> = new Set();\n  private messageHandler: ((event: MessageEvent) => void) | null = null;\n  private isDisconnected = false;\n  private heartbeatInterval: number | null = null;\n  private visibilityHandler?: () => void;\n\n  constructor(config: IframeBridgeConfig) {\n    // Transport lifecycle guardrail with self-healing: if a previous transport leaked, clean it up\n    const existingTransport = typeof globalThis !== 'undefined'\n      ? (globalThis as any)['__martini-kit_TRANSPORT__']\n      : null;\n\n    if (existingTransport && existingTransport !== this) {\n      try {\n        if (typeof existingTransport.disconnect === 'function') {\n          existingTransport.disconnect();\n        } else if (typeof existingTransport.destroy === 'function') {\n          existingTransport.destroy();\n        }\n      } catch (error) {\n        console.warn('[IframeBridgeTransport] Failed to cleanup existing transport', error);\n      }\n\n      // Clear the leaked reference so a fresh transport can be registered\n      if (typeof globalThis !== 'undefined') {\n        delete (globalThis as any)['__martini-kit_TRANSPORT__'];\n      }\n    }\n\n    this.roomId = config.roomId;\n    this.playerId = config.playerId || `player-${Math.random().toString(36).substring(2, 9)}`;\n    this._isHost = config.isHost;\n\n    // Initialize metrics\n    this.metrics = new IframeBridgeTransportMetrics(this);\n\n    // Register this transport globally for guardrail\n    if (typeof globalThis !== 'undefined') {\n      (globalThis as any)['__martini-kit_TRANSPORT__'] = this;\n    }\n\n    this.setupMessageListener();\n    this.registerWithRelay();\n    this.startHeartbeat();\n    this.setupVisibilityListener();\n  }\n\n  /**\n   * Set up listener for messages from parent relay\n   */\n  private setupMessageListener(): void {\n    this.messageHandler = (event: MessageEvent) => {\n      const data = event.data as BridgeMessage;\n\n      // Ignore messages not from our relay system\n      if (!data || !data.type || !data.type.startsWith('BRIDGE_')) {\n        return;\n      }\n\n      // Ignore messages for other rooms\n      if (data.roomId !== this.roomId) {\n        return;\n      }\n\n      switch (data.type) {\n        case 'BRIDGE_DELIVER':\n          // Received message from another peer\n          if (data.payload?.message && data.playerId !== this.playerId) {\n            (this.metrics as IframeBridgeTransportMetrics).trackMessageReceived();\n            this.messageHandlers.forEach(h => h(data.payload!.message!, data.playerId));\n          }\n          break;\n\n        case 'BRIDGE_PEER_JOIN':\n          // Another peer joined the room\n          if (data.payload?.peerId && data.payload.peerId !== this.playerId) {\n            this.peerIds.add(data.payload.peerId);\n            (this.metrics as IframeBridgeTransportMetrics).setConnected(); // Mark as connected when first peer joins\n            this.peerJoinHandlers.forEach(h => h(data.payload!.peerId!));\n          }\n          break;\n\n        case 'BRIDGE_PEER_LEAVE':\n          // Another peer left the room\n          if (data.payload?.peerId) {\n            this.peerIds.delete(data.payload.peerId);\n            this.peerLeaveHandlers.forEach(h => h(data.payload!.peerId!));\n          }\n          break;\n\n        case 'BRIDGE_HOST_DISCONNECT':\n          // Host disconnected\n          if (data.payload?.wasHost && !this._isHost) {\n            this.hostDisconnectHandlers.forEach(h => h());\n          }\n          break;\n\n        case 'BRIDGE_ERROR':\n          // Relay rejected our message (e.g., unknown sender after timeout)\n          // Auto-reconnect to re-establish connection\n          console.warn('[IframeBridgeTransport] Relay error, reconnecting...', data.payload?.error);\n          this.registerWithRelay();\n          this.sendHeartbeat();\n          break;\n      }\n    };\n\n    window.addEventListener('message', this.messageHandler);\n  }\n\n  /**\n   * Register this transport instance with parent relay\n   */\n  private registerWithRelay(): void {\n    if (!window.parent || window.parent === window) {\n      console.warn('[IframeBridgeTransport] No parent window found - transport may not work');\n      return;\n    }\n\n    const registerMessage: BridgeMessage = {\n      type: 'BRIDGE_REGISTER',\n      roomId: this.roomId,\n      playerId: this.playerId,\n      payload: {}\n    };\n\n    window.parent.postMessage(registerMessage, '*');\n  }\n\n  /**\n   * Send periodic heartbeat to relay\n   */\n  private sendHeartbeat(): void {\n    if (this.isDisconnected) return;\n    if (!window.parent || window.parent === window) return;\n\n    const heartbeat: BridgeMessage = {\n      type: 'BRIDGE_HEARTBEAT',\n      roomId: this.roomId,\n      playerId: this.playerId\n    };\n\n    window.parent.postMessage(heartbeat, '*');\n  }\n\n  private startHeartbeat(): void {\n    if (typeof window === 'undefined') return;\n    this.stopHeartbeat();\n    this.sendHeartbeat();\n    this.heartbeatInterval = window.setInterval(() => this.sendHeartbeat(), this.HEARTBEAT_INTERVAL_MS);\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n\n  private setupVisibilityListener(): void {\n    if (typeof document === 'undefined' || typeof document.addEventListener !== 'function') {\n      return;\n    }\n\n    this.visibilityHandler = () => {\n      if (document.visibilityState === 'visible') {\n        this.registerWithRelay();\n        this.sendHeartbeat();\n      }\n    };\n\n    document.addEventListener('visibilitychange', this.visibilityHandler);\n  }\n\n  /**\n   * Send message to peer(s)\n   */\n  send(message: WireMessage, targetId?: string): void {\n    if (this.isDisconnected) {\n      console.warn('[IframeBridgeTransport] Cannot send - transport is disconnected');\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageError();\n      return;\n    }\n\n    if (!window.parent || window.parent === window) {\n      console.warn('[IframeBridgeTransport] No parent window - message not sent');\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageError();\n      return;\n    }\n\n    try {\n      const bridgeMessage: BridgeMessage = {\n        type: 'BRIDGE_SEND',\n        roomId: this.roomId,\n        playerId: this.playerId,\n        payload: {\n          message,\n          targetId\n        }\n      };\n\n      window.parent.postMessage(bridgeMessage, '*');\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageSent();\n    } catch (error) {\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageError();\n      throw error;\n    }\n  }\n\n  onMessage(handler: (msg: WireMessage, senderId: string) => void): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      const idx = this.messageHandlers.indexOf(handler);\n      if (idx >= 0) this.messageHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerJoin(handler: (peerId: string) => void): () => void {\n    this.peerJoinHandlers.push(handler);\n    return () => {\n      const idx = this.peerJoinHandlers.indexOf(handler);\n      if (idx >= 0) this.peerJoinHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerLeave(handler: (peerId: string) => void): () => void {\n    this.peerLeaveHandlers.push(handler);\n    return () => {\n      const idx = this.peerLeaveHandlers.indexOf(handler);\n      if (idx >= 0) this.peerLeaveHandlers.splice(idx, 1);\n    };\n  }\n\n  onHostDisconnect(handler: () => void): () => void {\n    this.hostDisconnectHandlers.push(handler);\n    return () => {\n      const idx = this.hostDisconnectHandlers.indexOf(handler);\n      if (idx >= 0) this.hostDisconnectHandlers.splice(idx, 1);\n    };\n  }\n\n  getPlayerId(): string {\n    return this.playerId;\n  }\n\n  getPeerIds(): string[] {\n    return Array.from(this.peerIds);\n  }\n\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  disconnect(): void {\n    if (this.isDisconnected) return;\n\n    (this.metrics as IframeBridgeTransportMetrics).setDisconnected();\n    this.isDisconnected = true;\n    this.stopHeartbeat();\n\n    // Clear global transport reference to allow new instances\n    if (typeof globalThis !== 'undefined' && (globalThis as any)['__martini-kit_TRANSPORT__'] === this) {\n      delete (globalThis as any)['__martini-kit_TRANSPORT__'];\n    }\n\n    // Notify relay\n    if (window.parent && window.parent !== window) {\n      const disconnectMessage: BridgeMessage = {\n        type: 'BRIDGE_PEER_LEAVE',\n        roomId: this.roomId,\n        playerId: this.playerId,\n        payload: {\n          peerId: this.playerId,\n          wasHost: this._isHost\n        }\n      };\n\n      window.parent.postMessage(disconnectMessage, '*');\n    }\n\n    // Clean up\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n      this.messageHandler = null;\n    }\n\n    this.messageHandlers = [];\n    this.peerJoinHandlers = [];\n    this.peerLeaveHandlers = [];\n    this.hostDisconnectHandlers = [];\n    this.peerIds.clear();\n\n    if (this.visibilityHandler && typeof document !== 'undefined') {\n      document.removeEventListener('visibilitychange', this.visibilityHandler);\n      this.visibilityHandler = undefined;\n    }\n  }\n}\n",
  "/node_modules/@martini-kit/transport-iframe-bridge/index.ts": "/**\n * @martini-kit/transport-iframe-bridge\n *\n * Iframe-based transport for sandboxed multiplayer testing.\n * Enables local multiplayer testing in sandboxed iframes (like IDE dual-view).\n */\n\nexport { IframeBridgeTransport } from './IframeBridgeTransport.js';\nexport { IframeBridgeRelay } from './IframeBridgeRelay.js';\nexport type { IframeBridgeConfig, BridgeMessage } from './IframeBridgeTransport.js';\nexport type { PeerInfo } from './IframeBridgeRelay.js';\n",
  "/node_modules/@martini-kit/transport-iframe-bridge/package.json": "{\n  \"name\": \"@martini-kit/transport-iframe-bridge\",\n  \"version\": \"0.1.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}"
}