{
  "__metadata": {
    "version": "0.2.0",
    "gitSha": "bae71a308a841f61af2badcc373c48703f9d227a",
    "gitBranch": "main",
    "buildTime": "2025-12-04T12:53:46.577Z"
  },
  "/node_modules/@martini-kit/transport-local/LocalTransport.ts": "/**\n * LocalTransport - In-memory transport for same-page multiplayer\n *\n * Perfect for:\n * - Side-by-side demo instances on the same page\n * - Unit/integration testing\n * - Local development without network overhead\n *\n * All instances in the same room share messages instantly via an in-memory event bus.\n */\n\nimport type { Transport, WireMessage, TransportMetrics, ConnectionState, MessageStats } from '@martini-kit/core';\n\ntype MessageHandler = (message: WireMessage, senderId: string) => void;\ntype PeerHandler = (peerId: string) => void;\ntype ConnectionChangeHandler = (state: ConnectionState) => void;\n\n/**\n * Static registry of all local transport instances, grouped by room\n */\nclass LocalTransportRegistry {\n  private static rooms = new Map<string, Set<LocalTransport>>();\n\n  static register(roomId: string, transport: LocalTransport): void {\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n\n    const room = this.rooms.get(roomId)!;\n\n    // Check if any existing peer has locked the room\n    const isRoomLocked = Array.from(room).some(peer => peer.isRoomLocked());\n    if (isRoomLocked) {\n      console.warn(`[LocalTransport] Room ${roomId} is locked, rejecting new peer ${transport.playerId}`);\n      // Don't add the transport to the room\n      return;\n    }\n\n    room.add(transport);\n\n    // Notify existing peers about the new peer\n    for (const peer of room) {\n      if (peer !== transport) {\n        // Notify existing peer about new peer\n        peer.notifyPeerJoin(transport.playerId);\n        // Notify new peer about existing peer\n        transport.notifyPeerJoin(peer.playerId);\n      }\n    }\n  }\n\n  static unregister(roomId: string, transport: LocalTransport): void {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    // Check if the leaving peer is the host before removing\n    const isLeavingPeerHost = transport.isHost();\n\n    room.delete(transport);\n\n    // Notify remaining peers about the disconnect\n    for (const peer of room) {\n      peer.notifyPeerLeave(transport.playerId, isLeavingPeerHost);\n    }\n\n    if (room.size === 0) {\n      this.rooms.delete(roomId);\n    }\n  }\n\n  static getPeers(roomId: string, excludeId: string): LocalTransport[] {\n    const room = this.rooms.get(roomId);\n    if (!room) return [];\n    return Array.from(room).filter((t) => t.playerId !== excludeId);\n  }\n\n  static broadcast(roomId: string, message: WireMessage, senderId: string): void {\n    const peers = this.getPeers(roomId, senderId);\n    for (const peer of peers) {\n      peer.deliver(message, senderId);\n    }\n  }\n\n  static unicast(roomId: string, message: WireMessage, senderId: string, targetId: string): void {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    const target = Array.from(room).find((p) => p.playerId === targetId);\n    if (target) {\n      target.deliver(message, senderId);\n    }\n  }\n}\n\n/**\n * Metrics implementation for LocalTransport\n * Tracks connection state, peer count, and message statistics\n */\nclass LocalTransportMetrics implements TransportMetrics {\n  private connectionState: ConnectionState = 'disconnected';\n  private connectionChangeHandlers: ConnectionChangeHandler[] = [];\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private messagesErrored = 0;\n\n  constructor(private transport: LocalTransport) {\n    // LocalTransport is always \"connected\" since it's in-memory\n    this.connectionState = 'connected';\n  }\n\n  getConnectionState(): ConnectionState {\n    return this.connectionState;\n  }\n\n  onConnectionChange(callback: ConnectionChangeHandler): () => void {\n    this.connectionChangeHandlers.push(callback);\n    return () => {\n      const idx = this.connectionChangeHandlers.indexOf(callback);\n      if (idx >= 0) this.connectionChangeHandlers.splice(idx, 1);\n    };\n  }\n\n  getPeerCount(): number {\n    return this.transport.getPeerIds().length;\n  }\n\n  getMessageStats(): MessageStats {\n    return {\n      sent: this.messagesSent,\n      received: this.messagesReceived,\n      errors: this.messagesErrored\n    };\n  }\n\n  resetStats(): void {\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.messagesErrored = 0;\n  }\n\n  /** @internal - Called by LocalTransport when message is sent */\n  trackMessageSent(): void {\n    this.messagesSent++;\n  }\n\n  /** @internal - Called by LocalTransport when message is received */\n  trackMessageReceived(): void {\n    this.messagesReceived++;\n  }\n\n  /** @internal - Called by LocalTransport when message fails */\n  trackMessageError(): void {\n    this.messagesErrored++;\n  }\n\n  /** @internal - Called by LocalTransport when disconnecting */\n  setDisconnected(): void {\n    if (this.connectionState !== 'disconnected') {\n      this.connectionState = 'disconnected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  private notifyConnectionChange(): void {\n    this.connectionChangeHandlers.forEach(h => {\n      try {\n        h(this.connectionState);\n      } catch (error) {\n        console.error('Error in connection change handler:', error);\n      }\n    });\n  }\n}\n\nexport interface LocalTransportConfig {\n  roomId: string;\n  playerId?: string;\n  isHost: boolean;\n}\n\nexport class LocalTransport implements Transport {\n  public readonly playerId: string;\n  private readonly roomId: string;\n  private readonly _isHost: boolean;\n  public readonly metrics: TransportMetrics;\n\n  private messageHandlers: MessageHandler[] = [];\n  private peerJoinHandlers: PeerHandler[] = [];\n  private peerLeaveHandlers: PeerHandler[] = [];\n  private hostDisconnectHandlers: (() => void)[] = [];\n  private isLocked: boolean = false;\n\n  constructor(config: LocalTransportConfig) {\n    this.roomId = config.roomId;\n    this.playerId = config.playerId || `player-${Math.random().toString(36).substring(2, 9)}`;\n    this._isHost = config.isHost;\n\n    // Initialize metrics\n    this.metrics = new LocalTransportMetrics(this);\n\n    // Register with the global registry\n    LocalTransportRegistry.register(this.roomId, this);\n  }\n\n  send(message: WireMessage, targetId?: string): void {\n    try {\n      if (targetId) {\n        // Unicast\n        LocalTransportRegistry.unicast(this.roomId, message, this.playerId, targetId);\n      } else {\n        // Broadcast\n        LocalTransportRegistry.broadcast(this.roomId, message, this.playerId);\n      }\n      (this.metrics as LocalTransportMetrics).trackMessageSent();\n    } catch (error) {\n      (this.metrics as LocalTransportMetrics).trackMessageError();\n      throw error;\n    }\n  }\n\n  onMessage(handler: MessageHandler): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      const idx = this.messageHandlers.indexOf(handler);\n      if (idx >= 0) this.messageHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerJoin(handler: PeerHandler): () => void {\n    this.peerJoinHandlers.push(handler);\n    return () => {\n      const idx = this.peerJoinHandlers.indexOf(handler);\n      if (idx >= 0) this.peerJoinHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerLeave(handler: PeerHandler): () => void {\n    this.peerLeaveHandlers.push(handler);\n    return () => {\n      const idx = this.peerLeaveHandlers.indexOf(handler);\n      if (idx >= 0) this.peerLeaveHandlers.splice(idx, 1);\n    };\n  }\n\n  onHostDisconnect(handler: () => void): () => void {\n    this.hostDisconnectHandlers.push(handler);\n    return () => {\n      const idx = this.hostDisconnectHandlers.indexOf(handler);\n      if (idx >= 0) this.hostDisconnectHandlers.splice(idx, 1);\n    };\n  }\n\n  getPlayerId(): string {\n    return this.playerId;\n  }\n\n  getPeerIds(): string[] {\n    return LocalTransportRegistry.getPeers(this.roomId, this.playerId).map((p) => p.playerId);\n  }\n\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  /**\n   * Lock the room - prevent new peers from joining\n   * For LocalTransport, this is a simple flag check\n   */\n  lock(): void {\n    this.isLocked = true;\n  }\n\n  disconnect(): void {\n    (this.metrics as LocalTransportMetrics).setDisconnected();\n    LocalTransportRegistry.unregister(this.roomId, this);\n  }\n\n  /**\n   * Check if room is locked\n   * @internal\n   */\n  isRoomLocked(): boolean {\n    return this.isLocked;\n  }\n\n  // Internal methods called by the registry\n\n  /** @internal */\n  deliver(message: WireMessage, senderId: string): void {\n    (this.metrics as LocalTransportMetrics).trackMessageReceived();\n    this.messageHandlers.forEach((h) => h(message, senderId));\n  }\n\n  /** @internal */\n  notifyPeerJoin(peerId: string): void {\n    this.peerJoinHandlers.forEach((h) => h(peerId));\n  }\n\n  /** @internal */\n  notifyPeerLeave(peerId: string, wasHost: boolean): void {\n    this.peerLeaveHandlers.forEach((h) => h(peerId));\n\n    // If the leaving peer was the host, notify host disconnect handlers\n    if (wasHost) {\n      this.hostDisconnectHandlers.forEach((h) => h());\n    }\n  }\n}\n",
  "/node_modules/@martini-kit/transport-local/index.ts": "/**\n * @martini-kit/transport-local\n *\n * In-memory transport for same-page multiplayer demos and testing.\n *\n * Use this transport when you want to run multiple game instances\n * on the same page (e.g., side-by-side demo views) without the\n * complexity of WebRTC signaling.\n *\n * @example\n * ```ts\n * // Create two instances in the same room\n * const host = new LocalTransport({\n *   roomId: 'demo-room',\n *   isHost: true\n * });\n *\n * const client = new LocalTransport({\n *   roomId: 'demo-room',\n *   isHost: false\n * });\n *\n * // They instantly see each other\n * host.getPeerIds(); // [client.playerId]\n * client.getPeerIds(); // [host.playerId]\n * ```\n */\n\nexport { LocalTransport, type LocalTransportConfig } from './LocalTransport';\n",
  "/node_modules/@martini-kit/transport-local/package.json": "{\n  \"name\": \"@martini-kit/transport-local\",\n  \"version\": \"0.2.0\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}"
}