{
  "version": 3,
  "sources": ["../src/LocalTransport.ts"],
  "sourcesContent": ["/**\n * LocalTransport - In-memory transport for same-page multiplayer\n *\n * Perfect for:\n * - Side-by-side demo instances on the same page\n * - Unit/integration testing\n * - Local development without network overhead\n *\n * All instances in the same room share messages instantly via an in-memory event bus.\n */\n\nimport type { Transport, WireMessage, TransportMetrics, ConnectionState, MessageStats } from '@martini-kit/core';\n\ntype MessageHandler = (message: WireMessage, senderId: string) => void;\ntype PeerHandler = (peerId: string) => void;\ntype ConnectionChangeHandler = (state: ConnectionState) => void;\n\n/**\n * Static registry of all local transport instances, grouped by room\n */\nclass LocalTransportRegistry {\n  private static rooms = new Map<string, Set<LocalTransport>>();\n\n  static register(roomId: string, transport: LocalTransport): void {\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n\n    const room = this.rooms.get(roomId)!;\n\n    // Check if any existing peer has locked the room\n    const isRoomLocked = Array.from(room).some(peer => peer.isRoomLocked());\n    if (isRoomLocked) {\n      console.warn(`[LocalTransport] Room ${roomId} is locked, rejecting new peer ${transport.playerId}`);\n      // Don't add the transport to the room\n      return;\n    }\n\n    room.add(transport);\n\n    // Notify existing peers about the new peer\n    for (const peer of room) {\n      if (peer !== transport) {\n        // Notify existing peer about new peer\n        peer.notifyPeerJoin(transport.playerId);\n        // Notify new peer about existing peer\n        transport.notifyPeerJoin(peer.playerId);\n      }\n    }\n  }\n\n  static unregister(roomId: string, transport: LocalTransport): void {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    // Check if the leaving peer is the host before removing\n    const isLeavingPeerHost = transport.isHost();\n\n    room.delete(transport);\n\n    // Notify remaining peers about the disconnect\n    for (const peer of room) {\n      peer.notifyPeerLeave(transport.playerId, isLeavingPeerHost);\n    }\n\n    if (room.size === 0) {\n      this.rooms.delete(roomId);\n    }\n  }\n\n  static getPeers(roomId: string, excludeId: string): LocalTransport[] {\n    const room = this.rooms.get(roomId);\n    if (!room) return [];\n    return Array.from(room).filter((t) => t.playerId !== excludeId);\n  }\n\n  static broadcast(roomId: string, message: WireMessage, senderId: string): void {\n    const peers = this.getPeers(roomId, senderId);\n    for (const peer of peers) {\n      peer.deliver(message, senderId);\n    }\n  }\n\n  static unicast(roomId: string, message: WireMessage, senderId: string, targetId: string): void {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    const target = Array.from(room).find((p) => p.playerId === targetId);\n    if (target) {\n      target.deliver(message, senderId);\n    }\n  }\n}\n\n/**\n * Metrics implementation for LocalTransport\n * Tracks connection state, peer count, and message statistics\n */\nclass LocalTransportMetrics implements TransportMetrics {\n  private connectionState: ConnectionState = 'disconnected';\n  private connectionChangeHandlers: ConnectionChangeHandler[] = [];\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private messagesErrored = 0;\n\n  constructor(private transport: LocalTransport) {\n    // LocalTransport is always \"connected\" since it's in-memory\n    this.connectionState = 'connected';\n  }\n\n  getConnectionState(): ConnectionState {\n    return this.connectionState;\n  }\n\n  onConnectionChange(callback: ConnectionChangeHandler): () => void {\n    this.connectionChangeHandlers.push(callback);\n    return () => {\n      const idx = this.connectionChangeHandlers.indexOf(callback);\n      if (idx >= 0) this.connectionChangeHandlers.splice(idx, 1);\n    };\n  }\n\n  getPeerCount(): number {\n    return this.transport.getPeerIds().length;\n  }\n\n  getMessageStats(): MessageStats {\n    return {\n      sent: this.messagesSent,\n      received: this.messagesReceived,\n      errors: this.messagesErrored\n    };\n  }\n\n  resetStats(): void {\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.messagesErrored = 0;\n  }\n\n  /** @internal - Called by LocalTransport when message is sent */\n  trackMessageSent(): void {\n    this.messagesSent++;\n  }\n\n  /** @internal - Called by LocalTransport when message is received */\n  trackMessageReceived(): void {\n    this.messagesReceived++;\n  }\n\n  /** @internal - Called by LocalTransport when message fails */\n  trackMessageError(): void {\n    this.messagesErrored++;\n  }\n\n  /** @internal - Called by LocalTransport when disconnecting */\n  setDisconnected(): void {\n    if (this.connectionState !== 'disconnected') {\n      this.connectionState = 'disconnected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  private notifyConnectionChange(): void {\n    this.connectionChangeHandlers.forEach(h => {\n      try {\n        h(this.connectionState);\n      } catch (error) {\n        console.error('Error in connection change handler:', error);\n      }\n    });\n  }\n}\n\nexport interface LocalTransportConfig {\n  roomId: string;\n  playerId?: string;\n  isHost: boolean;\n}\n\nexport class LocalTransport implements Transport {\n  public readonly playerId: string;\n  private readonly roomId: string;\n  private readonly _isHost: boolean;\n  public readonly metrics: TransportMetrics;\n\n  private messageHandlers: MessageHandler[] = [];\n  private peerJoinHandlers: PeerHandler[] = [];\n  private peerLeaveHandlers: PeerHandler[] = [];\n  private hostDisconnectHandlers: (() => void)[] = [];\n  private isLocked: boolean = false;\n\n  constructor(config: LocalTransportConfig) {\n    this.roomId = config.roomId;\n    this.playerId = config.playerId || `player-${Math.random().toString(36).substring(2, 9)}`;\n    this._isHost = config.isHost;\n\n    // Initialize metrics\n    this.metrics = new LocalTransportMetrics(this);\n\n    // Register with the global registry\n    LocalTransportRegistry.register(this.roomId, this);\n  }\n\n  send(message: WireMessage, targetId?: string): void {\n    try {\n      if (targetId) {\n        // Unicast\n        LocalTransportRegistry.unicast(this.roomId, message, this.playerId, targetId);\n      } else {\n        // Broadcast\n        LocalTransportRegistry.broadcast(this.roomId, message, this.playerId);\n      }\n      (this.metrics as LocalTransportMetrics).trackMessageSent();\n    } catch (error) {\n      (this.metrics as LocalTransportMetrics).trackMessageError();\n      throw error;\n    }\n  }\n\n  onMessage(handler: MessageHandler): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      const idx = this.messageHandlers.indexOf(handler);\n      if (idx >= 0) this.messageHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerJoin(handler: PeerHandler): () => void {\n    this.peerJoinHandlers.push(handler);\n    return () => {\n      const idx = this.peerJoinHandlers.indexOf(handler);\n      if (idx >= 0) this.peerJoinHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerLeave(handler: PeerHandler): () => void {\n    this.peerLeaveHandlers.push(handler);\n    return () => {\n      const idx = this.peerLeaveHandlers.indexOf(handler);\n      if (idx >= 0) this.peerLeaveHandlers.splice(idx, 1);\n    };\n  }\n\n  onHostDisconnect(handler: () => void): () => void {\n    this.hostDisconnectHandlers.push(handler);\n    return () => {\n      const idx = this.hostDisconnectHandlers.indexOf(handler);\n      if (idx >= 0) this.hostDisconnectHandlers.splice(idx, 1);\n    };\n  }\n\n  getPlayerId(): string {\n    return this.playerId;\n  }\n\n  getPeerIds(): string[] {\n    return LocalTransportRegistry.getPeers(this.roomId, this.playerId).map((p) => p.playerId);\n  }\n\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  /**\n   * Lock the room - prevent new peers from joining\n   * For LocalTransport, this is a simple flag check\n   */\n  lock(): void {\n    this.isLocked = true;\n  }\n\n  disconnect(): void {\n    (this.metrics as LocalTransportMetrics).setDisconnected();\n    LocalTransportRegistry.unregister(this.roomId, this);\n  }\n\n  /**\n   * Check if room is locked\n   * @internal\n   */\n  isRoomLocked(): boolean {\n    return this.isLocked;\n  }\n\n  // Internal methods called by the registry\n\n  /** @internal */\n  deliver(message: WireMessage, senderId: string): void {\n    (this.metrics as LocalTransportMetrics).trackMessageReceived();\n    this.messageHandlers.forEach((h) => h(message, senderId));\n  }\n\n  /** @internal */\n  notifyPeerJoin(peerId: string): void {\n    this.peerJoinHandlers.forEach((h) => h(peerId));\n  }\n\n  /** @internal */\n  notifyPeerLeave(peerId: string, wasHost: boolean): void {\n    this.peerLeaveHandlers.forEach((h) => h(peerId));\n\n    // If the leaving peer was the host, notify host disconnect handlers\n    if (wasHost) {\n      this.hostDisconnectHandlers.forEach((h) => h());\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
