{
  "version": 3,
  "sources": ["../src/helpers/CameraFollower.ts", "../src/helpers/SpriteManager.ts", "../src/helpers/InputProfiles.ts", "../src/helpers/InputManager.ts", "../src/helpers/PlayerUIManager.ts", "../src/helpers/CollisionManager.ts", "../src/helpers/PhysicsManager.ts", "../src/helpers/StateDrivenSpawner.ts", "../src/helpers/HealthBarManager.ts", "../src/helpers/GridClickHelper.ts", "../src/helpers/GridCollisionManager.ts", "../src/helpers/GridLockedMovementManager.ts", "../src/PhaserAdapter.ts", "../src/helpers/HUDHelper.ts", "../src/helpers/PlayerStatsPanel.ts", "../src/helpers/CollectibleManager.ts", "../src/helpers/RoundManager.ts", "../src/helpers/SpeedDisplay.ts", "../src/helpers/SpriteAttachment.ts", "../src/helpers/DirectionalIndicator.ts", "../src/index.ts", "../src/helpers/DualRuntimeFactory.ts", "../src/helpers/LobbyUI.ts", "../src/runtime.ts"],
  "sourcesContent": ["/**\n * CameraFollower - Automatic camera following for local player\n *\n * Eliminates manual camera positioning code and fixes initialization timing bugs.\n * Automatically waits for player state to be ready, then follows smoothly.\n *\n * ## How it works:\n *\n * - **Initialization:** Uses `waitForMetadata` to wait for player position, then sets initial camera position\n * - **Updates:** Automatically updates camera position every frame based on follow mode\n * - **Modes:**\n *   - `instant`: Camera snaps directly to target (no smoothing)\n *   - `lerp`: Camera smoothly interpolates to target (configurable smoothness)\n *   - `deadzone`: Camera only moves when target leaves deadzone rectangle\n *\n * ## Why this helper exists:\n *\n * Without this helper, games manually set camera position in `update()`, which causes:\n * 1. **Timing bug:** Camera not positioned in `create()`, causing off-screen sprites on navigation\n * 2. **Boilerplate:** Same camera code repeated in every game\n * 3. **Edge cases:** Forgetting to check if player exists, handle player removal, etc.\n *\n * This helper solves all of these automatically.\n *\n * @example\n * ```ts\n * import { createCameraFollower } from '@martini-kit/phaser';\n *\n * // In scene.create() - simplest usage\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer' // Auto-follows local player\n * });\n *\n * // With smooth lerp following\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   mode: 'lerp',\n *   lerpFactor: 0.1 // Lower = smoother, higher = snappier\n * });\n *\n * // With deadzone (camera only moves when player leaves center area)\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   mode: 'deadzone',\n *   deadzone: { width: 200, height: 150 }\n * });\n *\n * // Follow specific player by ID\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: { stateKey: 'players', playerId: 'player-123' }\n * });\n *\n * // Set world bounds\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   bounds: { width: 1600, height: 1200 }\n * });\n *\n * // In scene.update() - camera automatically updates, no manual code needed!\n * // But you can manually update if needed:\n * // this.cameraFollower.update();\n *\n * // In scene shutdown/destroy:\n * this.cameraFollower.destroy();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface CameraFollowerTarget {\n  /**\n   * State key where the player/entity lives (default: 'players')\n   */\n  stateKey?: string;\n\n  /**\n   * Player ID to follow (if not specified, follows local player)\n   */\n  playerId?: string;\n}\n\nexport interface CameraFollowerConfig {\n  /**\n   * Target to follow\n   * - 'myPlayer': Follow local player (default)\n   * - { stateKey: 'players', playerId: 'id' }: Follow specific player\n   */\n  target?: 'myPlayer' | CameraFollowerTarget;\n\n  /**\n   * Follow mode\n   * - 'instant': Camera snaps directly to target (default)\n   * - 'lerp': Camera smoothly interpolates to target\n   * - 'deadzone': Camera only moves when target leaves deadzone\n   */\n  mode?: 'instant' | 'lerp' | 'deadzone';\n\n  /**\n   * Lerp factor for smooth following (0-1)\n   * Lower = smoother but laggier\n   * Higher = snappier but jerkier\n   * Default: 0.1\n   * Only used when mode = 'lerp'\n   */\n  lerpFactor?: number;\n\n  /**\n   * Camera offset from target center\n   * Default: { x: 0, y: 0 }\n   */\n  offset?: { x: number; y: number };\n\n  /**\n   * World bounds for camera\n   * If specified, sets camera bounds to prevent showing outside world\n   */\n  bounds?: { width: number; height: number };\n\n  /**\n   * Deadzone dimensions (only used when mode = 'deadzone')\n   * Camera only moves when target leaves this rectangle\n   * Default: { width: 200, height: 150 }\n   */\n  deadzone?: { width: number; height: number };\n\n  /**\n   * Whether to center camera on target\n   * If true, camera centers on target position\n   * If false, target position is used as-is\n   * Default: true\n   */\n  centerOnTarget?: boolean;\n}\n\nexport interface CameraFollower {\n  /**\n   * Manually update camera position (automatically called each frame)\n   */\n  update: () => void;\n\n  /**\n   * Clean up and stop following\n   */\n  destroy: () => void;\n\n  /**\n   * Change the target being followed\n   */\n  setTarget: (playerId: string) => void;\n\n  /**\n   * Get current target player ID\n   */\n  getTarget: () => string | null;\n}\n\n/**\n * Create a camera follower that automatically tracks a player\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Camera follower configuration\n * @returns CameraFollower instance\n */\nexport function createCameraFollower(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: CameraFollowerConfig = {}\n): CameraFollower {\n  const {\n    target = 'myPlayer',\n    mode = 'instant',\n    lerpFactor = 0.1,\n    offset = { x: 0, y: 0 },\n    bounds,\n    deadzone = { width: 200, height: 150 },\n    centerOnTarget = true,\n  } = config;\n\n  // Resolve target player ID\n  let targetPlayerId: string;\n  let stateKey: string;\n\n  if (target === 'myPlayer') {\n    targetPlayerId = adapter.getMyPlayerId();\n    stateKey = 'players';\n  } else {\n    targetPlayerId = target.playerId || adapter.getMyPlayerId();\n    stateKey = target.stateKey || 'players';\n  }\n\n  const camera = scene.cameras.main;\n  let unsubscribe: (() => void) | null = null;\n  let initialized = false;\n  let destroyed = false;\n\n  // Set world bounds if specified\n  if (bounds) {\n    camera.setBounds(0, 0, bounds.width, bounds.height);\n  }\n\n  // Initialize camera position when player is ready\n  const initializeCamera = () => {\n    const state = adapter['runtime'].getState() as any;\n    const players = state?.[stateKey];\n    const player = players?.[targetPlayerId];\n\n    if (player && typeof player.x === 'number' && typeof player.y === 'number') {\n      // Set initial camera position immediately to prevent off-screen rendering\n      setCameraPosition(player.x, player.y, true);\n      initialized = true;\n    }\n  };\n\n  // Wait for player to exist, then initialize camera\n  unsubscribe = adapter.waitForMetadata(\n    stateKey,\n    targetPlayerId,\n    ['x', 'y'],\n    (playerData) => {\n      if (!initialized && !destroyed) {\n        setCameraPosition(playerData.x, playerData.y, true);\n        initialized = true;\n      }\n    }\n  );\n\n  // Also try to initialize immediately in case player already exists\n  initializeCamera();\n\n  /**\n   * Set camera position based on target coordinates\n   */\n  function setCameraPosition(targetX: number, targetY: number, instant: boolean = false) {\n    if (destroyed) return;\n\n    const viewportWidth = camera.width;\n    const viewportHeight = camera.height;\n\n    // Calculate desired camera position\n    let desiredScrollX: number;\n    let desiredScrollY: number;\n\n    if (centerOnTarget) {\n      // Center camera on target\n      desiredScrollX = targetX - viewportWidth / 2 + offset.x;\n      desiredScrollY = targetY - viewportHeight / 2 + offset.y;\n    } else {\n      // Use target position directly\n      desiredScrollX = targetX + offset.x;\n      desiredScrollY = targetY + offset.y;\n    }\n\n    // Apply follow mode\n    if (instant || mode === 'instant') {\n      camera.scrollX = desiredScrollX;\n      camera.scrollY = desiredScrollY;\n    } else if (mode === 'lerp') {\n      camera.scrollX += (desiredScrollX - camera.scrollX) * lerpFactor;\n      camera.scrollY += (desiredScrollY - camera.scrollY) * lerpFactor;\n    } else if (mode === 'deadzone') {\n      // Calculate target position in screen space\n      const targetScreenX = targetX - camera.scrollX;\n      const targetScreenY = targetY - camera.scrollY;\n\n      const deadzoneLeft = (viewportWidth - deadzone.width) / 2;\n      const deadzoneRight = deadzoneLeft + deadzone.width;\n      const deadzoneTop = (viewportHeight - deadzone.height) / 2;\n      const deadzoneBottom = deadzoneTop + deadzone.height;\n\n      // Only move camera if target is outside deadzone\n      if (targetScreenX < deadzoneLeft) {\n        camera.scrollX += targetScreenX - deadzoneLeft;\n      } else if (targetScreenX > deadzoneRight) {\n        camera.scrollX += targetScreenX - deadzoneRight;\n      }\n\n      if (targetScreenY < deadzoneTop) {\n        camera.scrollY += targetScreenY - deadzoneTop;\n      } else if (targetScreenY > deadzoneBottom) {\n        camera.scrollY += targetScreenY - deadzoneBottom;\n      }\n    }\n  }\n\n  /**\n   * Update camera position based on current player position\n   */\n  function update() {\n    if (destroyed || !initialized) return;\n\n    const state = adapter['runtime'].getState() as any;\n    const players = state?.[stateKey];\n    const player = players?.[targetPlayerId];\n\n    if (player && typeof player.x === 'number' && typeof player.y === 'number') {\n      setCameraPosition(player.x, player.y);\n    }\n  }\n\n  /**\n   * Auto-update camera every frame\n   */\n  const updateEvent = scene.events.on('update', update);\n\n  /**\n   * Clean up resources\n   */\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n\n    scene.events.off('update', update);\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = null;\n    }\n  }\n\n  /**\n   * Change the target being followed\n   */\n  function setTarget(newPlayerId: string) {\n    targetPlayerId = newPlayerId;\n    initialized = false;\n\n    // Clean up old subscription\n    if (unsubscribe) {\n      unsubscribe();\n    }\n\n    // Wait for new player and reinitialize\n    unsubscribe = adapter.waitForMetadata(\n      stateKey,\n      targetPlayerId,\n      ['x', 'y'],\n      (playerData) => {\n        if (!initialized && !destroyed) {\n          setCameraPosition(playerData.x, playerData.y, true);\n          initialized = true;\n        }\n      }\n    );\n  }\n\n  /**\n   * Get current target player ID\n   */\n  function getTarget(): string | null {\n    return targetPlayerId;\n  }\n\n  return {\n    update,\n    destroy,\n    setTarget,\n    getTarget,\n  };\n}\n", "/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Optional motion profile to auto-tune sync defaults.\n   * 'platformer' \u2192 faster sync (16ms) to match physics frame rate.\n   */\n  motionProfile?: 'platformer' | 'projectile' | 'prop';\n\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Optional: Called after sprite is fully created and ready (onCreate + onCreatePhysics done)\n   * Fires for BOTH initial sprites and late-joining sprites\n   * Use this for inter-sprite setup (collisions, custom logic, event wiring, etc.)\n   *\n   * @example\n   * ```ts\n   * onAdd: (sprite, key, data, context) => {\n   *   // Attach particle emitter\n   *   const trail = this.add.particles(sprite.x, sprite.y, 'particle');\n   *   trail.startFollow(sprite);\n   *\n   *   // Per-sprite collision with unique object\n   *   if (this.boss) {\n   *     this.physics.add.collider(sprite, this.boss);\n   *   }\n   * }\n   * ```\n   */\n  onAdd?: (\n    sprite: any,\n    key: string,\n    data: TData,\n    context: {\n      manager: SpriteManager<TData>;\n      allSprites: Map<string, any>;\n    }\n  ) => void;\n\n  /**\n   * Optional: Keys from the initial data object to sync exactly once\n   * Useful for metadata like player roles that should be available on clients.\n   */\n  staticProperties?: (keyof TData & string)[];\n\n  /**\n   * **Unified Sync Configuration**\n   *\n   * Controls automatic property synchronization between sprites and state.\n   *\n   * @example\n   * ```ts\n   * // Default: Sync sprite \u2192 state (physics-driven, host only)\n   * sync: {\n   *   properties: ['x', 'y', 'rotation', 'alpha'],  // default\n   *   interval: 16  // ms, default (60 FPS)\n   * }\n   *\n   * // Adaptive sync: Only sync when sprite moves\n   * sync: {\n   *   properties: ['x', 'y'],\n   *   adaptive: true,  // Skip sync for idle sprites\n   *   adaptiveThreshold: 1  // pixels per frame\n   * }\n   *\n   * // State-driven: Sync state \u2192 sprite (rare, use StateDrivenSpawner instead)\n   * sync: {\n   *   properties: ['x', 'y'],\n   *   direction: 'toSprite'\n   * }\n   * ```\n   */\n  sync?: {\n    /**\n     * Properties to sync (default: ['x', 'y', 'rotation', 'alpha'])\n     */\n    properties?: string[];\n\n    /**\n     * Sync direction (default: 'toState' for SpriteManager)\n     * - 'toState': Sprite properties \u2192 State (physics-driven, host only)\n     * - 'toSprite': State properties \u2192 Sprite (state-driven, rare)\n     */\n    direction?: 'toState' | 'toSprite';\n\n    /**\n     * Sync interval in milliseconds (default: 16ms / 60 FPS)\n     */\n    interval?: number;\n\n    /**\n     * Enable adaptive sync (default: false)\n     * When true, skips sync for idle sprites (reduces bandwidth)\n     */\n    adaptive?: boolean;\n\n    /**\n     * Movement threshold for adaptive sync (default: 1 pixel/frame)\n     * Only syncs if sprite moved more than this distance\n     */\n    adaptiveThreshold?: number;\n  };\n\n\n  /**\n   * Optional label configuration. When provided, SpriteManager renders labels above sprites.\n   */\n  label?: {\n    getText: (data: TData) => string;\n    offset?: { x?: number; y?: number };\n    style?: Phaser.Types.GameObjects.Text.TextStyle;\n  };\n\n  /**\n   * Optional: Namespace for sprite data in state (default: '_sprites')\n   * Use different namespaces to prevent collisions between multiple managers\n   *\n   * @example\n   * ```ts\n   * const playerMgr = adapter.createSpriteManager({\n   *   namespace: 'players',  // \u2192 state.players.*\n   *   onCreate: ...\n   * });\n   *\n   * const enemyMgr = adapter.createSpriteManager({\n   *   namespace: 'enemies',  // \u2192 state.enemies.*\n   *   onCreate: ...\n   * });\n   * ```\n   */\n  namespace?: string;\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private spriteData = new Map<string, TData>();\n  private labels = new Map<\n    string,\n    { text: Phaser.GameObjects.Text; offset?: { x?: number; y?: number } }\n  >();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n  public readonly namespace: string;\n  private readonly effectiveSyncInterval?: number;\n\n  /**\n   * Track sprites created locally via add() method\n   * This eliminates the need to know player IDs for filtering\n   */\n  private localSprites = new Set<string>();\n\n  /**\n   * Phaser Group containing all sprites managed by this SpriteManager.\n   * Use this for collision detection:\n   * @example\n   * ```ts\n   * this.physics.add.collider(ball, playerManager.group);\n   * ```\n   *\n   * The group automatically includes all sprites added to this manager,\n   * both early-joining and late-joining, solving the \"forgot to add collider\n   * for new player\" bug.\n   */\n  public readonly group: Phaser.GameObjects.Group;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n    this.namespace = config.namespace || '_sprites';\n    const hasPhysicsManager = adapter.hasPhysicsManagedNamespace(this.namespace);\n    const motionProfile = config.motionProfile;\n    this.effectiveSyncInterval =\n      config.sync?.interval ??\n      (motionProfile === 'platformer' || hasPhysicsManager ? 13 : 13);\n\n    if (hasPhysicsManager && config.sync?.direction !== 'toSprite') {\n      console.warn(\n        `[SpriteManager] Namespace \"${this.namespace}\" is managed by PhysicsManager. ` +\n          'For platformer-style movement, set sync.direction: \"toSprite\" or disable syncPositionToState in PhysicsManager to avoid double writers.'\n      );\n    }\n\n    // Create Phaser group for collision management\n    const scene = adapter.getScene();\n    this.group = scene.add.group();\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Track that we created this sprite locally\n    this.localSprites.add(key);\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n    this.spriteData.set(key, data);\n    this.createLabel(key, data, sprite);\n\n    // Add to group for collision management\n    this.group.add(sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    if (this.config.staticProperties?.length) {\n      const staticData: Partial<TData> = {};\n      for (const prop of this.config.staticProperties) {\n        if (prop in data) {\n          staticData[prop] = data[prop];\n        }\n      }\n      if (Object.keys(staticData).length > 0) {\n        this.adapter.setSpriteStaticData(key, staticData, this.namespace);\n      }\n    }\n\n    // Track for automatic sync (host only)\n    const syncProperties = this.config.sync?.properties || ['x', 'y', 'rotation', 'alpha'];\n    const syncInterval = this.effectiveSyncInterval;\n    // Phase 1: Enable adaptive sync by default for bandwidth efficiency\n    const adaptiveSync = this.config.sync?.adaptive ?? true; // Default: true\n    const adaptiveSyncThreshold = this.config.sync?.adaptiveThreshold;\n\n    this.adapter.trackSprite(sprite, key, {\n      properties: syncProperties,\n      syncInterval: syncInterval,\n      namespace: this.namespace,\n      motionProfile: this.config.motionProfile,\n      adaptiveSync: adaptiveSync,\n      adaptiveSyncThreshold: adaptiveSyncThreshold\n    });\n\n    // Call onAdd hook (if provided)\n    if (this.config.onAdd) {\n      this.config.onAdd(sprite, key, data, {\n        manager: this,\n        allSprites: this.sprites\n      });\n    }\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n    const label = this.labels.get(key);\n    if (label) {\n      label.text.destroy();\n      this.labels.delete(key);\n    }\n    this.spriteData.delete(key);\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key, this.namespace);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   *\n   * Automatically calls update methods on attached components (arrows, health bars, etc.)\n   * if they use the `_update*` naming convention and autoUpdate is disabled.\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n    this.updateLabels();\n\n    // Auto-call attached component updates (fallback for manual mode)\n    // Note: If attachDirectionalIndicator is using autoUpdate: true (default),\n    // this is redundant but harmless. This provides backward compatibility\n    // for code that set autoUpdate: false and expects manual updates.\n    for (const sprite of this.sprites.values()) {\n      if (typeof sprite._updateArrow === 'function') {\n        sprite._updateArrow();\n      }\n      // Future: _updateHealthBar, _updateNameTag, etc.\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteData = state[this.namespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      // Skip sprites we created locally (pit of success: no player ID needed!)\n      if (this.localSprites.has(key)) {\n        continue;\n      }\n\n      if (!this.sprites.has(key)) {\n        // FIX #1: Wait for static properties before creating sprites (pit of success!)\n        // This prevents the \"sprite created before metadata arrives\" race condition.\n        // Matches the pattern used by PlayerUIManager (lines 200-207).\n        if (this.config.staticProperties?.length) {\n          const hasAllStatic = this.config.staticProperties.every(prop => prop in data);\n          if (!hasAllStatic) {\n            // Static metadata not ready yet - skip creation until next sync\n            continue;\n          }\n        }\n\n        // Create new sprite (now guaranteed to have all static properties!)\n        const sprite = this.config.onCreate(key, data as TData);\n        this.sprites.set(key, sprite);\n        this.spriteData.set(key, data as TData);\n        this.group.add(sprite); // Add to group on client side too\n        this.adapter.registerRemoteSprite(key, sprite, this.namespace);\n        this.createLabel(key, data as TData, sprite);\n\n        // Call onAdd hook (if provided) - runs for late-joining sprites on clients\n        if (this.config.onAdd) {\n          this.config.onAdd(sprite, key, data as TData, {\n            manager: this,\n            allSprites: this.sprites\n          });\n        }\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data as TData);\n        }\n        this.spriteData.set(key, data as TData);\n      }\n\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n\n  private createLabel(key: string, data: TData, sprite: any): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n\n    const scene = this.adapter.getScene();\n    if (!scene?.add?.text) return;\n\n    const textValue = labelConfig.getText(data);\n    const style = labelConfig.style || { fontSize: '12px', color: '#ffffff' };\n    const label = scene.add.text(sprite.x, sprite.y, textValue, style).setOrigin(0.5);\n    this.labels.set(key, { text: label, offset: labelConfig.offset });\n  }\n\n  private updateLabels(): void {\n    for (const key of this.labels.keys()) {\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n  }\n\n  private updateLabelText(key: string): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const data = this.spriteData.get(key);\n    if (!data) return;\n\n    const next = labelConfig.getText(data);\n    if (labelEntry.text.text !== next) {\n      labelEntry.text.setText(next);\n    }\n  }\n\n  private updateLabelPosition(key: string): void {\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    const offsetX = labelEntry.offset?.x ?? 0;\n    const offsetY = labelEntry.offset?.y ?? -20;\n    labelEntry.text.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n  }\n}\n", "/**\n * Input Profiles - Pre-defined control schemes\n *\n * Eliminates manual key binding boilerplate by providing standard control patterns.\n */\n\nimport type { KeyBindings } from './InputManager.js';\n\nexport interface AggregatedProfileConfig {\n  /** Profile type */\n  type: 'aggregated';\n\n  /** Action name to submit */\n  action: string;\n\n  /** Map of field names to key codes */\n  keys: Record<string, string>;\n\n  /** Continuous or oneshot mode */\n  mode?: 'continuous' | 'oneshot';\n}\n\nexport interface PerKeyProfileConfig {\n  /** Profile type */\n  type: 'per-key';\n\n  /** Key bindings for this profile */\n  bindings: KeyBindings;\n}\n\nexport interface InputProfile {\n  /** Profile name */\n  name: string;\n\n  /** Profile configuration (aggregated or per-key) */\n  config: AggregatedProfileConfig | PerKeyProfileConfig;\n\n  /** Description of the control scheme */\n  description?: string;\n}\n\nexport interface ProfileOptions {\n  /** Override specific keys */\n  overrides?: Partial<KeyBindings>;\n\n  /** Player number (1-based). Changes arrow keys to WASD for player 2 */\n  player?: 1 | 2;\n\n  /** Override action names */\n  action?: string;\n}\n\n/**\n * Built-in input profiles\n */\nexport const BUILT_IN_PROFILES: Record<string, InputProfile> = {\n  platformer: {\n    name: 'platformer',\n    description: 'Side-scrolling platformer controls (Arrow keys + Space for jump)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'Space'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  platformerWASD: {\n    name: 'platformerWASD',\n    description: 'Platformer controls with WASD',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDown: {\n    name: 'topDown',\n    description: '4-directional movement (Arrow keys)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'ArrowUp',\n        down: 'ArrowDown'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDownWASD: {\n    name: 'topDownWASD',\n    description: '4-directional movement (WASD)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W',\n        down: 'S'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  shooter: {\n    name: 'shooter',\n    description: 'Top-down shooter (WASD for move, Space for shoot)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'Space': { action: 'shoot', mode: 'oneshot' },\n      }\n    }\n  },\n\n  twinStick: {\n    name: 'twinStick',\n    description: 'Twin-stick shooter (WASD for move, Arrow keys for aim)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'ArrowLeft': { action: 'aim', input: { x: -1 }, mode: 'continuous' },\n        'ArrowRight': { action: 'aim', input: { x: 1 }, mode: 'continuous' },\n        'ArrowUp': { action: 'aim', input: { y: -1 }, mode: 'continuous' },\n        'ArrowDown': { action: 'aim', input: { y: 1 }, mode: 'continuous' },\n      }\n    }\n  }\n};\n\n/**\n * Custom profile registry\n */\nconst customProfiles = new Map<string, InputProfile>();\n\n/**\n * Register a custom input profile\n *\n * @param name - Profile name\n * @param profile - Profile configuration\n *\n * @example\n * ```ts\n * registerProfile('custom-platformer', {\n *   name: 'custom-platformer',\n *   bindings: {\n *     'A': { action: 'move', input: { left: true }, mode: 'continuous' },\n *     'D': { action: 'move', input: { right: true }, mode: 'continuous' },\n *     'W': { action: 'jump', mode: 'oneshot' },\n *   }\n * });\n * ```\n */\nexport function registerProfile(name: string, profile: InputProfile): void {\n  customProfiles.set(name, profile);\n}\n\n/**\n * Get a profile by name (checks custom profiles first, then built-in)\n *\n * @param name - Profile name\n * @returns Profile or undefined if not found\n */\nexport function getProfile(name: string): InputProfile | undefined {\n  return customProfiles.get(name) || BUILT_IN_PROFILES[name];\n}\n\n/**\n * Apply profile options to a profile config\n *\n * @param profile - Original profile\n * @param options - Profile options\n * @returns Modified profile config\n */\nexport function applyProfileOptions(\n  profile: InputProfile,\n  options?: ProfileOptions\n): AggregatedProfileConfig | PerKeyProfileConfig {\n  if (!options) return profile.config;\n\n  const config = profile.config;\n\n  // For aggregated profiles\n  if (config.type === 'aggregated') {\n    let keys = { ...config.keys };\n\n    // Apply player number (swap arrow keys for WASD)\n    if (options.player === 2) {\n      const keyMap: Record<string, string> = {\n        'ArrowLeft': 'A',\n        'ArrowRight': 'D',\n        'ArrowUp': 'W',\n        'ArrowDown': 'S',\n        'Space': 'Space', // Keep Space unchanged\n      };\n\n      const newKeys: Record<string, string> = {};\n      for (const [field, key] of Object.entries(keys)) {\n        newKeys[field] = keyMap[key] || key;\n      }\n      keys = newKeys;\n    }\n\n    return {\n      type: 'aggregated',\n      action: options.action || config.action,\n      keys,\n      mode: config.mode\n    };\n  }\n\n  // For per-key profiles\n  let bindings = { ...config.bindings };\n\n  // Apply player number (swap arrow keys for WASD)\n  if (options.player === 2) {\n    const keyMap: Record<string, string> = {\n      'ArrowLeft': 'A',\n      'ArrowRight': 'D',\n      'ArrowUp': 'W',\n      'ArrowDown': 'S',\n    };\n\n    const newBindings: KeyBindings = {};\n    for (const [key, binding] of Object.entries(bindings)) {\n      const newKey = keyMap[key] || key;\n      newBindings[newKey] = binding;\n    }\n    bindings = newBindings;\n  }\n\n  // Apply action override\n  if (options.action) {\n    for (const key of Object.keys(bindings)) {\n      const binding = bindings[key];\n      if (typeof binding === 'object') {\n        bindings[key] = { ...binding, action: options.action };\n      }\n    }\n  }\n\n  // Apply key overrides\n  if (options.overrides) {\n    for (const [key, binding] of Object.entries(options.overrides)) {\n      if (binding !== undefined) {\n        bindings[key] = binding;\n      }\n    }\n  }\n\n  return {\n    type: 'per-key',\n    bindings\n  };\n}\n\n/**\n * Merge multiple profiles into one\n *\n * @param profileNames - Array of profile names to merge\n * @returns Merged bindings (only works with per-key profiles)\n *\n * @example\n * ```ts\n * const bindings = mergeProfiles(['shooter', 'twinStick']);\n * // Combines multiple per-key profiles\n * ```\n */\nexport function mergeProfiles(profileNames: string[]): KeyBindings {\n  const merged: KeyBindings = {};\n\n  for (const name of profileNames) {\n    const profile = getProfile(name);\n    if (profile && profile.config.type === 'per-key') {\n      Object.assign(merged, profile.config.bindings);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * List all available profiles\n *\n * @returns Array of profile names\n */\nexport function listProfiles(): string[] {\n  return [\n    ...Object.keys(BUILT_IN_PROFILES),\n    ...Array.from(customProfiles.keys())\n  ];\n}\n", "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini-kit/core';\nimport { getProfile, applyProfileOptions, mergeProfiles as mergeProfileBindings, type ProfileOptions } from './InputProfiles.js';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport interface AggregatedBinding {\n  keyMap: Record<string, string>;\n  state: Record<string, any>;\n  mode: 'continuous' | 'oneshot';\n  targetId?: string;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n  private aggregatedBindings = new Map<string, AggregatedBinding>(); // NEW: Track aggregated state\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n    }\n  }\n\n  /**\n   * Bind multiple keys that aggregate into a single input state\n   * Perfect for platformers, twin-stick shooters, fighting games\n   *\n   * Key codes: Use standard DOM key names (ArrowLeft, ArrowRight, ArrowUp, ArrowDown, Space).\n   * Letter keys (A-Z) are automatically uppercased. Arrow keys and Space are automatically\n   * converted to Phaser's internal format (LEFT, RIGHT, UP, DOWN, SPACE).\n   *\n   * @example\n   * ```ts\n   * // Platformer controls - use ArrowLeft/ArrowRight/Space\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'ArrowLeft',\n   *   right: 'ArrowRight',\n   *   up: 'Space'\n   * });\n   * // Automatically tracks: { left: true/false, right: true/false, up: true/false }\n   *\n   * // Top-down movement - letter keys work as-is\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'A',\n   *   right: 'D',\n   *   up: 'W',\n   *   down: 'S'\n   * });\n   * ```\n   */\n  bindKeysAggregated(\n    action: string,\n    keyMap: Record<string, string>,\n    options?: {\n      initialState?: Record<string, any>;\n      mode?: 'continuous' | 'oneshot';\n      targetId?: string;\n    }\n  ): void {\n    // Build initial state (default to false for each field)\n    const state = options?.initialState ||\n      Object.fromEntries(\n        Object.keys(keyMap).map(field => [field, false])\n      );\n\n    this.aggregatedBindings.set(action, {\n      keyMap,\n      state,\n      mode: options?.mode || 'continuous',\n      targetId: options?.targetId\n    });\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n\n    // Handle aggregated bindings (multi-key state tracking)\n    for (const [action, binding] of this.aggregatedBindings.entries()) {\n      let stateChanged = false;\n\n      // Check each key in the map and update state\n      for (const [field, keyCode] of Object.entries(binding.keyMap)) {\n        // IMPORTANT: Convert user-friendly key names to Phaser's internal key codes\n        // Phaser uses uppercase constants (e.g., 'LEFT' not 'ArrowLeft')\n        // This mapping allows users to use standard DOM key names while Phaser expects its own format\n        // See: https://photonstorm.github.io/phaser3-docs/Phaser.Input.Keyboard.KeyCodes.html\n        let phaserKeyCode = keyCode;\n        const keyCodeMap: Record<string, string> = {\n          'ArrowLeft': 'LEFT',\n          'ArrowRight': 'RIGHT',\n          'ArrowUp': 'UP',\n          'ArrowDown': 'DOWN',\n          'Space': 'SPACE'\n        };\n\n        if (keyCodeMap[keyCode]) {\n          phaserKeyCode = keyCodeMap[keyCode];\n        }\n\n        const keyObj = this.scene.input.keyboard?.addKey(phaserKeyCode, false);\n        if (!keyObj) {\n          console.warn(`[InputManager] Failed to create key object for: ${keyCode} (mapped to ${phaserKeyCode})`);\n          continue;\n        }\n\n        const pressed = keyObj.isDown;\n\n        // Update state if changed\n        if (binding.state[field] !== pressed) {\n          binding.state[field] = pressed;\n          stateChanged = true;\n        }\n      }\n\n      // Submit aggregated state ONLY when changed (10x devtools improvement!)\n      // This prevents 60 actions/second when idle\n      if (stateChanged) {\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Use a pre-defined input profile\n   *\n   * @param profileName - Name of the profile ('platformer', 'topDown', 'shooter', etc.)\n   * @param options - Optional customization\n   *\n   * @example\n   * ```ts\n   * // Simple usage\n   * inputManager.useProfile('platformer');\n   *\n   * // With player 2 (uses WASD instead of arrows)\n   * inputManager.useProfile('platformer', { player: 2 });\n   *\n   * // With custom action name\n   * inputManager.useProfile('platformer', { action: 'move' });\n   *\n   * // With key overrides\n   * inputManager.useProfile('platformer', {\n   *   overrides: {\n   *     'Space': { action: 'jump', mode: 'oneshot' }\n   *   }\n   * });\n   * ```\n   */\n  useProfile(profileName: string, options?: ProfileOptions): void {\n    const profile = getProfile(profileName);\n\n    if (!profile) {\n      console.warn(`[InputManager] Profile \"${profileName}\" not found. Available profiles:`, [\n        'platformer', 'platformerWASD', 'topDown', 'topDownWASD', 'shooter', 'twinStick'\n      ]);\n      return;\n    }\n\n    const config = applyProfileOptions(profile, options);\n\n    if (config.type === 'aggregated') {\n      // Use aggregated binding for multi-key state tracking\n      this.bindKeysAggregated(config.action, config.keys, {\n        mode: config.mode\n      });\n    } else {\n      // Use per-key binding for separate actions\n      this.bindKeys(config.bindings);\n    }\n  }\n\n  /**\n   * Merge multiple profiles into one\n   *\n   * @param profileNames - Array of profile names\n   *\n   * @example\n   * ```ts\n   * // Combine platformer movement with shooter actions\n   * inputManager.mergeProfiles(['platformer', 'shooter']);\n   * ```\n   */\n  mergeProfiles(profileNames: string[]): void {\n    const merged = mergeProfileBindings(profileNames);\n    this.bindKeys(merged);\n  }\n\n  /**\n   * Bind edge-triggered actions (fire once on press, not every frame)\n   * Perfect for shoot, jump, interact, etc.\n   *\n   * @example\n   * ```ts\n   * // Shoot on space press\n   * inputManager.bindEdgeTrigger('Space', 'shoot');\n   *\n   * // Jump on up arrow press\n   * inputManager.bindEdgeTrigger('ArrowUp', 'jump');\n   *\n   * // Multiple edge triggers\n   * inputManager.bindEdgeTriggers({\n   *   'Space': 'shoot',\n   *   'E': 'interact',\n   *   'R': 'reload'\n   * });\n   * ```\n   */\n  bindEdgeTrigger(key: string, action: string, input?: any): void {\n    this.keyBindings.set(key.toUpperCase(), {\n      action,\n      input,\n      mode: 'oneshot'\n    });\n  }\n\n  /**\n   * Bind multiple edge-triggered actions at once\n   */\n  bindEdgeTriggers(bindings: Record<string, string | { action: string; input?: any }>): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      if (typeof binding === 'string') {\n        this.bindEdgeTrigger(key, binding);\n      } else {\n        this.bindEdgeTrigger(key, binding.action, binding.input);\n      }\n    }\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * **NEW: Bridge input to actions automatically**\n   *\n   * Eliminates manual edge detection and action submission boilerplate.\n   * Integrates with input profiles for complete automation.\n   *\n   * @example\n   * ```ts\n   * // Simple: Use existing profile bindings\n   * inputManager.useProfile('topDown');\n   * inputManager.bridgeToActions({\n   *   move: 'continuous',  // submits every frame from profile\n   *   shoot: 'edge'        // submits once on press from profile\n   * });\n   *\n   * // Advanced: Custom key mapping\n   * inputManager.bridgeToActions({\n   *   move: { type: 'continuous', keys: { left: 'A', right: 'D', up: 'W', down: 'S' } },\n   *   shoot: { type: 'edge', key: 'SPACE' }\n   * });\n   * ```\n   */\n  bridgeToActions(config: Record<string, 'continuous' | 'edge' | {\n    type: 'continuous' | 'edge';\n    key?: string;\n    keys?: Record<string, string>;\n  }>): void {\n    for (const [action, actionConfig] of Object.entries(config)) {\n      const normalized = typeof actionConfig === 'string'\n        ? { type: actionConfig }\n        : actionConfig;\n\n      if (normalized.type === 'continuous') {\n        // For continuous actions, check if we have aggregated bindings\n        const aggregated = this.aggregatedBindings.get(action);\n        if (aggregated) {\n          // Already configured via useProfile/bindKeysAggregated\n          continue;\n        }\n\n        // Set up new aggregated binding if keys provided\n        if (normalized.keys) {\n          this.bindKeysAggregated(action, normalized.keys, { mode: 'continuous' });\n        }\n      } else if (normalized.type === 'edge') {\n        // For edge triggers, set up binding if key provided\n        if (normalized.key) {\n          this.bindEdgeTrigger(normalized.key, action);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n", "/**\n * PlayerUIManager - Automatic UI synchronization for players\n *\n * Eliminates bugs caused by:\n * - Creating UI before player metadata (side, team, etc.) is synced\n * - Forgetting to update UI when player data changes\n * - Manual loops to create/update/destroy UI elements\n *\n * Features:\n * - Waits for staticProperties before creating UI (no race conditions!)\n * - Auto-repositions UI when metadata changes\n * - Auto-creates UI for late-joining players\n * - Auto-destroys UI when players leave\n *\n * Usage:\n * ```ts\n * const playerUI = adapter.createPlayerUIManager({\n *   score: {\n *     position: (player) => ({\n *       x: player.side === 'left' ? 200 : 600,\n *       y: 80\n *     }),\n *     getText: (player) => String(player.score || 0),\n *     style: { fontSize: '48px', color: '#fff' }\n *   },\n *\n *   health: {\n *     position: (player) => ({ x: player.x, y: player.y - 30 }),\n *     width: 50,\n *     height: 5,\n *     getValue: (player) => player.health / player.maxHealth,\n *     backgroundColor: 0x333333,\n *     foregroundColor: 0x00ff00\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TextUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   * Called when UI is created AND when metadata changes\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Text content function\n   */\n  getText: (player: any, playerId: string) => string;\n\n  /**\n   * Phaser text style\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   * Example: ['side', 'team'] - waits until these are synced\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface BarUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Value function (0-1 range)\n   */\n  getValue: (player: any, playerId: string) => number;\n\n  /**\n   * Bar dimensions\n   */\n  width: number;\n  height: number;\n\n  /**\n   * Colors\n   */\n  backgroundColor: number;\n  foregroundColor: number;\n\n  /**\n   * Bar origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface PlayerUIManagerConfig {\n  /**\n   * UI elements keyed by name\n   * Each element can be text or bar type\n   */\n  [elementName: string]: TextUIConfig | BarUIConfig;\n}\n\ntype UIElement = {\n  type: 'text' | 'bar';\n  config: TextUIConfig | BarUIConfig;\n  gameObject: any; // Phaser.GameObjects.Text | Container with rectangles\n};\n\nexport class PlayerUIManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: PlayerUIManagerConfig;\n  private playerElements: Map<string, Map<string, UIElement>> = new Map(); // playerId -> elementName -> UIElement\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, scene: any, config: PlayerUIManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config;\n\n    // Subscribe to state changes\n    this.unsubscribe = adapter.onChange((state: any) => {\n      this.syncFromState(state);\n    });\n  }\n\n  /**\n   * Get UI element for a specific player\n   */\n  get(playerId: string, elementName: string): any {\n    return this.playerElements.get(playerId)?.get(elementName)?.gameObject;\n  }\n\n  /**\n   * Manually update all UI (also called automatically on state changes)\n   */\n  update(): void {\n    const state = this.adapter.getRuntime().getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Destroy all UI elements\n    for (const [playerId, elements] of this.playerElements.entries()) {\n      for (const [elementName, element] of elements.entries()) {\n        this.destroyElement(element);\n      }\n    }\n    this.playerElements.clear();\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * Sync UI from state\n   */\n  private syncFromState(state: any): void {\n    if (!state.players) return;\n\n    const existingPlayers = new Set(this.playerElements.keys());\n\n    // Create/update UI for each player\n    for (const [playerId, playerData] of Object.entries(state.players) as [string, any][]) {\n      existingPlayers.delete(playerId);\n\n      // Get or create element map for this player\n      let elements = this.playerElements.get(playerId);\n      if (!elements) {\n        elements = new Map();\n        this.playerElements.set(playerId, elements);\n      }\n\n      // Create/update each UI element\n      for (const [elementName, elementConfig] of Object.entries(this.config)) {\n        const existing = elements.get(elementName);\n\n        // Check if required metadata exists\n        const requiredMetadata = (elementConfig as any).requiredMetadata || [];\n        const hasMetadata = requiredMetadata.every((key: string) => key in playerData);\n\n        if (!hasMetadata) {\n          // Metadata not ready yet - skip creation\n          continue;\n        }\n\n        if (!existing) {\n          // Create new UI element\n          const element = this.createElement(elementName, elementConfig, playerId, playerData);\n          if (element) {\n            elements.set(elementName, element);\n          }\n        } else {\n          // Update existing UI element\n          this.updateElement(existing, playerId, playerData);\n        }\n      }\n    }\n\n    // Remove UI for players who left\n    for (const playerId of existingPlayers) {\n      const elements = this.playerElements.get(playerId);\n      if (elements) {\n        for (const element of elements.values()) {\n          this.destroyElement(element);\n        }\n      }\n      this.playerElements.delete(playerId);\n    }\n  }\n\n  /**\n   * Create a UI element\n   */\n  private createElement(\n    elementName: string,\n    config: TextUIConfig | BarUIConfig,\n    playerId: string,\n    playerData: any\n  ): UIElement | null {\n    const pos = config.position(playerData, playerId);\n\n    if (this.isTextConfig(config)) {\n      // Create text element\n      const text = this.scene.add.text(\n        pos.x,\n        pos.y,\n        config.getText(playerData, playerId),\n        config.style || {}\n      );\n\n      if (config.origin !== undefined) {\n        if (typeof config.origin === 'number') {\n          text.setOrigin(config.origin);\n        } else {\n          text.setOrigin(config.origin.x, config.origin.y);\n        }\n      }\n\n      if (config.depth !== undefined) {\n        text.setDepth(config.depth);\n      }\n\n      return {\n        type: 'text',\n        config,\n        gameObject: text\n      };\n    } else {\n      // Create bar element (container with two rectangles)\n      const container = this.scene.add.container(pos.x, pos.y);\n\n      const bg = this.scene.add.rectangle(0, 0, config.width, config.height, config.backgroundColor);\n      const fg = this.scene.add.rectangle(\n        0,\n        0,\n        config.width * config.getValue(playerData, playerId),\n        config.height,\n        config.foregroundColor\n      );\n\n      if (config.origin !== undefined) {\n        const originX = typeof config.origin === 'number' ? config.origin : config.origin.x;\n        const originY = typeof config.origin === 'number' ? config.origin : config.origin.y;\n        bg.setOrigin(originX, originY);\n        fg.setOrigin(originX, originY);\n      }\n\n      container.add([bg, fg]);\n\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n\n      // Store references for updates\n      (container as any)._bg = bg;\n      (container as any)._fg = fg;\n\n      return {\n        type: 'bar',\n        config,\n        gameObject: container\n      };\n    }\n  }\n\n  /**\n   * Update a UI element\n   */\n  private updateElement(element: UIElement, playerId: string, playerData: any): void {\n    const pos = element.config.position(playerData, playerId);\n\n    if (element.type === 'text') {\n      const config = element.config as TextUIConfig;\n      const text = element.gameObject;\n\n      text.setPosition(pos.x, pos.y);\n      text.setText(config.getText(playerData, playerId));\n    } else {\n      const config = element.config as BarUIConfig;\n      const container = element.gameObject;\n      const fg = (container as any)._fg;\n\n      container.setPosition(pos.x, pos.y);\n\n      // Update bar width based on value\n      const value = Math.max(0, Math.min(1, config.getValue(playerData, playerId)));\n      fg.width = config.width * value;\n    }\n  }\n\n  /**\n   * Destroy a UI element\n   */\n  private destroyElement(element: UIElement): void {\n    if (element.gameObject && element.gameObject.destroy) {\n      element.gameObject.destroy();\n    }\n  }\n\n  /**\n   * Type guard for TextUIConfig\n   */\n  private isTextConfig(config: TextUIConfig | BarUIConfig): config is TextUIConfig {\n    return 'getText' in config;\n  }\n}\n", "/**\n * CollisionManager - Declarative collision rule system\n *\n * Eliminates \"forgot to add collider for late-joining player\" bugs by:\n * - Declaring collision rules ONCE\n * - Auto-applying rules to all sprites (early and late-joining)\n * - Supporting sprites, SpriteManagers, and Phaser groups\n *\n * Usage:\n * ```ts\n * const collisionManager = adapter.createCollisionManager();\n *\n * // Register a ball sprite\n * collisionManager.registerSprite('ball', this.ball);\n *\n * // Declare collision rules ONCE\n * collisionManager.addCollision('ball', this.spriteManager);\n * // \u261D\uFE0F Automatically adds colliders for all current AND future paddles!\n *\n * // With custom handler\n * collisionManager.addCollision(this.bulletGroup, this.enemyGroup, {\n *   onCollide: (bullet, enemy) => {\n *     enemy.takeDamage(bullet.damage);\n *     bullet.destroy();\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface CollisionRule {\n  a: string | SpriteManager | any; // Phaser.Physics.Arcade.Group or sprite\n  b: string | SpriteManager | any;\n  handler?: (objA: any, objB: any) => void;\n}\n\nexport interface CollisionManagerConfig {\n  /**\n   * Optional: Global collision handler\n   * Called for all collisions if no specific handler provided\n   */\n  onCollide?: (obj1: any, obj2: any) => void;\n}\n\nexport class CollisionManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: CollisionManagerConfig;\n  private rules: CollisionRule[] = [];\n  private colliders: any[] = []; // Phaser.Physics.Arcade.Collider instances\n  private namedSprites: Map<string, any> = new Map(); // key -> sprite\n  private spriteToColliders: WeakMap<any, Set<any>> = new WeakMap(); // sprite -> Set of colliders\n\n  constructor(adapter: PhaserAdapter, scene: any, config?: CollisionManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config || {};\n  }\n\n  /**\n   * Register a sprite by name (for string-based collision rules)\n   *\n   * @example\n   * ```ts\n   * collisionManager.registerSprite('ball', this.ball);\n   * collisionManager.addCollision('ball', paddleManager);\n   * ```\n   */\n  registerSprite(key: string, sprite: any): void {\n    this.namedSprites.set(key, sprite);\n    // Re-apply all rules to create colliders for this newly registered sprite\n    for (const rule of this.rules) {\n      this.applyRule(rule);\n    }\n  }\n\n  /**\n   * Unregister a sprite by name\n   */\n  unregisterSprite(key: string): void {\n    const sprite = this.namedSprites.get(key);\n    if (sprite) {\n      this.removeCollidersForSprite(sprite);\n    }\n    this.namedSprites.delete(key);\n  }\n\n  /**\n   * Add collision between sprites/groups/managers\n   *\n   * Supports:\n   * - String keys (via registerSprite)\n   * - SpriteManager instances (auto-syncs with new sprites)\n   * - Phaser sprites or groups\n   */\n  addCollision(\n    a: string | SpriteManager | any,\n    b: string | SpriteManager | any,\n    options?: {\n      onCollide?: (obj1: any, obj2: any) => void;\n    }\n  ): void {\n    const rule: CollisionRule = {\n      a,\n      b,\n      handler: options?.onCollide\n    };\n\n    this.rules.push(rule);\n\n    // Apply rule immediately\n    // Note: If either side is a SpriteManager, resolveToObjects() will return\n    // the manager's Phaser Group, which automatically handles all sprites\n    // (both current and future) without needing lifecycle hooks\n    this.applyRule(rule);\n  }\n\n  /**\n   * Remove collision rule\n   */\n  removeCollision(a: string | SpriteManager | any, b: string | SpriteManager | any): void {\n    const ruleIndex = this.rules.findIndex(r =>\n      (r.a === a && r.b === b) || (r.a === b && r.b === a)\n    );\n\n    if (ruleIndex !== -1) {\n      this.rules.splice(ruleIndex, 1);\n      // Note: We don't remove existing colliders, just stop creating new ones\n    }\n  }\n\n  /**\n   * Cleanup all colliders\n   */\n  destroy(): void {\n    for (const collider of this.colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n    }\n    this.colliders.length = 0;\n    this.rules.length = 0;\n    this.namedSprites.clear();\n  }\n\n  /**\n   * Apply a single collision rule (create colliders)\n   */\n  private applyRule(rule: CollisionRule): void {\n    const objectsA = this.resolveToObjects(rule.a);\n    const objectsB = this.resolveToObjects(rule.b);\n\n    if (objectsA.length === 0 || objectsB.length === 0) {\n      // One or both sides have no objects yet\n      return;\n    }\n\n    const handler = rule.handler || this.config.onCollide;\n\n    // Create colliders for each combination\n    for (const objA of objectsA) {\n      for (const objB of objectsB) {\n        // Skip if collider already exists\n        if (this.hasCollider(objA, objB)) {\n          continue;\n        }\n\n        // Create the collider\n        const collider = this.scene.physics.add.collider(objA, objB, handler);\n        this.colliders.push(collider);\n\n        // Track colliders per sprite\n        this.trackCollider(objA, collider);\n        this.trackCollider(objB, collider);\n      }\n    }\n  }\n\n  /**\n   * Resolve a rule target to an array of Phaser objects\n   */\n  private resolveToObjects(target: string | SpriteManager | any): any[] {\n    if (typeof target === 'string') {\n      // It's a named sprite\n      const sprite = this.namedSprites.get(target);\n      return sprite ? [sprite] : [];\n    }\n\n    if (this.isSpriteManager(target)) {\n      // It's a SpriteManager - return its Phaser Group\n      // The group automatically handles all sprites (early and late-joining)\n      return [(target as SpriteManager).group];\n    }\n\n    // It's a raw Phaser object (sprite or group)\n    return [target];\n  }\n\n  /**\n   * Check if target is a SpriteManager\n   */\n  private isSpriteManager(target: any): boolean {\n    return target && typeof target === 'object' && 'getAll' in target && 'add' in target;\n  }\n\n  /**\n   * Check if a collider already exists between two objects\n   */\n  private hasCollider(objA: any, objB: any): boolean {\n    const collidersA = this.spriteToColliders.get(objA);\n    const collidersB = this.spriteToColliders.get(objB);\n\n    if (!collidersA || !collidersB) {\n      return false;\n    }\n\n    // Check if any collider is shared\n    for (const collider of collidersA) {\n      if (collidersB.has(collider)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Track that a collider belongs to a sprite\n   */\n  private trackCollider(sprite: any, collider: any): void {\n    let colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) {\n      colliders = new Set();\n      this.spriteToColliders.set(sprite, colliders);\n    }\n    colliders.add(collider);\n  }\n\n  /**\n   * Remove all colliders associated with a sprite\n   */\n  private removeCollidersForSprite(sprite: any): void {\n    const colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) return;\n\n    for (const collider of colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n      const index = this.colliders.indexOf(collider);\n      if (index !== -1) {\n        this.colliders.splice(index, 1);\n      }\n    }\n\n    this.spriteToColliders.delete(sprite);\n  }\n}\n", "/**\n * PhysicsManager - Automates physics behavior based on inputs\n *\n * Eliminates manual physics loops by automatically reading inputs from state\n * and applying pre-defined or custom physics behaviors.\n *\n * ## Position Syncing (PIT OF SUCCESS!)\n *\n * **NEW:** PhysicsManager now automatically syncs sprite positions BACK to state\n * (enabled by default). This prevents the \"bullets spawn from starting position\" bug\n * where actions reading `state.players[id].x/y` get stale data.\n *\n * **How it works:**\n * 1. PhysicsManager moves sprites via Phaser physics bodies\n * 2. After each physics update, sprite.x/y/rotation \u2192 state.players[id].x/y/rotation\n * 3. Actions can now read current positions from state reliably\n *\n * **When to disable:**\n * - Performance optimization for 100+ entities\n * - You're manually syncing positions elsewhere\n * - Set `syncPositionToState: false` in config\n *\n * ## Velocity Updates (Racing Behavior)\n *\n * PhysicsManager provides velocity data through TWO channels:\n *\n * 1. **Local Events** (`onVelocityChange`) - Host only, no network overhead\n *    - Fast, synchronous updates\n *    - Use for: Host-only displays, debug overlays, analytics\n *    - Example: Dev tools showing real-time physics metrics\n *\n * 2. **State Sync** (`state.players[id].velocity`) - Synced across network\n *    - Automatically written to game state\n *    - Use for: Client HUDs, multiplayer displays\n *    - Example: Speed display visible to all players\n *\n * Helpers like `createSpeedDisplay` use BOTH:\n * - Host: Fast event updates (instant feedback)\n * - Clients: State sync (receives velocity from host)\n *\n * @example\n * ```ts\n * // In scene.create()\n * this.physicsManager = this.adapter.createPhysicsManager({\n *   spriteManager: this.spriteManager,\n *   inputKey: 'inputs',\n *   stateKey: 'players', // optional, defaults to 'players'\n *   syncPositionToState: true // optional, defaults to true (PIT OF SUCCESS!)\n * });\n *\n * this.physicsManager.addBehavior('topDown', {\n *   speed: 200\n * });\n *\n * // Now actions can read current positions from state!\n * // shoot action: bullet.x = state.players[id].x \u2705 (always up to date)\n *\n * // In scene.update()\n * this.physicsManager.update();\n * ```\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PlatformerBehaviorConfig {\n  speed?: number;\n  jumpPower?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    jump?: string;\n  };\n}\n\nexport interface TopDownBehaviorConfig {\n  speed?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    up?: string;\n    down?: string;\n  };\n}\n\nexport interface RacingBehaviorConfig {\n  /** Acceleration rate when accelerating (default: 5) */\n  acceleration?: number;\n  /** Maximum speed (default: 200) */\n  maxSpeed?: number;\n  /** Turn speed in radians per frame (default: 0.05) */\n  turnSpeed?: number;\n  /** Friction/decay multiplier per frame (default: 0.98) */\n  friction?: number;\n  /** Keys for controls */\n  keys?: {\n    left?: string;\n    right?: string;\n    accelerate?: string;\n  };\n}\n\nexport interface CustomBehaviorConfig {\n  apply: (sprite: any, input: any, body: Phaser.Physics.Arcade.Body) => void;\n}\n\nexport type BehaviorConfig = PlatformerBehaviorConfig | TopDownBehaviorConfig | RacingBehaviorConfig | CustomBehaviorConfig;\n\nexport interface PhysicsManagerConfig {\n  /** SpriteManager to get sprites from */\n  spriteManager: SpriteManager;\n\n  /** Key in state to read inputs from (e.g., 'inputs') */\n  inputKey?: string;\n\n  /** Key prefix for sprite keys (defaults to 'player-') */\n  spriteKeyPrefix?: string;\n\n  /**\n   * Automatically sync sprite positions back to state (default: true)\n   *\n   * **PIT OF SUCCESS:** Enabled by default to prevent the \"bullets spawn from\n   * player's starting position\" bug. When PhysicsManager moves sprites via\n   * physics bodies, those positions need to be written back to state so that\n   * actions (like 'shoot') can read the current position.\n   *\n   * Disable only if you have a specific reason (e.g., performance optimization\n   * for 100+ entities, or you're manually syncing positions elsewhere).\n   *\n   * @default true\n   */\n  syncPositionToState?: boolean;\n\n  /**\n   * State key where player/entity data is stored (default: 'players')\n   * Used for syncing positions back to state when syncPositionToState is enabled\n   */\n  stateKey?: string;\n}\n\n/**\n * Simple event emitter for velocity changes\n */\nclass VelocityEmitter {\n  private listeners: Array<(playerId: string, velocity: number) => void> = [];\n\n  on(callback: (playerId: string, velocity: number) => void): () => void {\n    this.listeners.push(callback);\n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  emit(playerId: string, velocity: number): void {\n    for (const listener of this.listeners) {\n      listener(playerId, velocity);\n    }\n  }\n}\n\nexport class PhysicsManager {\n  private runtime: GameRuntime;\n  private spriteManager: SpriteManager;\n  private inputKey: string;\n  private spriteKeyPrefix: string;\n  private syncPositionToState: boolean;\n  private stateKey: string;\n  private behaviorType: 'platformer' | 'topDown' | 'racing' | 'custom' | null = null;\n  private behaviorConfig: BehaviorConfig | null = null;\n  private velocities: Map<string, number> = new Map(); // Track velocity for racing behavior\n  private velocityEmitter = new VelocityEmitter(); // Event emitter for velocity changes\n\n  constructor(runtime: GameRuntime, config: PhysicsManagerConfig) {\n    this.runtime = runtime;\n    this.spriteManager = config.spriteManager;\n    this.inputKey = config.inputKey || 'inputs';\n    this.spriteKeyPrefix = config.spriteKeyPrefix || 'player-';\n    this.syncPositionToState = config.syncPositionToState !== false; // default true\n    this.stateKey = config.stateKey || 'players';\n  }\n\n  /**\n   * Get velocity for a specific player (racing behavior only)\n   * Useful for displaying speed in HUD\n   *\n   * @param playerId - The player ID to get velocity for\n   * @returns Current velocity, or 0 if not found\n   *\n   * @example\n   * ```ts\n   * const speed = physicsManager.getVelocity(adapter.getLocalPlayerId());\n   * ```\n   */\n  getVelocity(playerId: string): number {\n    return this.velocities.get(playerId) || 0;\n  }\n\n  /**\n   * Get readonly access to all velocities (for debugging/UI)\n   * Returns a readonly map of player IDs to their current velocities\n   */\n  getVelocities(): ReadonlyMap<string, number> {\n    return this.velocities;\n  }\n\n  /**\n   * Subscribe to velocity changes (racing behavior only)\n   *\n   * **Important:** This is a LOCAL event that only fires on the HOST.\n   * Events do NOT cross the network boundary.\n   *\n   * Use cases:\n   * - Host-only displays (debug overlays, dev tools)\n   * - Performance-critical updates (no network overhead)\n   * - Analytics/telemetry (host-side tracking)\n   *\n   * For client displays, use `createSpeedDisplay()` helper which automatically\n   * handles both events (host) and state sync (clients).\n   *\n   * Alternatively, read `state.players[playerId].velocity` which is automatically\n   * synced across the network by PhysicsManager.\n   *\n   * @param callback - Called whenever a player's velocity changes (host only)\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Host-only analytics\n   * const unsubscribe = physicsManager.onVelocityChange((playerId, velocity) => {\n   *   if (velocity > 250) {\n   *     trackAchievement('speed_demon', playerId);\n   *   }\n   * });\n   *\n   * // Later, cleanup\n   * unsubscribe();\n   * ```\n   */\n  onVelocityChange(callback: (playerId: string, velocity: number) => void): () => void {\n    return this.velocityEmitter.on(callback);\n  }\n\n  /**\n   * Add a physics behavior\n   *\n   * @param type - Behavior type ('platformer', 'topDown', 'racing', 'custom')\n   * @param config - Behavior configuration\n   */\n  addBehavior(\n    type: 'platformer',\n    config?: PlatformerBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'topDown',\n    config?: TopDownBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'racing',\n    config?: RacingBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'custom',\n    config: CustomBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'platformer' | 'topDown' | 'racing' | 'custom',\n    config?: BehaviorConfig\n  ): void {\n    this.behaviorType = type;\n    this.behaviorConfig = config || {};\n  }\n\n  /**\n   * Update physics for all sprites (call in scene.update())\n   * Only runs on host.\n   */\n  update(): void {\n    // Only host applies physics\n    const transport = this.runtime.getTransport();\n    if (!transport.isHost()) return;\n\n    const state = this.runtime.getState() as any;\n    const inputs = state[this.inputKey];\n    if (!inputs) return;\n\n    // Apply physics to each player based on their input\n    for (const [playerId, playerInput] of Object.entries(inputs)) {\n      const sprite = this.spriteManager.get(`${this.spriteKeyPrefix}${playerId}`);\n      if (!sprite || !sprite.body) continue;\n\n      const body = sprite.body as Phaser.Physics.Arcade.Body;\n\n      if (this.behaviorType === 'platformer') {\n        this.applyPlatformerBehavior(body, playerInput as any, this.behaviorConfig as PlatformerBehaviorConfig);\n      } else if (this.behaviorType === 'topDown') {\n        this.applyTopDownBehavior(body, playerInput as any, this.behaviorConfig as TopDownBehaviorConfig);\n      } else if (this.behaviorType === 'racing') {\n        this.applyRacingBehavior(sprite, body, playerInput as any, playerId, this.behaviorConfig as RacingBehaviorConfig);\n      } else if (this.behaviorType === 'custom' && this.behaviorConfig) {\n        const customConfig = this.behaviorConfig as CustomBehaviorConfig;\n        customConfig.apply(sprite, playerInput, body);\n      }\n\n      // Sync sprite position back to state (PIT OF SUCCESS!)\n      // This ensures actions reading from state (e.g., shoot) get current positions\n      if (this.syncPositionToState) {\n        this.syncPositionToStateForPlayer(playerId, sprite);\n      }\n    }\n  }\n\n  private applyPlatformerBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: PlatformerBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const jumpPower = config.jumpPower || 350;\n    const keys = config.keys || { left: 'left', right: 'right', jump: 'up' };\n\n    // Horizontal movement\n    if (input[keys.left!]) {\n      body.setVelocityX(-speed);\n    } else if (input[keys.right!]) {\n      body.setVelocityX(speed);\n    } else {\n      body.setVelocityX(0);\n    }\n\n    // Jumping (only if on ground)\n    if (input[keys.jump!] && body.touching.down) {\n      body.setVelocityY(-jumpPower);\n    }\n  }\n\n  private applyTopDownBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: TopDownBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const keys = config.keys || { left: 'left', right: 'right', up: 'up', down: 'down' };\n\n    let vx = 0;\n    let vy = 0;\n\n    if (input[keys.left!]) vx = -speed;\n    if (input[keys.right!]) vx = speed;\n    if (input[keys.up!]) vy = -speed;\n    if (input[keys.down!]) vy = speed;\n\n    body.setVelocity(vx, vy);\n  }\n\n  private applyRacingBehavior(\n    sprite: any,\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    playerId: string,\n    config: RacingBehaviorConfig\n  ): void {\n    const acceleration = config.acceleration ?? 5;\n    const maxSpeed = config.maxSpeed ?? 200;\n    const turnSpeed = config.turnSpeed ?? 0.05;\n    const friction = config.friction ?? 0.98;\n    const keys = config.keys || { left: 'left', right: 'right', accelerate: 'up' };\n\n    // Get or initialize velocity for this player\n    const prevVelocity = this.velocities.get(playerId) || 0;\n    let velocity = prevVelocity;\n\n    // Rotation (turning)\n    if (input[keys.left!]) {\n      sprite.rotation -= turnSpeed;\n    }\n    if (input[keys.right!]) {\n      sprite.rotation += turnSpeed;\n    }\n\n    // Acceleration\n    if (input[keys.accelerate!]) {\n      velocity = Math.min(velocity + acceleration, maxSpeed);\n    } else {\n      // Apply friction when not accelerating\n      velocity *= friction;\n      // Snap to zero when very slow (avoid asymptotic decay)\n      if (velocity < 0.5) {\n        velocity = 0;\n      }\n    }\n\n    // Store velocity locally\n    this.velocities.set(playerId, velocity);\n\n    // Sync velocity to state so clients can display it\n    this.runtime.mutateState((state: any) => {\n      if (state.players && state.players[playerId]) {\n        state.players[playerId].velocity = velocity;\n      }\n    });\n\n    // Emit event for local reactive displays (host only)\n    this.velocityEmitter.emit(playerId, velocity);\n\n    // Apply velocity in the direction of rotation\n    const vx = Math.cos(sprite.rotation) * velocity;\n    const vy = Math.sin(sprite.rotation) * velocity;\n    body.setVelocity(vx, vy);\n  }\n\n  /**\n   * Sync sprite position and rotation back to state\n   * Called automatically after physics updates when syncPositionToState is enabled\n   */\n  private syncPositionToStateForPlayer(playerId: string, sprite: any): void {\n    this.runtime.mutateState((state: any) => {\n      const entities = state[this.stateKey];\n      if (entities && entities[playerId]) {\n        // Always sync position (this is what PhysicsManager controls)\n        entities[playerId].x = sprite.x;\n        entities[playerId].y = sprite.y;\n\n        // Only sync rotation for racing behavior, where sprite.rotation is modified by physics\n        // For topDown/platformer, rotation is typically managed by actions/game logic\n        if (this.behaviorType === 'racing' && sprite.rotation !== undefined) {\n          entities[playerId].rotation = sprite.rotation;\n        }\n      }\n    });\n  }\n}\n", "/**\n * StateDrivenSpawner - Automatic sprite spawning from state collections\n *\n * Eliminates the manual \"check for new players/bullets\" loop in every demo.\n * Watches a state collection (e.g., state.players, state.bullets) and automatically\n * creates/removes sprites as the collection changes.\n *\n * **PIT OF SUCCESS: Positions sync from state by default!**\n * Sprites automatically follow state.x/y changes unless you opt-out.\n *\n * **NEW: Automatic physics integration!**\n * Projectiles/moving entities automatically update from velocity - no manual position updates needed!\n *\n * Usage:\n * ```ts\n * // State-driven entities (default - positions sync automatically!)\n * const blobSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'players',\n *   spriteManager: this.spriteManager,\n *   keyPrefix: 'player-'\n *   // syncProperties: ['x', 'y'] is automatic! Just mutate state and sprites follow.\n * });\n *\n * // NEW: Velocity-based movement (projectiles, moving entities)\n * const bulletSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'bullets',\n *   spriteManager: this.bulletManager,\n *   keyField: 'id',\n *   physics: {\n *     velocityFromState: { x: 'velocityX', y: 'velocityY' }\n *   }\n * });\n *\n * // In scene.update():\n * bulletSpawner.update(delta); // Automatically updates positions from velocity!\n *\n * // Physics-driven entities (opt-out of position sync)\n * const paddleSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'players',\n *   spriteManager: this.spriteManager,\n *   keyPrefix: 'player-',\n *   syncProperties: [] // Empty = physics body controls position, not state\n * });\n *\n * // Custom properties (override default)\n * const bulletSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'bullets',\n *   spriteManager: this.bulletManager,\n *   syncProperties: ['x', 'y', 'rotation', 'alpha'] // Sync more than just position\n * });\n * ```\n *\n * This automatically:\n * - Creates sprites when new entries appear in state\n * - **Syncs x,y from state to sprites by default (opt-out with syncProperties: [])**\n * - **NEW: Updates positions from velocity automatically (opt-in with physics config)**\n * - Removes sprites when entries are deleted\n * - Works on both HOST (initial + late joins) and CLIENT (state sync)\n * - Handles arrays (bullets) and objects (players)\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PhysicsConfig {\n  /**\n   * Automatically update position from velocity in state\n   *\n   * @example\n   * ```ts\n   * velocityFromState: { x: 'velocityX', y: 'velocityY' }\n   * ```\n   *\n   * This will automatically apply:\n   * ```ts\n   * data.x += data.velocityX * deltaSeconds;\n   * data.y += data.velocityY * deltaSeconds;\n   * ```\n   */\n  velocityFromState?: { x: string; y: string };\n\n  /**\n   * Future: Acceleration support\n   * acceleration?: { x: string; y: string };\n   * friction?: number;\n   */\n}\n\nexport interface StateDrivenSpawnerConfig {\n  /**\n   * Path to the collection in state (e.g., 'players', 'bullets', 'powerUps')\n   */\n  stateKey: string;\n\n  /**\n   * The SpriteManager to spawn sprites into\n   */\n  spriteManager: SpriteManager;\n\n  /**\n   * Optional prefix for sprite keys (e.g., 'player-' \u2192 'player-abc123')\n   */\n  keyPrefix?: string;\n\n  /**\n   * For array collections, which field to use as the unique key\n   * (e.g., 'id' for bullets)\n   * If not provided, assumes state collection is an object and uses its keys\n   */\n  keyField?: string;\n\n  /**\n   * Optional filter function - only spawn if this returns true\n   * @example\n   * ```ts\n   * filter: (data) => data.isAlive // Only spawn living entities\n   * ```\n   */\n  filter?: (data: any) => boolean;\n\n  /**\n   * **Unified Sync Configuration**\n   *\n   * Controls automatic property synchronization from state to sprites.\n   * **DEFAULT: Syncs ['x', 'y'] from state to sprites** (PIT OF SUCCESS!)\n   *\n   * @example\n   * ```ts\n   * // Default: State \u2192 Sprite position sync (automatic!)\n   * // sync: { properties: ['x', 'y'], direction: 'toSprite' }\n   *\n   * // Physics-driven: No sync (physics body controls position)\n   * sync: { properties: [] }\n   *\n   * // Custom properties\n   * sync: { properties: ['x', 'y', 'rotation', 'alpha'] }\n   * ```\n   */\n  sync?: {\n    /**\n     * Properties to sync (default: ['x', 'y'])\n     */\n    properties?: string[];\n\n    /**\n     * Sync direction (always 'toSprite' for StateDrivenSpawner)\n     */\n    direction?: 'toSprite';\n  };\n\n\n  /**\n   * Custom update function for more complex sprite syncing\n   * If provided, this takes precedence over syncProperties\n   *\n   * @example\n   * ```ts\n   * onUpdateSprite: (sprite, data) => {\n   *   sprite.x = data.x;\n   *   sprite.y = data.y;\n   *   sprite.setAlpha(data.health / 100);\n   * }\n   * ```\n   */\n  onUpdateSprite?: (sprite: any, data: any) => void;\n\n  /**\n   * **NEW: Automatic physics integration**\n   *\n   * Automatically update entity positions from velocity in state.\n   * Eliminates manual `entity.x += entity.velocityX * deltaSeconds` boilerplate.\n   *\n   * **Benefits:**\n   * - 80% less code for projectiles/moving entities\n   * - \"Pit of success\" - velocity-based movement just works\n   * - Consistent with PhysicsManager mental model\n   *\n   * @example\n   * ```ts\n   * // Simple projectiles\n   * const bulletSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'bullets',\n   *   spriteManager: bulletManager,\n   *   keyField: 'id',\n   *   physics: {\n   *     velocityFromState: { x: 'velocityX', y: 'velocityY' }\n   *   }\n   * });\n   *\n   * // In update loop:\n   * bulletSpawner.updatePhysics(delta); // Automatically updates positions!\n   * ```\n   */\n  physics?: PhysicsConfig;\n}\n\nexport class StateDrivenSpawner {\n  private config: StateDrivenSpawnerConfig;\n  private adapter: PhaserAdapter;\n  private trackedKeys = new Set<string>();\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: StateDrivenSpawnerConfig) {\n    this.adapter = adapter;\n\n    // PIT OF SUCCESS: Default to syncing positions from state\n    if (!config.sync?.properties && !config.onUpdateSprite) {\n      // Default: sync x,y from state to sprites\n      config.sync = { properties: ['x', 'y'], direction: 'toSprite' };\n    }\n\n    this.config = config;\n\n    // HOST: Poll state every update to spawn new entries\n    // CLIENT: React to state changes via onChange\n    if (adapter.isHost()) {\n      // Host checks state directly (no onChange subscription needed)\n      // Just need to call update() from scene\n    } else {\n      // Client subscribes to state changes\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Call this in scene.update() (HOST ONLY)\n   * Checks for new entries in the state collection and spawns sprites\n   *\n   * @param delta - Optional delta time in milliseconds for physics updates\n   *\n   * @example\n   * ```ts\n   * update(time: number, delta: number) {\n   *   // Without physics: just sync spawning/despawning\n   *   spawner.update();\n   *\n   *   // With physics: update positions from velocity\n   *   spawner.update(delta);\n   * }\n   * ```\n   */\n  update(delta?: number): void {\n    if (!this.adapter.isHost()) {\n      return; // Client uses onChange subscription instead\n    }\n\n    // Update physics before syncing (so new positions are synced)\n    if (delta !== undefined && this.config.physics) {\n      this.updatePhysics(delta);\n    }\n\n    const state = this.adapter.getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * **NEW: Automatic physics updates**\n   *\n   * Updates entity positions from velocity in state.\n   * Call this in your scene.update() with delta time.\n   *\n   * **Only runs on HOST** - clients receive position updates via state sync.\n   *\n   * @param delta - Delta time in milliseconds\n   *\n   * @example\n   * ```ts\n   * update(time: number, delta: number) {\n   *   bulletSpawner.updatePhysics(delta);\n   *   bulletSpawner.update(); // Sync sprites to new positions\n   * }\n   * ```\n   */\n  updatePhysics(delta: number): void {\n    if (!this.adapter.isHost()) {\n      return; // Only host updates physics - clients get state sync\n    }\n\n    if (!this.config.physics?.velocityFromState) {\n      return; // No physics config\n    }\n\n    const state = this.adapter.getState();\n    const collection = state[this.config.stateKey];\n    if (!collection) return;\n\n    const deltaSeconds = delta / 1000;\n    const { x: velXKey, y: velYKey } = this.config.physics.velocityFromState;\n\n    // Determine if collection is array or object\n    const isArray = Array.isArray(collection);\n\n    // Extract entries\n    const entries: Array<[string, any]> = isArray\n      ? collection.map((item: any) => {\n          const key = this.config.keyField ? item[this.config.keyField] : item.id;\n          return [String(key), item];\n        })\n      : Object.entries(collection);\n\n    // Update positions from velocity\n    for (const [_, data] of entries) {\n      // Apply filter if provided\n      if (this.config.filter && !this.config.filter(data)) {\n        continue;\n      }\n\n      // Check if velocity properties exist in state\n      if (velXKey in data && velYKey in data) {\n        // Update position from velocity\n        // Initialize position if missing\n        if (!('x' in data)) data.x = 0;\n        if (!('y' in data)) data.y = 0;\n\n        data.x += data[velXKey] * deltaSeconds;\n        data.y += data[velYKey] * deltaSeconds;\n      }\n    }\n  }\n\n  /**\n   * Manually trigger a sync (useful for initial spawn in create())\n   */\n  sync(): void {\n    const state = this.adapter.getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Core sync logic - creates/removes sprites based on state\n   */\n  private syncFromState(state: any): void {\n    const collection = state[this.config.stateKey];\n    if (!collection) return;\n\n    const currentKeys = new Set<string>();\n\n    // Determine if collection is array or object\n    const isArray = Array.isArray(collection);\n\n    // Extract entries\n    const entries: Array<[string, any]> = isArray\n      ? collection.map((item: any) => {\n          const key = this.config.keyField ? item[this.config.keyField] : item.id;\n          return [String(key), item];\n        })\n      : Object.entries(collection);\n\n    // Create/update sprites for entries\n    for (const [rawKey, data] of entries) {\n      // Apply filter if provided\n      if (this.config.filter && !this.config.filter(data)) {\n        continue;\n      }\n\n      const spriteKey = this.config.keyPrefix ? `${this.config.keyPrefix}${rawKey}` : rawKey;\n      currentKeys.add(spriteKey);\n\n      // If sprite already exists, update its properties\n      if (this.trackedKeys.has(spriteKey)) {\n        this.updateSpriteFromState(spriteKey, data);\n        continue;\n      }\n\n      // Create sprite (only on HOST - SpriteManager handles client sync)\n      if (this.adapter.isHost()) {\n        this.config.spriteManager.add(spriteKey, data);\n        this.trackedKeys.add(spriteKey);\n      } else {\n        // On client, just track that we've seen it (SpriteManager creates it via state sync)\n        this.trackedKeys.add(spriteKey);\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const spriteKey of this.trackedKeys) {\n      if (!currentKeys.has(spriteKey)) {\n        this.config.spriteManager.remove(spriteKey);\n        this.trackedKeys.delete(spriteKey);\n      }\n    }\n  }\n\n  /**\n   * Update sprite properties from state data\n   * Only runs on HOST (clients get updates via SpriteManager sync)\n   */\n  private updateSpriteFromState(spriteKey: string, data: any): void {\n    // Only update on host - clients rely on SpriteManager's automatic sync\n    if (!this.adapter.isHost()) {\n      return;\n    }\n\n    const sprite = this.config.spriteManager.get(spriteKey);\n    if (!sprite) return;\n\n    // Custom update function takes precedence\n    if (this.config.onUpdateSprite) {\n      this.config.onUpdateSprite(sprite, data);\n      return;\n    }\n\n    // Sync properties using unified API\n    const syncProperties = this.config.sync?.properties;\n    if (syncProperties) {\n      for (const prop of syncProperties) {\n        if (prop in data && sprite[prop] !== undefined) {\n          sprite[prop] = data[prop];\n        }\n      }\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    this.unsubscribe?.();\n  }\n}\n", "/**\n * HealthBarManager - Auto-synced health bars for sprites\n *\n * Eliminates manual health bar creation, positioning, scaling, and color updates.\n * One-liner attachment like directional indicators, auto-updates from state.\n *\n * Usage:\n * ```ts\n * const healthBars = adapter.createHealthBarManager({\n *   spriteManager: this.spriteManager,\n *   healthKey: 'health',\n *   maxHealth: 100,\n *   offset: { x: 0, y: -30 },\n *   width: 50,\n *   height: 5\n * });\n *\n * // That's it! Health bars auto-create, auto-position, auto-scale, auto-color!\n * // Just call in update():\n * healthBars.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\nimport type Phaser from 'phaser';\n\nexport interface HealthBarConfig {\n  /**\n   * SpriteManager to attach health bars to\n   */\n  spriteManager: SpriteManager;\n\n  /**\n   * Path to health value in state (e.g., 'health', 'hp', 'lives')\n   */\n  healthKey: string;\n\n  /**\n   * Maximum health value for scaling\n   */\n  maxHealth: number;\n\n  /**\n   * Offset from sprite center\n   */\n  offset?: { x?: number; y?: number };\n\n  /**\n   * Health bar dimensions\n   */\n  width?: number;\n  height?: number;\n\n  /**\n   * Color thresholds for health bar\n   * Default: green > 50%, yellow > 25%, red <= 25%\n   */\n  colorThresholds?: {\n    high?: { value: number; color: number };\n    medium?: { value: number; color: number };\n    low?: { value: number; color: number };\n  };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Show background bar (darker shade)\n   */\n  showBackground?: boolean;\n\n  /**\n   * Background bar color\n   */\n  backgroundColor?: number;\n}\n\nexport class HealthBarManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: HealthBarConfig;\n  private healthBars = new Map<string, {\n    bar: Phaser.GameObjects.Rectangle;\n    background?: Phaser.GameObjects.Rectangle;\n  }>();\n\n  constructor(adapter: PhaserAdapter, config: HealthBarConfig) {\n    this.adapter = adapter;\n    this.scene = adapter.getScene();\n    this.config = {\n      offset: { x: 0, y: -30 },\n      width: 50,\n      height: 5,\n      colorThresholds: {\n        high: { value: 50, color: 0x48bb78 },   // Green\n        medium: { value: 25, color: 0xeab308 }, // Yellow\n        low: { value: 0, color: 0xef4444 }      // Red\n      },\n      depth: 100,\n      showBackground: true,\n      backgroundColor: 0x333333,\n      ...config\n    };\n\n    // Listen for sprite additions via SpriteManager\n    // We'll create health bars in update() when we detect new sprites\n  }\n\n  /**\n   * Update all health bars\n   * Call this in your scene's update() loop\n   */\n  update(): void {\n    const state = this.adapter.getState();\n    const sprites = this.config.spriteManager.getAll();\n\n    // Create health bars for new sprites\n    for (const [key, sprite] of sprites) {\n      if (!this.healthBars.has(key)) {\n        this.createHealthBar(key, sprite);\n      }\n    }\n\n    // Update existing health bars\n    for (const [key, healthBarObj] of this.healthBars.entries()) {\n      const sprite = sprites.get(key);\n      if (!sprite) {\n        // Sprite removed, cleanup\n        this.removeHealthBar(key);\n        continue;\n      }\n\n      // Extract player/entity ID from sprite key\n      const entityId = this.extractEntityId(key);\n      const entityState = this.getEntityState(state, entityId);\n\n      if (!entityState) {\n        continue;\n      }\n\n      // Get health value\n      const health = entityState[this.config.healthKey];\n      if (health === undefined) {\n        continue;\n      }\n\n      // Update position\n      const offsetX = this.config.offset?.x ?? 0;\n      const offsetY = this.config.offset?.y ?? -30;\n      healthBarObj.bar.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n\n      if (healthBarObj.background) {\n        healthBarObj.background.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n      }\n\n      // Update scale\n      const healthPercent = health / this.config.maxHealth;\n      healthBarObj.bar.setScale(Math.max(0, healthPercent), 1);\n\n      // Update color based on health\n      const color = this.getColorForHealth(healthPercent * 100);\n      healthBarObj.bar.setFillStyle(color);\n    }\n  }\n\n  /**\n   * Manually create a health bar for a sprite\n   */\n  private createHealthBar(key: string, sprite: any): void {\n    const width = this.config.width ?? 50;\n    const height = this.config.height ?? 5;\n    const offsetX = this.config.offset?.x ?? 0;\n    const offsetY = this.config.offset?.y ?? -30;\n\n    // Create background bar (if enabled)\n    let background: Phaser.GameObjects.Rectangle | undefined;\n    if (this.config.showBackground) {\n      background = this.scene.add.rectangle(\n        sprite.x + offsetX,\n        sprite.y + offsetY,\n        width,\n        height,\n        this.config.backgroundColor\n      );\n      background?.setDepth(this.config.depth ?? 100);\n    }\n\n    // Create foreground bar\n    const bar = this.scene.add.rectangle(\n      sprite.x + offsetX,\n      sprite.y + offsetY,\n      width,\n      height,\n      this.config.colorThresholds?.high?.color ?? 0x48bb78\n    );\n    bar.setDepth((this.config.depth ?? 100) + 1);\n    bar.setOrigin(0, 0.5); // Left-aligned for scale effect\n\n    // Adjust background origin to match\n    background?.setOrigin(0, 0.5);\n\n    this.healthBars.set(key, { bar, background });\n  }\n\n  /**\n   * Remove a health bar\n   */\n  private removeHealthBar(key: string): void {\n    const healthBarObj = this.healthBars.get(key);\n    if (healthBarObj) {\n      healthBarObj.bar.destroy();\n      healthBarObj.background?.destroy();\n      this.healthBars.delete(key);\n    }\n  }\n\n  /**\n   * Extract entity ID from sprite key\n   * Assumes format like \"player-abc123\" or \"enemy-xyz789\"\n   */\n  private extractEntityId(key: string): string {\n    const parts = key.split('-');\n    return parts.length > 1 ? parts.slice(1).join('-') : key;\n  }\n\n  /**\n   * Get entity state from game state\n   * Tries common state keys: players, enemies, entities\n   */\n  private getEntityState(state: any, entityId: string): any {\n    if (state.players?.[entityId]) {\n      return state.players[entityId];\n    }\n    if (state.enemies?.[entityId]) {\n      return state.enemies[entityId];\n    }\n    if (state.entities?.[entityId]) {\n      return state.entities[entityId];\n    }\n    return null;\n  }\n\n  /**\n   * Get color based on health percentage\n   */\n  private getColorForHealth(healthPercent: number): number {\n    const thresholds = this.config.colorThresholds!;\n\n    if (healthPercent > (thresholds.high?.value ?? 50)) {\n      return thresholds.high?.color ?? 0x48bb78;\n    } else if (healthPercent > (thresholds.medium?.value ?? 25)) {\n      return thresholds.medium?.color ?? 0xeab308;\n    } else {\n      return thresholds.low?.color ?? 0xef4444;\n    }\n  }\n\n  /**\n   * Cleanup all health bars\n   */\n  destroy(): void {\n    for (const key of this.healthBars.keys()) {\n      this.removeHealthBar(key);\n    }\n  }\n}\n", "/**\n * GridClickHelper - Robust grid/board click handling\n *\n * Solves the common problem of grid-based games where interactive rectangles\n * don't scale properly with the canvas. Uses pointer.worldX/worldY for\n * accurate coordinate-to-grid mapping that works in any scale mode.\n *\n * Perfect for: Connect Four, Chess, Tic-Tac-Toe, Minesweeper, Battleship,\n * Checkers, Go, Reversi, Sudoku, Bejeweled, etc.\n *\n * Usage:\n * ```ts\n * const gridHelper = adapter.createClickableGrid({\n *   columns: 7,\n *   rows: 6,\n *   cellWidth: 80,\n *   cellHeight: 80,\n *   offsetX: 100,\n *   offsetY: 100,\n *   onCellClick: (col, row) => {\n *     runtime.submitAction('dropToken', { col });\n *   },\n *   highlightColor: 0xffffff,\n *   highlightAlpha: 0.15\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface GridClickConfig {\n  /** Number of columns in the grid */\n  columns: number;\n\n  /** Number of rows in the grid */\n  rows: number;\n\n  /** Width of each cell in pixels */\n  cellWidth: number;\n\n  /** Height of each cell in pixels */\n  cellHeight: number;\n\n  /** X offset of the grid's top-left corner (in world coordinates) */\n  offsetX: number;\n\n  /** Y offset of the grid's top-left corner (in world coordinates) */\n  offsetY: number;\n\n  /** Callback when a cell is clicked - receives (col, row) */\n  onCellClick: (col: number, row: number) => void;\n\n  /**\n   * Optional: Validate if a cell can be clicked\n   * Return true to allow click, false to block\n   */\n  canClick?: (col: number, row: number) => boolean;\n\n  /**\n   * Optional: Validate if a cell can be highlighted on hover\n   * Return true to show highlight, false to hide\n   */\n  canHighlight?: (col: number, row: number) => boolean;\n\n  /** Optional: Highlight color (default: 0xffffff) */\n  highlightColor?: number;\n\n  /** Optional: Highlight alpha (default: 0.15) */\n  highlightAlpha?: number;\n\n  /** Optional: Show cursor pointer on hover (default: true) */\n  useHandCursor?: boolean;\n\n  /**\n   * Optional: Grid layout mode\n   * - 'top-left': (0,0) is top-left corner (default for most grids)\n   * - 'bottom-left': (0,0) is bottom-left corner (for Connect Four, platformers)\n   */\n  origin?: 'top-left' | 'bottom-left';\n\n  /**\n   * Optional: Cell click mode\n   * - 'down': Fire on pointerdown (default, feels responsive)\n   * - 'up': Fire on pointerup (better for drag operations)\n   */\n  clickMode?: 'down' | 'up';\n\n  /**\n   * Optional: Enable debug visualization\n   * Shows grid lines and cell coordinates\n   */\n  debug?: boolean;\n}\n\nexport class GridClickHelper {\n  private config: Required<GridClickConfig>;\n  private scene: Phaser.Scene;\n  private highlights: Phaser.GameObjects.Rectangle[] = [];\n  private debugGraphics?: Phaser.GameObjects.Graphics;\n  private debugTexts: Phaser.GameObjects.Text[] = [];\n\n  constructor(adapter: PhaserAdapter, scene: Phaser.Scene, config: GridClickConfig) {\n    this.scene = scene;\n\n    // Fill in defaults\n    this.config = {\n      ...config,\n      canClick: config.canClick ?? (() => true),\n      canHighlight: config.canHighlight ?? (() => true),\n      highlightColor: config.highlightColor ?? 0xffffff,\n      highlightAlpha: config.highlightAlpha ?? 0.15,\n      useHandCursor: config.useHandCursor ?? true,\n      origin: config.origin ?? 'top-left',\n      clickMode: config.clickMode ?? 'down',\n      debug: config.debug ?? false\n    };\n\n    this.setupHighlights();\n    this.setupInputHandlers();\n\n    if (this.config.debug) {\n      this.setupDebugVisualization();\n    }\n  }\n\n  /**\n   * Create highlight rectangles for visual feedback\n   */\n  private setupHighlights(): void {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, highlightColor, origin } = this.config;\n\n    for (let col = 0; col < columns; col++) {\n      for (let row = 0; row < rows; row++) {\n        const x = offsetX + col * cellWidth + cellWidth / 2;\n\n        // Handle different origin modes\n        const y = origin === 'bottom-left'\n          ? offsetY + (rows - 1 - row) * cellHeight + cellHeight / 2\n          : offsetY + row * cellHeight + cellHeight / 2;\n\n        const highlight = this.scene.add.rectangle(\n          x,\n          y,\n          cellWidth,\n          cellHeight,\n          highlightColor,\n          0 // Start invisible\n        );\n\n        // Store index for easy lookup\n        (highlight as any).gridCol = col;\n        (highlight as any).gridRow = row;\n\n        this.highlights.push(highlight);\n      }\n    }\n  }\n\n  /**\n   * Setup pointer event handlers using worldX/worldY for accurate mapping\n   */\n  private setupInputHandlers(): void {\n    const { useHandCursor, clickMode } = this.config;\n\n    // Handle pointer move for hover highlights\n    this.scene.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {\n      const cell = this.pointerToCell(pointer);\n\n      // Hide all highlights\n      this.highlights.forEach(h => h.setAlpha(0));\n\n      // Show highlight for hovered cell if valid\n      if (cell && this.config.canHighlight(cell.col, cell.row)) {\n        const highlight = this.getHighlight(cell.col, cell.row);\n        if (highlight) {\n          highlight.setAlpha(this.config.highlightAlpha);\n        }\n      }\n\n      // Update cursor\n      if (useHandCursor) {\n        const canClick = cell && this.config.canClick(cell.col, cell.row);\n        this.scene.input.setDefaultCursor(canClick ? 'pointer' : 'default');\n      }\n    });\n\n    // Handle clicks\n    const eventName = clickMode === 'down' ? 'pointerdown' : 'pointerup';\n    this.scene.input.on(eventName, (pointer: Phaser.Input.Pointer) => {\n      const cell = this.pointerToCell(pointer);\n\n      if (cell && this.config.canClick(cell.col, cell.row)) {\n        this.config.onCellClick(cell.col, cell.row);\n\n        // Flash the highlight for feedback\n        const highlight = this.getHighlight(cell.col, cell.row);\n        if (highlight) {\n          this.scene.tweens.add({\n            targets: highlight,\n            alpha: this.config.highlightAlpha * 2,\n            duration: 100,\n            yoyo: true\n          });\n        }\n      }\n    });\n\n    // Reset cursor when pointer leaves\n    this.scene.input.on('pointerout', () => {\n      this.highlights.forEach(h => h.setAlpha(0));\n      if (useHandCursor) {\n        this.scene.input.setDefaultCursor('default');\n      }\n    });\n  }\n\n  /**\n   * Convert pointer coordinates to grid cell\n   * Uses worldX/worldY for accurate mapping in any scale mode\n   */\n  private pointerToCell(pointer: Phaser.Input.Pointer): { col: number; row: number } | null {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, origin } = this.config;\n\n    // Use worldX/worldY to account for camera transforms and scaling\n    const col = Math.floor((pointer.worldX - offsetX) / cellWidth);\n    const rowFromTop = Math.floor((pointer.worldY - offsetY) / cellHeight);\n\n    // Convert to grid coordinates based on origin\n    const row = origin === 'bottom-left' ? rows - 1 - rowFromTop : rowFromTop;\n\n    // Validate bounds\n    if (col < 0 || col >= columns || row < 0 || row >= rows) {\n      return null;\n    }\n\n    return { col, row };\n  }\n\n  /**\n   * Get highlight rectangle for a specific cell\n   */\n  private getHighlight(col: number, row: number): Phaser.GameObjects.Rectangle | undefined {\n    return this.highlights.find(h => (h as any).gridCol === col && (h as any).gridRow === row);\n  }\n\n  /**\n   * Setup debug visualization (grid lines and coordinates)\n   */\n  private setupDebugVisualization(): void {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, origin } = this.config;\n\n    // Draw grid lines\n    this.debugGraphics = this.scene.add.graphics();\n    this.debugGraphics.lineStyle(1, 0xff00ff, 0.5);\n\n    // Vertical lines\n    for (let col = 0; col <= columns; col++) {\n      const x = offsetX + col * cellWidth;\n      this.debugGraphics.lineBetween(x, offsetY, x, offsetY + rows * cellHeight);\n    }\n\n    // Horizontal lines\n    for (let row = 0; row <= rows; row++) {\n      const y = offsetY + row * cellHeight;\n      this.debugGraphics.lineBetween(offsetX, y, offsetX + columns * cellWidth, y);\n    }\n\n    // Draw cell coordinates\n    for (let col = 0; col < columns; col++) {\n      for (let row = 0; row < rows; row++) {\n        const x = offsetX + col * cellWidth + 5;\n\n        // Handle different origin modes\n        const y = origin === 'bottom-left'\n          ? offsetY + (rows - 1 - row) * cellHeight + 5\n          : offsetY + row * cellHeight + 5;\n\n        const text = this.scene.add.text(x, y, `${col},${row}`, {\n          fontSize: '10px',\n          color: '#ff00ff',\n          backgroundColor: '#000000'\n        });\n        this.debugTexts.push(text);\n      }\n    }\n  }\n\n  /**\n   * Manually trigger a highlight (useful for showing valid moves, etc.)\n   */\n  showHighlight(col: number, row: number, alpha?: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setAlpha(alpha ?? this.config.highlightAlpha);\n    }\n  }\n\n  /**\n   * Hide a specific cell's highlight\n   */\n  hideHighlight(col: number, row: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setAlpha(0);\n    }\n  }\n\n  /**\n   * Hide all highlights\n   */\n  hideAllHighlights(): void {\n    this.highlights.forEach(h => h.setAlpha(0));\n  }\n\n  /**\n   * Update highlight color for a specific cell\n   */\n  setHighlightColor(col: number, row: number, color: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setFillStyle(color);\n    }\n  }\n\n  /**\n   * Destroy the helper and clean up resources\n   */\n  destroy(): void {\n    this.highlights.forEach(h => h.destroy());\n    this.debugGraphics?.destroy();\n    this.debugTexts.forEach(t => t.destroy());\n    this.highlights = [];\n    this.debugTexts = [];\n\n    // Remove input listeners\n    this.scene.input.off('pointermove');\n    this.scene.input.off('pointerdown');\n    this.scene.input.off('pointerup');\n    this.scene.input.off('pointerout');\n  }\n}\n\n/**\n * Factory function for creating a GridClickHelper\n * Called from PhaserAdapter.createClickableGrid()\n */\nexport function createClickableGrid(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: GridClickConfig\n): GridClickHelper {\n  return new GridClickHelper(adapter, scene, config);\n}\n", "/**\n * GridCollisionManager - Grid-based collision detection for smooth movement\n *\n * \u26A0\uFE0F NOTE: This does NOT lock entities to grid cells like classic Bomberman.\n * It provides smooth pixel movement with grid-aligned collision checks.\n *\n * For true grid-locked movement (cell-to-cell committed movement), use\n * GridLockedMovementManager instead.\n *\n * Features:\n * - Smooth pixel-by-pixel movement\n * - Grid-aligned collision detection\n * - Supports diagonal movement with normalization\n * - Optional debug visualization\n *\n * \u26A0\uFE0F COMMON MISTAKES:\n * \u274C Only checking blocks \u2192 Also check bombs, enemies, hazards\n * \u274C Creating in tick action \u2192 Create in scene.create() instead\n * \u274C Expecting grid-locking \u2192 Use GridLockedMovementManager for that\n *\n * \u2705 CORRECT USAGE:\n * ```ts\n * // scene.create()\n * this.gridCollision = this.adapter.createGridCollisionManager({\n *   tileSize: 52,\n *   gridWidth: 13,\n *   gridHeight: 13,\n *   collisionCheck: createMultiCollisionCheck(\n *     { name: 'blocks', fn: (x, y) => hasBlock(state.blocks, x, y) },\n *     { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n *   ),\n *   debug: false // Enable to see grid overlay\n * });\n *\n * // game.ts tick action\n * tick: createTickAction((state, delta) => {\n *   forEachPlayerInput(state, (player, input) => {\n *     this.gridCollision.moveEntity(player, input, delta);\n *   });\n * })\n * ```\n *\n * @see GridLockedMovementManager for Bomberman-style grid locking\n * @see createMultiCollisionCheck for combining multiple collision types\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface GridCollisionConfig {\n  /**\n   * Size of each grid cell in pixels\n   */\n  tileSize: number;\n\n  /**\n   * Width of the grid in cells\n   */\n  gridWidth: number;\n\n  /**\n   * Height of the grid in cells\n   */\n  gridHeight: number;\n\n  /**\n   * Collision check function\n   * Returns true if there's a blocking obstacle at (gridX, gridY)\n   * \n   * \u26A0\uFE0F Remember to check ALL obstacle types: blocks, bombs, enemies, etc.\n   * Consider using createMultiCollisionCheck() helper.\n   */\n  collisionCheck: (gridX: number, gridY: number) => boolean;\n\n  /**\n   * Base movement speed in pixels per second (default: 150)\n   */\n  baseSpeed?: number;\n\n  /**\n   * Normalize diagonal movement (default: true)\n   * When true, diagonal movement is same speed as cardinal\n   */\n  normalizeDiagonal?: boolean;\n\n  /**\n   * Enable debug visualization (default: false)\n   * Shows grid lines, collision cells, entity positions\n   */\n  debug?: boolean;\n\n  /**\n   * Debug color (default: 0xff0000 red)\n   */\n  debugColor?: number;\n}\n\nexport interface GridEntity {\n  x: number;\n  y: number;\n  speed?: number; // Speed multiplier (default: 1.0)\n  [key: string]: any;\n}\n\nexport interface MovementInput {\n  up?: boolean;\n  down?: boolean;\n  left?: boolean;\n  right?: boolean;\n  [key: string]: any;\n}\n\nexport interface GridPosition {\n  gridX: number;\n  gridY: number;\n  isAligned: boolean;\n}\n\nexport class GridCollisionManager {\n  private config: Required<GridCollisionConfig>;\n  private debugGraphics?: any; // Phaser.GameObjects.Graphics\n  private adapter: PhaserAdapter;\n\n  constructor(adapter: PhaserAdapter, config: GridCollisionConfig) {\n    this.adapter = adapter;\n    this.config = {\n      baseSpeed: 150,\n      normalizeDiagonal: true,\n      debug: false,\n      debugColor: 0xff0000,\n      ...config\n    };\n\n    // Setup debug visualization\n    if (this.config.debug) {\n      this.debugGraphics = adapter.getScene().add.graphics();\n      this.renderDebugGrid();\n    }\n  }\n\n  /**\n   * Move an entity based on input\n   * Handles collision detection and smooth movement\n   *\n   * @param entity - Entity with x, y, and optional speed multiplier\n   * @param input - Input with up/down/left/right flags\n   * @param delta - Time delta in milliseconds\n   */\n  moveEntity(entity: GridEntity, input: MovementInput, delta: number): void {\n    const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);\n    const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);\n\n    if (dx === 0 && dy === 0) return;\n\n    // Calculate speed\n    const speedMultiplier = entity.speed ?? 1.0;\n    let speed = this.config.baseSpeed * speedMultiplier * (delta / 1000);\n\n    // Normalize diagonal movement\n    if (this.config.normalizeDiagonal && dx !== 0 && dy !== 0) {\n      const length = Math.sqrt(dx * dx + dy * dy);\n      speed /= length;\n    }\n\n    // Calculate next position\n    const nextX = entity.x + dx * speed;\n    const nextY = entity.y + dy * speed;\n\n    // Check collision at next position\n    const gridPos = this.worldToGrid(nextX, nextY);\n    const hasCollision = this.config.collisionCheck(gridPos.gridX, gridPos.gridY);\n\n    // Check bounds\n    const worldSize = {\n      width: this.config.gridWidth * this.config.tileSize,\n      height: this.config.gridHeight * this.config.tileSize\n    };\n    const outOfBounds =\n      nextX < 0 ||\n      nextX >= worldSize.width ||\n      nextY < 0 ||\n      nextY >= worldSize.height;\n\n    // Update position if valid\n    if (!hasCollision && !outOfBounds) {\n      entity.x = nextX;\n      entity.y = nextY;\n    }\n\n    // Update debug visualization\n    if (this.config.debug && this.debugGraphics) {\n      this.updateDebugVisualization(entity, hasCollision ? gridPos : null);\n    }\n  }\n\n  /**\n   * Convert world position to grid coordinates\n   *\n   * @param x - World X position in pixels\n   * @param y - World Y position in pixels\n   * @returns Grid coordinates and alignment status\n   */\n  worldToGrid(x: number, y: number): GridPosition {\n    const gridX = Math.floor(x / this.config.tileSize);\n    const gridY = Math.floor(y / this.config.tileSize);\n\n    // Check if position is aligned to grid (within threshold)\n    const threshold = this.config.tileSize * 0.1;\n    const offsetX = Math.abs(x - (gridX * this.config.tileSize + this.config.tileSize / 2));\n    const offsetY = Math.abs(y - (gridY * this.config.tileSize + this.config.tileSize / 2));\n    const isAligned = offsetX < threshold && offsetY < threshold;\n\n    return { gridX, gridY, isAligned };\n  }\n\n  /**\n   * Convert grid coordinates to world position (center of cell)\n   *\n   * @param gridX - Grid X coordinate\n   * @param gridY - Grid Y coordinate\n   * @returns World position in pixels (center of cell)\n   */\n  gridToWorld(gridX: number, gridY: number): { x: number; y: number } {\n    return {\n      x: gridX * this.config.tileSize + this.config.tileSize / 2,\n      y: gridY * this.config.tileSize + this.config.tileSize / 2\n    };\n  }\n\n  /**\n   * Snap an entity to the nearest grid cell center\n   *\n   * @param entity - Entity to snap\n   */\n  snapToGrid(entity: GridEntity): void {\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    const worldPos = this.gridToWorld(gridPos.gridX, gridPos.gridY);\n    entity.x = worldPos.x;\n    entity.y = worldPos.y;\n  }\n\n  /**\n   * Check if a grid cell is walkable (not blocked)\n   *\n   * @param gridX - Grid X coordinate\n   * @param gridY - Grid Y coordinate\n   * @returns True if cell is walkable\n   */\n  isWalkable(gridX: number, gridY: number): boolean {\n    // Check bounds\n    if (gridX < 0 || gridX >= this.config.gridWidth) return false;\n    if (gridY < 0 || gridY >= this.config.gridHeight) return false;\n\n    // Check collision\n    return !this.config.collisionCheck(gridX, gridY);\n  }\n\n  /**\n   * Get the current grid cell of an entity\n   *\n   * @param entity - Entity with x, y position\n   * @returns Grid position with alignment status\n   */\n  getEntityGridPosition(entity: GridEntity): GridPosition {\n    return this.worldToGrid(entity.x, entity.y);\n  }\n\n  /**\n   * Render debug grid overlay\n   */\n  private renderDebugGrid(): void {\n    if (!this.debugGraphics) return;\n\n    this.debugGraphics.clear();\n    this.debugGraphics.lineStyle(1, this.config.debugColor, 0.2);\n\n    // Draw grid lines\n    const worldWidth = this.config.gridWidth * this.config.tileSize;\n    const worldHeight = this.config.gridHeight * this.config.tileSize;\n\n    for (let i = 0; i <= this.config.gridWidth; i++) {\n      const x = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(x, 0, x, worldHeight);\n    }\n\n    for (let i = 0; i <= this.config.gridHeight; i++) {\n      const y = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(0, y, worldWidth, y);\n    }\n  }\n\n  /**\n   * Update debug visualization\n   */\n  private updateDebugVisualization(entity: GridEntity, blockedCell: GridPosition | null): void {\n    if (!this.debugGraphics) return;\n\n    this.renderDebugGrid();\n\n    // Show entity position\n    this.debugGraphics.fillStyle(0x00ff00, 0.8);\n    this.debugGraphics.fillCircle(entity.x, entity.y, 4);\n\n    // Highlight current cell\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    const worldPos = this.gridToWorld(gridPos.gridX, gridPos.gridY);\n    this.debugGraphics.lineStyle(2, 0x00ff00, 0.6);\n    this.debugGraphics.strokeRect(\n      worldPos.x - this.config.tileSize / 2,\n      worldPos.y - this.config.tileSize / 2,\n      this.config.tileSize,\n      this.config.tileSize\n    );\n\n    // Highlight blocked cell if collision detected\n    if (blockedCell) {\n      const blockedWorld = this.gridToWorld(blockedCell.gridX, blockedCell.gridY);\n      this.debugGraphics.fillStyle(this.config.debugColor, 0.4);\n      this.debugGraphics.fillRect(\n        blockedWorld.x - this.config.tileSize / 2,\n        blockedWorld.y - this.config.tileSize / 2,\n        this.config.tileSize,\n        this.config.tileSize\n      );\n    }\n  }\n\n  /**\n   * Cleanup debug graphics\n   */\n  destroy(): void {\n    if (this.debugGraphics) {\n      this.debugGraphics.destroy();\n      this.debugGraphics = undefined;\n    }\n  }\n}\n\n// Maintain backward compatibility\n/** @deprecated Use GridCollisionConfig instead */\nexport type GridMovementConfig = GridCollisionConfig;\n/** @deprecated Use GridCollisionManager instead */\nexport const GridMovementManager = GridCollisionManager;\n\n/**\n * Factory function for creating a GridCollisionManager\n * Called from PhaserAdapter.createGridCollisionManager()\n */\nexport function createGridCollisionManager(\n  adapter: PhaserAdapter,\n  config: GridCollisionConfig\n): GridCollisionManager {\n  return new GridCollisionManager(adapter, config);\n}\n\n// Backward compatibility\n/** @deprecated Use createGridCollisionManager instead */\nexport const createGridMovementManager = createGridCollisionManager;\n", "/**\n * GridLockedMovementManager - True grid-locked movement for Bomberman-style games\n *\n * This helper provides CELL-TO-CELL committed movement where:\n * - Entities align to grid cell centers\n * - Movement commits to one full cell at a time\n * - Direction can only change when aligned to a cell\n * - Smooth animation interpolates between cells\n *\n * \u26A0\uFE0F NOTE: This is different from GridCollisionManager:\n * - GridLockedMovementManager: Cell-locked movement (Bomberman classic, Pacman, Sokoban)\n * - GridCollisionManager: Smooth movement with grid collision (Zelda, modern Bomberman)\n *\n * \u2705 CORRECT USAGE:\n * ```ts\n * // In scene.create()\n * this.gridLocked = this.adapter.createGridLockedMovementManager({\n *   tileSize: 52,\n *   gridWidth: 13,\n *   gridHeight: 13,\n *   collisionCheck: createMultiCollisionCheck(\n *     { name: 'blocks', fn: (x, y) => hasBlock(x, y) },\n *     { name: 'bombs', fn: (x, y) => hasBomb(x, y) }\n *   )\n * });\n *\n * // In tick action:\n * tick: createTickAction((state, delta) => {\n *   for (const [playerId, player] of Object.entries(state.players)) {\n *     const input = state.inputs[playerId];\n *     if (!input) continue;\n *     this.gridLocked.moveEntity(player, input, delta);\n *   }\n * })\n * ```\n *\n * @see GridCollisionManager for smooth movement with grid-aligned collision\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface GridLockedMovementConfig {\n  /**\n   * Size of each grid cell in pixels\n   */\n  tileSize: number;\n\n  /**\n   * Width of the grid in cells\n   */\n  gridWidth: number;\n\n  /**\n   * Height of the grid in cells\n   */\n  gridHeight: number;\n\n  /**\n   * Collision check function\n   * Returns true if there's a blocking obstacle at (gridX, gridY)\n   */\n  collisionCheck: (gridX: number, gridY: number) => boolean;\n\n  /**\n   * Base movement speed in cells per second (default: 3.0)\n   * Higher = faster movement between cells\n   */\n  baseSpeed?: number;\n\n  /**\n   * Enable debug visualization (default: false)\n   * Shows grid lines, current cell, target cell, progress\n   */\n  debug?: boolean;\n\n  /**\n   * Debug visualization color (default: 0xff0000)\n   */\n  debugColor?: number;\n}\n\nexport interface GridLockedEntity {\n  /** Current grid X position (cell coordinate) */\n  currentCell?: { x: number; y: number };\n  \n  /** Target grid position when moving */\n  targetCell?: { x: number; y: number } | null;\n  \n  /** Movement progress 0-1 between current and target */\n  moveProgress?: number;\n  \n  /** Actual world position (pixels) for rendering */\n  x: number;\n  y: number;\n  \n  /** Speed multiplier (default: 1.0) */\n  speed?: number;\n  \n  [key: string]: any;\n}\n\nexport interface MovementInput {\n  up?: boolean;\n  down?: boolean;\n  left?: boolean;\n  right?: boolean;\n  [key: string]: any;\n}\n\nexport class GridLockedMovementManager {\n  private config: Required<GridLockedMovementConfig>;\n  private debugGraphics?: any; // Phaser.GameObjects.Graphics\n  private adapter: PhaserAdapter;\n\n  constructor(adapter: PhaserAdapter, config: GridLockedMovementConfig) {\n    this.adapter = adapter;\n    this.config = {\n      baseSpeed: 3.0,\n      debug: false,\n      debugColor: 0xff0000,\n      ...config\n    };\n\n    // Setup debug visualization\n    if (this.config.debug) {\n      this.debugGraphics = adapter.getScene().add.graphics();\n      this.renderDebugGrid();\n    }\n  }\n\n  /**\n   * Move an entity with grid-locked behavior\n   * \n   * The entity will:\n   * 1. Continue moving to targetCell if already in motion\n   * 2. Accept new direction input only when aligned to a cell\n   * 3. Smoothly interpolate position between cells\n   *\n   * @param entity - Entity with grid position state\n   * @param input - Input with up/down/left/right flags\n   * @param delta - Time delta in milliseconds\n   */\n  moveEntity(entity: GridLockedEntity, input: MovementInput, delta: number): void {\n    // Initialize entity grid state if needed\n    if (!entity.currentCell) {\n      const gridPos = this.worldToGrid(entity.x, entity.y);\n      entity.currentCell = { x: gridPos.gridX, y: gridPos.gridY };\n      entity.targetCell = null;\n      entity.moveProgress = 0;\n    }\n\n    const speedMultiplier = entity.speed ?? 1.0;\n    const cellsPerSecond = this.config.baseSpeed * speedMultiplier;\n    const progressDelta = (cellsPerSecond * delta) / 1000;\n\n    // If currently moving, continue to target\n    if (entity.targetCell && entity.moveProgress !== undefined) {\n      entity.moveProgress += progressDelta;\n\n      if (entity.moveProgress >= 1.0) {\n        // Reached target cell - snap to center\n        entity.currentCell = { ...entity.targetCell };\n        entity.targetCell = null;\n        entity.moveProgress = 0;\n\n        // Update world position to exact cell center\n        const worldPos = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n        entity.x = worldPos.x;\n        entity.y = worldPos.y;\n      } else {\n        // Interpolate position\n        const currentWorld = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n        const targetWorld = this.gridToWorld(entity.targetCell.x, entity.targetCell.y);\n        \n        entity.x = this.lerp(currentWorld.x, targetWorld.x, entity.moveProgress);\n        entity.y = this.lerp(currentWorld.y, targetWorld.y, entity.moveProgress);\n      }\n    } else {\n      // Aligned to cell - can start new move\n      const direction = this.getDirection(input);\n      \n      if (direction.dx !== 0 || direction.dy !== 0) {\n        const nextCell = {\n          x: entity.currentCell.x + direction.dx,\n          y: entity.currentCell.y + direction.dy\n        };\n\n        // Check if next cell is walkable\n        if (this.isWalkable(nextCell.x, nextCell.y)) {\n          entity.targetCell = nextCell;\n          entity.moveProgress = 0;\n        }\n      }\n    }\n\n    // Update debug visualization\n    if (this.config.debug && this.debugGraphics) {\n      this.updateDebugVisualization(entity);\n    }\n  }\n\n  /**\n   * Snap entity to nearest grid cell center\n   */\n  snapToGrid(entity: GridLockedEntity): void {\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    const worldPos = this.gridToWorld(gridPos.gridX, gridPos.gridY);\n    \n    entity.x = worldPos.x;\n    entity.y = worldPos.y;\n    entity.currentCell = { x: gridPos.gridX, y: gridPos.gridY };\n    entity.targetCell = null;\n    entity.moveProgress = 0;\n  }\n\n  /**\n   * Check if entity is aligned to a grid cell\n   */\n  isAligned(entity: GridLockedEntity): boolean {\n    return !entity.targetCell && entity.moveProgress === 0;\n  }\n\n  /**\n   * Get entity's current grid position\n   */\n  getGridPosition(entity: GridLockedEntity): { x: number; y: number } {\n    if (entity.currentCell) {\n      return { ...entity.currentCell };\n    }\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    return { x: gridPos.gridX, y: gridPos.gridY };\n  }\n\n  /**\n   * Convert world coordinates to grid coordinates\n   */\n  worldToGrid(x: number, y: number): { gridX: number; gridY: number; isAligned: boolean } {\n    const gridX = Math.floor(x / this.config.tileSize);\n    const gridY = Math.floor(y / this.config.tileSize);\n\n    // Check if position is aligned to cell center\n    const centerX = gridX * this.config.tileSize + this.config.tileSize / 2;\n    const centerY = gridY * this.config.tileSize + this.config.tileSize / 2;\n    const threshold = this.config.tileSize * 0.1;\n    const isAligned = Math.abs(x - centerX) < threshold && Math.abs(y - centerY) < threshold;\n\n    return { gridX, gridY, isAligned };\n  }\n\n  /**\n   * Convert grid coordinates to world position (center of cell)\n   */\n  gridToWorld(gridX: number, gridY: number): { x: number; y: number } {\n    return {\n      x: gridX * this.config.tileSize + this.config.tileSize / 2,\n      y: gridY * this.config.tileSize + this.config.tileSize / 2\n    };\n  }\n\n  /**\n   * Check if a grid cell is walkable\n   */\n  private isWalkable(gridX: number, gridY: number): boolean {\n    // Check bounds\n    if (gridX < 0 || gridX >= this.config.gridWidth) return false;\n    if (gridY < 0 || gridY >= this.config.gridHeight) return false;\n\n    // Check collision\n    return !this.config.collisionCheck(gridX, gridY);\n  }\n\n  /**\n   * Extract direction from input\n   */\n  private getDirection(input: MovementInput): { dx: number; dy: number } {\n    const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);\n    const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);\n\n    // Grid-locked movement doesn't allow diagonal - pick strongest direction\n    if (dx !== 0 && dy !== 0) {\n      // Prioritize the most recent input (could be enhanced with input buffering)\n      // For now, prioritize horizontal\n      return { dx, dy: 0 };\n    }\n\n    return { dx, dy };\n  }\n\n  /**\n   * Linear interpolation\n   */\n  private lerp(start: number, end: number, t: number): number {\n    return start + (end - start) * t;\n  }\n\n  /**\n   * Render debug grid overlay\n   */\n  private renderDebugGrid(): void {\n    if (!this.debugGraphics) return;\n\n    this.debugGraphics.clear();\n    this.debugGraphics.lineStyle(1, this.config.debugColor, 0.3);\n\n    // Draw grid lines\n    const worldWidth = this.config.gridWidth * this.config.tileSize;\n    const worldHeight = this.config.gridHeight * this.config.tileSize;\n\n    for (let i = 0; i <= this.config.gridWidth; i++) {\n      const x = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(x, 0, x, worldHeight);\n    }\n\n    for (let i = 0; i <= this.config.gridHeight; i++) {\n      const y = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(0, y, worldWidth, y);\n    }\n  }\n\n  /**\n   * Update debug visualization for an entity\n   */\n  private updateDebugVisualization(entity: GridLockedEntity): void {\n    if (!this.debugGraphics) return;\n\n    this.renderDebugGrid();\n\n    // Highlight current cell\n    if (entity.currentCell) {\n      const worldPos = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n      this.debugGraphics.fillStyle(this.config.debugColor, 0.2);\n      this.debugGraphics.fillRect(\n        worldPos.x - this.config.tileSize / 2,\n        worldPos.y - this.config.tileSize / 2,\n        this.config.tileSize,\n        this.config.tileSize\n      );\n    }\n\n    // Highlight target cell\n    if (entity.targetCell) {\n      const worldPos = this.gridToWorld(entity.targetCell.x, entity.targetCell.y);\n      this.debugGraphics.fillStyle(this.config.debugColor, 0.4);\n      this.debugGraphics.fillRect(\n        worldPos.x - this.config.tileSize / 2,\n        worldPos.y - this.config.tileSize / 2,\n        this.config.tileSize,\n        this.config.tileSize\n      );\n\n      // Draw arrow from current to target\n      if (entity.currentCell) {\n        const currentWorld = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n        const targetWorld = this.gridToWorld(entity.targetCell.x, entity.targetCell.y);\n        this.debugGraphics.lineStyle(2, this.config.debugColor, 0.8);\n        this.debugGraphics.lineBetween(\n          currentWorld.x,\n          currentWorld.y,\n          targetWorld.x,\n          targetWorld.y\n        );\n      }\n    }\n\n    // Show entity position\n    this.debugGraphics.fillStyle(0xffffff, 1.0);\n    this.debugGraphics.fillCircle(entity.x, entity.y, 3);\n  }\n\n  /**\n   * Cleanup debug graphics\n   */\n  destroy(): void {\n    if (this.debugGraphics) {\n      this.debugGraphics.destroy();\n      this.debugGraphics = undefined;\n    }\n  }\n}\n\n/**\n * Factory function for creating a GridLockedMovementManager\n * Called from PhaserAdapter.createGridLockedMovementManager()\n */\nexport function createGridLockedMovementManager(\n  adapter: PhaserAdapter,\n  config: GridLockedMovementConfig\n): GridLockedMovementManager {\n  return new GridLockedMovementManager(adapter, config);\n}\n", "/**\n * PhaserAdapter - Bridge between Phaser and @martini-kit/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\nimport { PlayerUIManager, type PlayerUIManagerConfig } from './helpers/PlayerUIManager.js';\nimport { CollisionManager, type CollisionManagerConfig } from './helpers/CollisionManager.js';\nimport { PhysicsManager, type PhysicsManagerConfig } from './helpers/PhysicsManager.js';\nimport { StateDrivenSpawner, type StateDrivenSpawnerConfig } from './helpers/StateDrivenSpawner.js';\nimport { HealthBarManager, type HealthBarConfig } from './helpers/HealthBarManager.js';\nimport { GridClickHelper, type GridClickConfig } from './helpers/GridClickHelper.js';\nimport { GridCollisionManager, GridMovementManager, type GridCollisionConfig, type GridMovementConfig } from './helpers/GridCollisionManager.js';\nimport { GridLockedMovementManager, type GridLockedMovementConfig } from './helpers/GridLockedMovementManager.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 16ms / 60 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Optional motion profile to tune sync behavior */\n  motionProfile?: 'platformer' | 'projectile' | 'prop';\n\n  /** Namespace to write sprite data to (default: uses adapter's spriteNamespace) */\n  namespace?: string;\n\n  /** Enable adaptive sync rate (default: false) - syncs faster when moving, slower when idle */\n  adaptiveSync?: boolean;\n\n  /** Movement threshold for adaptive sync (default: 1 pixel/frame) */\n  adaptiveSyncThreshold?: number;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Snapshot buffer size in sync-intervals (optional)\n   *\n   * Defaults to auto-calculated `ceil(32ms / syncInterval)` so visuals always render\n   * ~32ms in the past, regardless of the host's sync rate. Override to trade\n   * smoothness vs latency (higher = smoother, more delay).\n   */\n  snapshotBufferSize?: number;\n\n  /**\n   * Automatically call tick action in scene.update() (default: true)\n   * When enabled, eliminates need for manual runtime.submitAction('tick', {delta})\n   * Set to false only if you need manual tick control.\n   */\n  autoTick?: boolean;\n\n  /**\n   * Name of the tick action to auto-call (default: 'tick')\n   * Only used when autoTick is enabled\n   */\n  tickAction?: string;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   snapshotBufferSize: 3           // optional, defaults to auto-sized for ~32ms delay\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\n/** Snapshot for buffered interpolation */\ninterface SpriteSnapshot {\n  x: number;\n  y: number;\n  rotation?: number;\n  timestamp: number;\n}\n\n/** Enhanced remote sprite data with interpolation state */\ninterface RemoteSpriteData {\n  sprite: any;\n  namespace: string;\n  snapshots: SpriteSnapshot[];\n  estimatedSyncInterval?: number;\n  delayIntervals?: number;\n}\n\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<\n    string,\n    {\n      sprite: any;\n      options: SpriteTrackingOptions;\n      lastPosition?: { x: number; y: number };\n      lastGrounded?: boolean;\n    }\n  > = new Map();\n  private remoteSprites: Map<string, RemoteSpriteData> = new Map();\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly snapshotBufferSizeOverride?: number;\n  private readonly targetInterpolationDelayMs: number = 32;\n  private readonly defaultSyncIntervalMs: number = 13;\n  private spriteManagers: Set<{ namespace: string }> = new Set(); // Track all registered SpriteManagers\n  private physicsManagedNamespaces: Set<string> = new Set(); // Track namespaces driven by PhysicsManager\n  private readonly autoTick: boolean;\n  private readonly tickAction: string;\n  private lastTickTime: number = Date.now();\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.snapshotBufferSizeOverride = config.snapshotBufferSize ?? 4;\n    this.autoTick = config.autoTick !== false; // default true\n    this.tickAction = config.tickAction || 'tick';\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Get the local player's ID\n   * More discoverable alias for {@link myId}\n   */\n  getLocalPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Backwards-compatible helper - alias for {@link myId}\n   * @deprecated Use {@link getLocalPlayerId} instead for better discoverability\n   */\n  getMyPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Get the current player's state object from the runtime\n   *\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  getMyPlayer<TPlayer = any>(playersKey: string = 'players'): TPlayer | undefined {\n    const state = this.runtime.getState() as any;\n    const players = state?.[playersKey];\n    if (!players) return undefined;\n    return players[this.getMyPlayerId()];\n  }\n\n  /**\n   * Subscribe to changes in the current player's state\n   *\n   * @param callback Invoked whenever the local player's record changes\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  onMyPlayerChange<TPlayer = any>(\n    callback: (player: TPlayer | undefined) => void,\n    playersKey: string = 'players'\n  ): () => void {\n    let lastValue = this.getMyPlayer<TPlayer>(playersKey);\n    callback(lastValue);\n\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const nextValue = players ? players[this.getMyPlayerId()] : undefined;\n      if (nextValue === lastValue) {\n        return;\n      }\n      lastValue = nextValue;\n      callback(nextValue);\n    });\n  }\n\n  /**\n   * Watch a derived value from the current player's state with automatic change detection\n   *\n   * This is the reactive counterpart to `onMyPlayerChange`. It re-runs a selector function\n   * on every state change and only fires the callback when the selected value changes\n   * (using Object.is equality by default).\n   *\n   * Perfect for reactive UIs that need to respond to property mutations like size, health, score, etc.\n   *\n   * @param selector Function that extracts a value from the player state\n   * @param callback Invoked when the selected value changes\n   * @param options Optional configuration\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Watch player size changes\n   * adapter.watchMyPlayer(\n   *   (player) => player?.size,\n   *   (size) => {\n   *     hudText.setText(`Size: ${size}`);\n   *   }\n   * );\n   *\n   * // Watch multiple properties\n   * adapter.watchMyPlayer(\n   *   (player) => ({ size: player?.size, health: player?.health }),\n   *   (stats) => {\n   *     hudText.setText(`Size: ${stats.size}, HP: ${stats.health}`);\n   *   }\n   * );\n   *\n   * // Custom equality check\n   * adapter.watchMyPlayer(\n   *   (player) => player?.position,\n   *   (pos) => console.log('Position changed:', pos),\n   *   { equals: (a, b) => a?.x === b?.x && a?.y === b?.y }\n   * );\n   * ```\n   */\n  watchMyPlayer<TPlayer = any, TSelected = any>(\n    selector: (player: TPlayer | undefined) => TSelected,\n    callback: (selected: TSelected, prev: TSelected | undefined) => void,\n    options?: {\n      /** Key in state where players are stored (default: 'players') */\n      playersKey?: string;\n      /** Custom equality check (default: Object.is) */\n      equals?: (a: TSelected, b: TSelected) => boolean;\n    }\n  ): () => void {\n    const playersKey = options?.playersKey || 'players';\n    const equals = options?.equals || Object.is;\n\n    // Get initial value and fire callback\n    let lastSelected = selector(this.getMyPlayer<TPlayer>(playersKey));\n    callback(lastSelected, undefined);\n\n    // Subscribe to all state changes\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const player = players ? players[this.getMyPlayerId()] : undefined;\n      const nextSelected = selector(player);\n\n      // Only fire callback if selected value changed\n      if (!equals(nextSelected, lastSelected)) {\n        const prev = lastSelected;\n        lastSelected = nextSelected;\n        callback(nextSelected, prev);\n      }\n    });\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Expose the underlying Phaser scene\n   */\n  getScene(): any {\n    return this.scene;\n  }\n\n  /**\n   * Convert pointer screen coordinates to world coordinates\n   *\n   * IMPORTANT: Always use this helper (or pointer.worldX/worldY directly)\n   * when handling pointer input for game logic. Using pointer.x/y will break\n   * when the camera is scrolled/following a player.\n   *\n   * @param pointer - Phaser pointer object from input events\n   * @returns World coordinates { x: number, y: number }\n   *\n   * @example\n   * ```ts\n   * this.input.on('pointerdown', (pointer) => {\n   *   const worldPos = adapter.pointerToWorld(pointer);\n   *   runtime.submitAction('move', { x: worldPos.x, y: worldPos.y });\n   * });\n   * ```\n   */\n  pointerToWorld(pointer: { worldX: number; worldY: number }): { x: number; y: number } {\n    return {\n      x: pointer.worldX,\n      y: pointer.worldY\n    };\n  }\n\n  /**\n   * FIX #2: Wait for required metadata properties before executing callback\n   *\n   * This is a shared utility that prevents race conditions when creating UI/sprites\n   * that depend on static properties like role, team, side, etc.\n   *\n   * Extracted pattern from PlayerUIManager and HUDHelper for reuse across the SDK.\n   *\n   * @param stateKey - Key in state where the entity data lives (e.g., 'players')\n   * @param entityId - ID of the specific entity (e.g., player ID)\n   * @param requiredProperties - Array of property names that must exist before callback fires\n   * @param callback - Called when all required properties are present\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Wait for player metadata before creating UI\n   * adapter.waitForMetadata('players', playerId, ['role', 'team'], (data) => {\n   *   const color = data.role === 'fire' ? 0xff0000 : 0x0000ff;\n   *   const sprite = this.add.circle(data.x, data.y, 20, color);\n   * });\n   *\n   * // Wait for sprite static properties\n   * adapter.waitForMetadata('__sprites__.players', spriteKey, ['role'], (data) => {\n   *   const label = this.add.text(data.x, data.y, data.role.toUpperCase());\n   * });\n   * ```\n   */\n  waitForMetadata(\n    stateKey: string,\n    entityId: string,\n    requiredProperties: string[],\n    callback: (data: any) => void\n  ): () => void {\n    // Helper to check if all required properties exist\n    const hasAllProperties = (data: any): boolean => {\n      if (!data) return false;\n      return requiredProperties.every(prop => prop in data && data[prop] !== undefined);\n    };\n\n    // Check current state immediately\n    const state = this.runtime.getState() as any;\n    const collection = this.getNestedProperty(state, stateKey);\n    const currentData = collection?.[entityId];\n\n    if (hasAllProperties(currentData)) {\n      // All properties already present - fire immediately\n      callback(currentData);\n      return () => {}; // No-op unsubscribe\n    }\n\n    // Properties not ready yet - subscribe to state changes\n    return this.runtime.onChange((state: any) => {\n      const collection = this.getNestedProperty(state, stateKey);\n      const data = collection?.[entityId];\n\n      if (hasAllProperties(data)) {\n        callback(data);\n      }\n    });\n  }\n\n  /**\n   * Helper to get nested property from state (e.g., '__sprites__.players')\n   * @internal\n   */\n  private getNestedProperty(obj: any, path: string): any {\n    const parts = path.split('.');\n    let current = obj;\n    for (const part of parts) {\n      if (current == null) return undefined;\n      current = current[part];\n    }\n    return current;\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, {\n      sprite,\n      options,\n      lastPosition: { x: sprite.x, y: sprite.y },\n      lastGrounded: undefined\n    });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 16;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // FIX #3 & #4: Do immediate first sync to guarantee ordering\n    // Previously, the first sync happened 50ms later via interval, which created\n    // a race condition where static data (from setSpriteStaticData) could arrive\n    // at clients before or after position data.\n    //\n    // Now we sync immediately, which guarantees the order:\n    // 1. setSpriteStaticData() writes static properties (e.g., role: 'fire')\n    // 2. trackSprite() immediately writes position (e.g., x, y)\n    // Both broadcasts happen synchronously in the correct order!\n    if (this.isHost()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Stop tracking a sprite\n   *\n   * @param key - Sprite key\n   * @param namespace - Optional namespace (defaults to spriteNamespace from config)\n   */\n  untrackSprite(key: string, namespace?: string): void {\n    const tracked = this.trackedSprites.get(key);\n    this.trackedSprites.delete(key);\n\n    // Use namespace from tracked options, parameter, or default\n    const ns = namespace || tracked?.options.namespace || this.spriteNamespace;\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[ns];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Call this in your Phaser scene's update() loop\n   *\n   * When autoTick is enabled, this automatically calls the tick action.\n   * Always handles remote sprite interpolation (on clients).\n   *\n   * @param time - Phaser time (total elapsed time in ms)\n   * @param delta - Phaser delta (time since last frame in ms)\n   *\n   * @example\n   * ```ts\n   * // In your Phaser scene:\n   * update(time: number, delta: number) {\n   *   adapter.update(time, delta);\n   * }\n   * ```\n   */\n  update(time: number, delta: number): void {\n    // Auto-tick: Automatically submit tick action (host only)\n    if (this.autoTick && this.isHost()) {\n      const now = Date.now();\n      const tickDelta = now - this.lastTickTime;\n      this.lastTickTime = now;\n      this.runtime.submitAction(this.tickAction, { delta: tickDelta });\n    }\n\n    // Always update interpolation on clients\n    if (!this.isHost()) {\n      this.updateInterpolation(delta);\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const { sprite, options, lastPosition } = tracked;\n      const motionProfile = options.motionProfile;\n\n      // Detect ground contact for platformers to force an immediate sync\n      let forceSync = false;\n      if (motionProfile === 'platformer' && sprite?.body) {\n        const body = sprite.body as any;\n        const grounded = !!(body.blocked?.down || body.touching?.down);\n        if (grounded && tracked.lastGrounded === false) {\n          forceSync = true; // landing transition\n        }\n        tracked.lastGrounded = grounded;\n      }\n\n      // Adaptive sync: skip if sprite hasn't moved much\n      if (!forceSync && options.adaptiveSync && lastPosition) {\n        const threshold = options.adaptiveSyncThreshold ?? 1;\n        const dx = Math.abs(sprite.x - lastPosition.x);\n        const dy = Math.abs(sprite.y - lastPosition.y);\n\n        if (dx < threshold && dy < threshold) {\n          continue; // Skip sync for idle sprite\n        }\n      }\n\n      this.syncSpriteToState(key, sprite, options);\n\n      // Update last position for adaptive sync\n      if (options.adaptiveSync) {\n        tracked.lastPosition = { x: sprite.x, y: sprite.y };\n      }\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Use namespace from options or default\n    const namespace = options.namespace || this.spriteNamespace;\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[namespace]) {\n        state[namespace] = {};\n      }\n      const sprites = state[namespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Set static metadata for a tracked sprite (host only)\n   *\n   * @param key - Sprite key\n   * @param data - Static data to set\n   * @param namespace - Optional namespace (defaults to spriteNamespace from config)\n   */\n  setSpriteStaticData(key: string, data: Record<string, any>, namespace?: string): void {\n    if (!this.isHost()) return;\n\n    const ns = namespace || this.spriteNamespace;\n    this.runtime.mutateState((state: any) => {\n      if (!state[ns]) {\n        state[ns] = {};\n      }\n      const sprites = state[ns];\n      sprites[key] = { ...data, ...sprites[key] };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   *\n   * MULTI-NAMESPACE SUPPORT: This method now handles sprites from all registered\n   * namespaces, including both the default namespace and custom namespaces from\n   * createSpriteRegistry(). This fixes the bug where sprites in custom namespaces\n   * (like __sprites__.players) weren't getting interpolation targets on clients.\n   */\n  private updateSpritesFromState(state: any): void {\n    if (this.isHost()) return;\n\n    // Collect all namespaces to check\n    const namespacesToCheck = new Set<string>();\n\n    // Add default namespace\n    namespacesToCheck.add(this.spriteNamespace);\n\n    // Add all registered SpriteManager namespaces\n    for (const manager of this.spriteManagers) {\n      namespacesToCheck.add(manager.namespace);\n    }\n\n    // Update sprites in each namespace\n    for (const namespace of namespacesToCheck) {\n      const sprites = state[namespace];\n      if (!sprites) continue; // Skip if this namespace doesn't exist in state\n\n      // Update tracked sprites (sprites that exist on this client)\n      for (const [key, tracked] of this.trackedSprites.entries()) {\n        const spriteData = sprites[key];\n        if (spriteData) {\n          this.applySpriteData(tracked.sprite, spriteData);\n        }\n      }\n\n      // Update remote sprites (sprites from other players)\n      // Store snapshot for interpolation\n      const now = Date.now();\n      for (const [key, spriteData] of Object.entries(sprites)) {\n        // Skip if this is our own sprite\n        if (this.trackedSprites.has(key)) continue;\n\n        const remoteSpriteData = this.remoteSprites.get(key);\n        if (!remoteSpriteData || remoteSpriteData.namespace !== namespace) continue;\n\n        const data = spriteData as any;\n        const snapshots = remoteSpriteData.snapshots;\n\n        snapshots.push({\n          x: data.x,\n          y: data.y,\n          rotation: data.rotation,\n          timestamp: now\n        });\n\n        // Update estimated sync interval for adaptive buffering\n        if (snapshots.length >= 2) {\n          const latest = snapshots[snapshots.length - 1].timestamp;\n          const previous = snapshots[snapshots.length - 2].timestamp;\n          const interval = latest - previous;\n          if (interval > 0) {\n            remoteSpriteData.estimatedSyncInterval = this.smoothSyncInterval(\n              remoteSpriteData.estimatedSyncInterval,\n              interval\n            );\n          }\n        }\n\n        // Keep only the snapshots needed to cover the target delay window\n        const maxSnapshots = this.getMaxSnapshots(remoteSpriteData);\n        while (snapshots.length > maxSnapshots) {\n          snapshots.shift();\n        }\n\n        // First update - snap to position immediately\n        const sprite = remoteSpriteData.sprite;\n        if (sprite.x === undefined || Number.isNaN(sprite.x)) {\n          sprite.x = data.x;\n          sprite.y = data.y;\n          sprite.rotation = data.rotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Blend new sync interval measurements with previous estimate for stability\n   */\n  private smoothSyncInterval(previous: number | undefined, next: number): number {\n    if (!previous) return next;\n    const alpha = 0.2; // simple EMA to avoid jitter in delay calculation\n    return previous * (1 - alpha) + next * alpha;\n  }\n\n  /**\n   * Number of snapshots we should keep to cover the target render delay window\n   */\n  private getMaxSnapshots(remoteSpriteData: RemoteSpriteData): number {\n    const delayIntervals = this.getDelayIntervals(remoteSpriteData);\n    // Need one more snapshot than delay intervals to bracket the render time\n    return Math.max(2, delayIntervals + 1);\n  }\n\n  /**\n   * Compute delay intervals (in sync steps) for this sprite\n   */\n  private getDelayIntervals(remoteSpriteData: RemoteSpriteData): number {\n    if (this.snapshotBufferSizeOverride) {\n      remoteSpriteData.delayIntervals = Math.max(1, this.snapshotBufferSizeOverride);\n      return remoteSpriteData.delayIntervals;\n    }\n\n    const syncInterval = remoteSpriteData.estimatedSyncInterval ?? this.defaultSyncIntervalMs;\n    const autoSize = Math.max(1, Math.ceil(this.targetInterpolationDelayMs / syncInterval));\n    remoteSpriteData.delayIntervals = autoSize;\n    return autoSize;\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   * @param namespace - Optional namespace (defaults to spriteNamespace config)\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any, namespace?: string): void {\n    this.remoteSprites.set(key, {\n      sprite,\n      namespace: namespace || this.spriteNamespace,\n      snapshots: []\n    });\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Clients always render between the last 2 received snapshots for buttery smooth motion.\n   * This eliminates frame timing jitter while adding ~32ms consistent latency.\n   */\n  updateInterpolation(_delta?: number): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    const now = Date.now();\n\n    for (const [key, remoteSpriteData] of this.remoteSprites.entries()) {\n      const sprite = remoteSpriteData.sprite;\n      // Snapshot buffer interpolation: Render between last 2 snapshots\n      this.updateSnapshotBufferInterpolation(sprite, remoteSpriteData, now);\n    }\n  }\n\n  /**\n   * Snapshot buffer interpolation (smoothest, renders in the past)\n   */\n  private updateSnapshotBufferInterpolation(\n    sprite: any,\n    remoteSpriteData: RemoteSpriteData,\n    now: number\n  ): void {\n    const snapshots = remoteSpriteData.snapshots;\n    if (!snapshots || snapshots.length < 2) return;\n\n    const syncInterval = remoteSpriteData.estimatedSyncInterval ?? this.defaultSyncIntervalMs;\n    const delayIntervals = this.getDelayIntervals(remoteSpriteData);\n    const renderDelay = delayIntervals * syncInterval;\n    const renderTime = now - renderDelay;\n\n    // Find two snapshots to interpolate between\n    let snapshot0: SpriteSnapshot = snapshots[0];\n    let snapshot1: SpriteSnapshot = snapshots[snapshots.length - 1];\n\n    for (let i = 0; i < snapshots.length - 1; i++) {\n      const current = snapshots[i];\n      const next = snapshots[i + 1];\n      if (current.timestamp <= renderTime && next.timestamp >= renderTime) {\n        snapshot0 = current;\n        snapshot1 = next;\n        break;\n      }\n    }\n\n    // Clamp to earliest/latest if renderTime is outside buffered window\n    if (renderTime <= snapshots[0].timestamp) {\n      snapshot0 = snapshots[0];\n      snapshot1 = snapshots[1] ?? snapshots[0];\n    } else if (renderTime >= snapshots[snapshots.length - 1].timestamp) {\n      snapshot0 = snapshots[snapshots.length - 2];\n      snapshot1 = snapshots[snapshots.length - 1];\n    }\n\n    // Interpolate between snapshots\n    const t0 = snapshot0.timestamp;\n    const t1 = snapshot1.timestamp;\n    const denom = t1 - t0;\n    const t = denom === 0 ? 1 : (renderTime - t0) / denom;\n    const clamped = Math.max(0, Math.min(1, t));\n\n    sprite.x = snapshot0.x + (snapshot1.x - snapshot0.x) * clamped;\n    sprite.y = snapshot0.y + (snapshot1.y - snapshot0.y) * clamped;\n\n    if (snapshot0.rotation !== undefined && snapshot1.rotation !== undefined) {\n      sprite.rotation = snapshot0.rotation + (snapshot1.rotation - snapshot0.rotation) * clamped;\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const remoteSpriteData = this.remoteSprites.get(key);\n    if (remoteSpriteData?.sprite && remoteSpriteData.sprite.destroy) {\n      remoteSpriteData.sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  // ============================================================================\n  // Lobby System Helpers (Pit of Success)\n  // ============================================================================\n\n  /**\n   * Register a callback that only runs once when transitioning to 'playing' phase\n   *\n   * \u2705 Pit of success: Prevents creating game objects during lobby phase\n   *\n   * @example\n   * ```ts\n   * create() {\n   *   // Static setup (background, lobby UI)\n   *   this.add.rectangle(400, 300, 800, 600, 0x1a1a2e);\n   *\n   *   // \u2705 Game objects only created when playing starts\n   *   this.adapter.onPlaying((state) => {\n   *     this.ball = this.add.circle(state.ball.x, state.ball.y, 10, 0xff6b6b);\n   *     this.physics.add.existing(this.ball);\n   *   });\n   * }\n   * ```\n   */\n  onPlaying(callback: (state: TState) => void): () => void {\n    let hasStarted = false;\n\n    return this.runtime.onChange((state: any) => {\n      // If no lobby system, run immediately\n      if (!state.__lobby) {\n        if (!hasStarted) {\n          hasStarted = true;\n          callback(state);\n        }\n        return;\n      }\n\n      // With lobby: only run when transitioning to 'playing'\n      if (!hasStarted && state.__lobby.phase === 'playing') {\n        hasStarted = true;\n        callback(state);\n      }\n    });\n  }\n\n  /**\n   * Register a callback that only runs while in 'playing' phase\n   *\n   * Runs every state update during gameplay, stops when game ends.\n   *\n   * @example\n   * ```ts\n   * this.adapter.whilePlaying((state) => {\n   *   // Physics updates, collision checks, etc.\n   *   this.handleGameLogic(state);\n   * });\n   * ```\n   */\n  whilePlaying(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange((state: any) => {\n      // If no lobby system, always run\n      if (!state.__lobby) {\n        callback(state);\n        return;\n      }\n\n      // With lobby: only run during 'playing' phase\n      if (state.__lobby.phase === 'playing') {\n        callback(state);\n      }\n    });\n  }\n\n  /**\n   * Register a callback that runs when game ends\n   *\n   * @example\n   * ```ts\n   * this.adapter.onEnded((state) => {\n   *   this.showResults(state);\n   * });\n   * ```\n   */\n  onEnded(callback: (state: TState) => void): () => void {\n    let hasEnded = false;\n\n    return this.runtime.onChange((state: any) => {\n      if (!state.__lobby) return; // No lobby system\n\n      if (!hasEnded && state.__lobby.phase === 'ended') {\n        hasEnded = true;\n        callback(state);\n      }\n    });\n  }\n\n  /**\n   * Check if game is currently in lobby phase\n   */\n  isInLobby(): boolean {\n    const state = this.runtime.getState() as any;\n    return state.__lobby?.phase === 'lobby';\n  }\n\n  /**\n   * Check if game is currently playing\n   */\n  isPlaying(): boolean {\n    const state = this.runtime.getState() as any;\n    if (!state.__lobby) return true; // No lobby = always playing\n    return state.__lobby.phase === 'playing';\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   namespace: 'players',  // optional, defaults to '_sprites'\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    const manager = new SpriteManager(this, config);\n    // Register the namespace for multi-namespace interpolation support\n    this.registerSpriteManager(manager);\n    return manager;\n  }\n\n  /**\n   * Register a SpriteManager with this adapter for multi-namespace support\n   * Internal method - automatically called by createSpriteManager\n   */\n  registerSpriteManager(manager: { namespace: string }): void {\n    this.spriteManagers.add(manager);\n  }\n\n  /**\n   * Check if a namespace is already managed by PhysicsManager (for conflict warnings/defaults)\n   */\n  hasPhysicsManagedNamespace(namespace: string): boolean {\n    return this.physicsManagedNamespaces.has(namespace);\n  }\n\n  /**\n   * Create a typed registry of sprite managers\n   *\n   * This provides type-safe collections of sprites with automatic namespacing.\n   * Each sprite type gets its own isolated namespace in the state tree.\n   *\n   * @example\n   * ```ts\n   * const sprites = adapter.createSpriteRegistry({\n   *   players: {\n   *     onCreate: (key, data: { x: number, y: number, role: string }) => {\n   *       const color = data.role === 'fire' ? 0xff3300 : 0x0033ff;\n   *       return this.add.circle(data.x, data.y, 20, color);\n   *     },\n   *     staticProperties: ['role'],\n   *     label: { getText: (d) => d.role.toUpperCase() }\n   *   },\n   *   enemies: {\n   *     onCreate: (key, data: { x: number, y: number, type: string }) => {\n   *       return this.add.sprite(data.x, data.y, data.type);\n   *     }\n   *   }\n   * });\n   *\n   * // Type-safe sprite creation\n   * sprites.players.add('p1', { x: 100, y: 100, role: 'fire' });\n   * sprites.enemies.add('e1', { x: 200, y: 200, type: 'goblin' });\n   *\n   * // Each collection has its own namespace:\n   * // state.__sprites__.players = { p1: { x: 100, y: 100, role: 'fire' } }\n   * // state.__sprites__.enemies = { e1: { x: 200, y: 200, type: 'goblin' } }\n   * ```\n   */\n  createSpriteRegistry<TRegistry extends Record<string, SpriteManagerConfig<any>>>(\n    config: TRegistry\n  ): {\n    [K in keyof TRegistry]: SpriteManager<\n      TRegistry[K] extends SpriteManagerConfig<infer TData> ? TData : never\n    >;\n  } {\n    const registry: any = {};\n\n    for (const [name, managerConfig] of Object.entries(config)) {\n      const manager = new SpriteManager(this, {\n        ...managerConfig,\n        namespace: `__sprites__.${name}`\n      });\n      // Register the namespace for multi-namespace interpolation support\n      this.registerSpriteManager(manager);\n      registry[name] = manager;\n    }\n\n    return registry;\n  }\n\n  /**\n   * Create a PlayerUIManager for automatically managed player HUD elements\n   */\n  createPlayerUIManager(config: PlayerUIManagerConfig): PlayerUIManager {\n    return new PlayerUIManager(this, this.scene, config);\n  }\n\n  /**\n   * Create a CollisionManager for declarative collision rules\n   */\n  createCollisionManager(config?: CollisionManagerConfig): CollisionManager {\n    return new CollisionManager(this, this.scene, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n\n  /**\n   * Create a PhysicsManager for automatic physics behaviors\n   */\n  createPhysicsManager(config: PhysicsManagerConfig): PhysicsManager {\n    if ((config as any).spriteManager?.namespace && (config as any).syncPositionToState !== false) {\n      this.physicsManagedNamespaces.add((config as any).spriteManager.namespace);\n    }\n    return new PhysicsManager(this.runtime, config);\n  }\n\n  /**\n   * Create a StateDrivenSpawner for automatic sprite spawning from state collections\n   *\n   * Eliminates the manual \"check for new players/bullets\" loop.\n   * Watches a state collection and automatically creates/removes sprites.\n   *\n   * @example\n   * ```ts\n   * // Players (uses object keys)\n   * const playerSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'players',\n   *   spriteManager: this.spriteManager,\n   *   keyPrefix: 'player-'\n   * });\n   *\n   * // Bullets (uses array with id field)\n   * const bulletSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'bullets',\n   *   spriteManager: this.bulletManager,\n   *   keyPrefix: 'bullet-',\n   *   keyField: 'id'\n   * });\n   *\n   * // In update():\n   * playerSpawner.update(); // HOST only\n   * ```\n   */\n  createStateDrivenSpawner(config: StateDrivenSpawnerConfig): StateDrivenSpawner {\n    return new StateDrivenSpawner(this, config);\n  }\n\n  /**\n   * Create a GridClickHelper for robust grid/board click handling\n   *\n   * Solves the common problem where interactive rectangles don't scale properly\n   * with the canvas. Uses pointer.worldX/worldY for accurate coordinate mapping\n   * that works in any scale mode (FIT, RESIZE, etc).\n   *\n   * Perfect for: Connect Four, Chess, Tic-Tac-Toe, Minesweeper, Battleship, etc.\n   *\n   * @example\n   * ```ts\n   * const gridHelper = adapter.createClickableGrid({\n   *   columns: 7,\n   *   rows: 6,\n   *   cellWidth: 80,\n   *   cellHeight: 80,\n   *   offsetX: 100,\n   *   offsetY: 100,\n   *   onCellClick: (col, row) => {\n   *     runtime.submitAction('dropToken', { col });\n   *   },\n   *   highlightColor: 0xffffff,\n   *   highlightAlpha: 0.15,\n   *   origin: 'bottom-left' // For Connect Four\n   * });\n   * ```\n   */\n  createClickableGrid(config: GridClickConfig): GridClickHelper {\n    return new GridClickHelper(this, this.scene, config);\n  }\n\n  /**\n   * Create a GridCollisionManager for smooth movement with grid-aligned collision\n   *\n   * \u26A0\uFE0F NOTE: This provides SMOOTH movement, not grid-locked movement.\n   * For cell-to-cell committed movement (classic Bomberman), use createGridLockedMovementManager().\n   *\n   * @example\n   * ```ts\n   * const gridCollision = adapter.createGridCollisionManager({\n   *   tileSize: 52,\n   *   gridWidth: 13,\n   *   gridHeight: 13,\n   *   collisionCheck: createMultiCollisionCheck(\n   *     { name: 'blocks', fn: (x, y) => hasBlock(state.blocks, x, y) },\n   *     { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n   *   ),\n   *   debug: false // Enable to see grid overlay\n   * });\n   *\n   * // In tick action:\n   * gridCollision.moveEntity(player, input, delta);\n   * ```\n   */\n  createGridCollisionManager(config: GridCollisionConfig): GridCollisionManager {\n    return new GridCollisionManager(this, config);\n  }\n\n  /**\n   * Create a GridLockedMovementManager for true grid-locked movement\n   *\n   * Provides cell-to-cell committed movement where entities:\n   * - Align to grid cell centers\n   * - Commit to moving one full cell at a time\n   * - Can only change direction when aligned\n   * - Smoothly animate between cells\n   *\n   * Perfect for: Classic Bomberman, Pacman, Sokoban, turn-based grid games.\n   *\n   * @example\n   * ```ts\n   * const gridLocked = adapter.createGridLockedMovementManager({\n   *   tileSize: 52,\n   *   gridWidth: 13,\n   *   gridHeight: 13,\n   *   collisionCheck: createMultiCollisionCheck(\n   *     { name: 'blocks', fn: (x, y) => hasBlock(state.blocks, x, y) },\n   *     { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n   *   ),\n   *   baseSpeed: 3.0 // cells per second\n   * });\n   *\n   * // In tick action:\n   * gridLocked.moveEntity(player, input, delta);\n   * ```\n   */\n  createGridLockedMovementManager(config: GridLockedMovementConfig): GridLockedMovementManager {\n    return new GridLockedMovementManager(this, config);\n  }\n\n  /**\n   * @deprecated Use createGridCollisionManager instead. GridMovementManager has been renamed to GridCollisionManager for clarity.\n   */\n  createGridMovementManager(config: GridMovementConfig): GridCollisionManager {\n    return new GridCollisionManager(this, config);\n  }\n\n  /**\n   * Create a HealthBarManager for automatic health bar management\n   *\n   * Auto-creates, positions, scales, and colors health bars for all sprites.\n   *\n   * @example\n   * ```ts\n   * const healthBars = adapter.createHealthBarManager({\n   *   spriteManager: this.spriteManager,\n   *   healthKey: 'health',\n   *   maxHealth: 100,\n   *   offset: { x: 0, y: -30 },\n   *   width: 50,\n   *   height: 5\n   * });\n   *\n   * // In update():\n   * healthBars.update();\n   * ```\n   */\n  createHealthBarManager(config: HealthBarConfig): HealthBarManager {\n    return new HealthBarManager(this, config);\n  }\n\n  /**\n   * Create a CameraFollower for automatic camera tracking\n   *\n   * Eliminates manual camera positioning and fixes initialization timing bugs.\n   * Automatically waits for player state, then follows smoothly.\n   *\n   * @example\n   * ```ts\n   * // Simplest usage - auto-follows local player\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer'\n   * });\n   *\n   * // With smooth lerp following\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer',\n   *   mode: 'lerp',\n   *   lerpFactor: 0.1\n   * });\n   *\n   * // With world bounds\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer',\n   *   bounds: { width: 1600, height: 1200 }\n   * });\n   *\n   * // No manual camera code needed in update()!\n   * // Camera automatically follows and handles all edge cases.\n   * ```\n   */\n  createCameraFollower(config: import('./helpers/CameraFollower.js').CameraFollowerConfig = {}): import('./helpers/CameraFollower.js').CameraFollower {\n    const { createCameraFollower } = require('./helpers/CameraFollower.js');\n    return createCameraFollower(this, this.scene, config);\n  }\n\n  /**\n   * Submit action ONLY when input changes (10x devtools improvement!)\n   *\n   * Automatically tracks previous input and only submits when changed.\n   * Prevents flooding devtools with 60 identical actions per second.\n   *\n   * @param actionName - Name of the action to submit\n   * @param input - Current input state\n   * @param targetId - Optional target player ID\n   *\n   * @example\n   * ```ts\n   * // In scene.update()\n   * const input = {\n   *   left: keys.left.isDown,\n   *   right: keys.right.isDown,\n   *   up: keys.up.isDown\n   * };\n   * adapter.submitActionOnChange('move', input); // Only sends when input changes!\n   * ```\n   */\n  submitActionOnChange(actionName: string, input: any, targetId?: string): void {\n    // Use a private map to track previous inputs per action\n    if (!(this as any)._previousInputs) {\n      (this as any)._previousInputs = new Map<string, string>();\n    }\n\n    const key = targetId ? `${actionName}:${targetId}` : actionName;\n    const inputJson = JSON.stringify(input);\n    const previousJson = (this as any)._previousInputs.get(key);\n\n    // Only submit if input changed\n    if (inputJson !== previousJson) {\n      (this as any)._previousInputs.set(key, inputJson);\n      this.runtime.submitAction(actionName, input, targetId);\n    }\n  }\n}\n", "/**\n * HUD Helper - Unified player HUD/UI for multiplayer games\n *\n * Eliminates the manual HUD boilerplate by automatically creating and managing\n * title, role, and control hint text based on the current player state.\n *\n * @example\n * ```ts\n * import { createPlayerHUD } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.hud = createPlayerHUD(this.adapter, this, {\n *   title: 'Fire & Ice - Cooperative Platformer',\n *\n *   roleText: (myPlayer) => {\n *     if (!myPlayer) return 'Spectator';\n *     return myPlayer.role === 'fire' ? 'Fire Player' : 'Ice Player';\n *   },\n *\n *   controlHints: (myPlayer) => {\n *     if (!myPlayer) return '';\n *     return 'Arrow Keys + SPACE to Jump';\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface HUDLayout {\n\t/** Position for title text */\n\ttitle?: { x: number; y: number };\n\t/** Position for role text */\n\trole?: { x: number; y: number };\n\t/** Position for controls text */\n\tcontrols?: { x: number; y: number };\n}\n\nexport interface HUDTextStyle {\n\tfontSize?: string;\n\tcolor?: string;\n\tfontStyle?: string;\n\tbackgroundColor?: string;\n\tpadding?: { x: number; y: number };\n}\n\nexport interface PlayerHUDConfig<TPlayer = any, TState = any> {\n\t/** Title text (static) */\n\ttitle?: string;\n\t/** Title text style */\n\ttitleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate role text from player data and optionally game state\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @param state - Full game state (optional, for turn-based games)\n\t * @returns Text to display\n\t *\n\t * @example\n\t * // Simple usage (action games)\n\t * roleText: (myPlayer) => {\n\t *   if (!myPlayer) return 'Spectator';\n\t *   return `Player ${myPlayer.id}`;\n\t * }\n\t *\n\t * @example\n\t * // With state (turn-based games)\n\t * roleText: (myPlayer, state) => {\n\t *   if (!myPlayer) return 'Spectator';\n\t *   if (state?.gameOver) return 'Game Over!';\n\t *   return state?.currentTurn === myPlayer.id ? 'Your Turn' : 'Waiting...';\n\t * }\n\t */\n\troleText?: (myPlayer: TPlayer | undefined, state?: TState) => string;\n\t/** Role text style */\n\troleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate control hints from player data and optionally game state\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @param state - Full game state (optional)\n\t * @returns Text to display\n\t */\n\tcontrolHints?: (myPlayer: TPlayer | undefined, state?: TState) => string;\n\t/** Control hints text style */\n\tcontrolsStyle?: HUDTextStyle;\n\n\t/** Custom layout positions */\n\tlayout?: HUDLayout;\n\n\t/** Key in state where players are stored (default: 'players') */\n\tplayersKey?: string;\n}\n\nexport interface PlayerHUD {\n\t/** Update HUD (automatically called when player changes) */\n\tupdate: () => void;\n\t/** Destroy HUD elements */\n\tdestroy: () => void;\n\t/** Get title text object */\n\tgetTitleText: () => Phaser.GameObjects.Text | null;\n\t/** Get role text object */\n\tgetRoleText: () => Phaser.GameObjects.Text | null;\n\t/** Get controls text object */\n\tgetControlsText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a player HUD with automatic role/control updates\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - HUD configuration\n * @returns PlayerHUD instance\n */\nexport function createPlayerHUD<TPlayer = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: PlayerHUDConfig<TPlayer>\n): PlayerHUD {\n\tconst playersKey = config.playersKey || 'players';\n\n\t// Default layout\n\tconst layout = {\n\t\ttitle: config.layout?.title || { x: 400, y: 20 },\n\t\trole: config.layout?.role || { x: 400, y: 50 },\n\t\tcontrols: config.layout?.controls || { x: 400, y: 75 }\n\t};\n\n\t// Default styles\n\tconst titleStyle = {\n\t\tfontSize: config.titleStyle?.fontSize || '24px',\n\t\tcolor: config.titleStyle?.color || '#000',\n\t\tfontStyle: config.titleStyle?.fontStyle || 'bold',\n\t\tbackgroundColor: config.titleStyle?.backgroundColor,\n\t\tpadding: config.titleStyle?.padding\n\t};\n\n\tconst roleStyle = {\n\t\tfontSize: config.roleStyle?.fontSize || '16px',\n\t\tcolor: config.roleStyle?.color || '#000',\n\t\tfontStyle: config.roleStyle?.fontStyle,\n\t\tbackgroundColor: config.roleStyle?.backgroundColor,\n\t\tpadding: config.roleStyle?.padding\n\t};\n\n\tconst controlsStyle = {\n\t\tfontSize: config.controlsStyle?.fontSize || '14px',\n\t\tcolor: config.controlsStyle?.color || '#333',\n\t\tfontStyle: config.controlsStyle?.fontStyle,\n\t\tbackgroundColor: config.controlsStyle?.backgroundColor,\n\t\tpadding: config.controlsStyle?.padding\n\t};\n\n\t// Create text objects\n\tlet titleText: Phaser.GameObjects.Text | null = null;\n\tlet roleText: Phaser.GameObjects.Text | null = null;\n\tlet controlsText: Phaser.GameObjects.Text | null = null;\n\n\t// Create title (static)\n\tif (config.title) {\n\t\ttitleText = scene.add.text(layout.title.x, layout.title.y, config.title, titleStyle);\n\t\ttitleText.setOrigin(0.5);\n\t}\n\n\t// Create role text (dynamic)\n\tif (config.roleText) {\n\t\troleText = scene.add.text(layout.role.x, layout.role.y, 'Loading...', roleStyle);\n\t\troleText.setOrigin(0.5);\n\t}\n\n\t// Create controls text (dynamic)\n\tif (config.controlHints) {\n\t\tcontrolsText = scene.add.text(layout.controls.x, layout.controls.y, '', controlsStyle);\n\t\tcontrolsText.setOrigin(0.5);\n\t}\n\n\t// Update function\n\tconst update = () => {\n\t\tconst state = adapter.getState();\n\t\tconst myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n\t\tif (roleText && config.roleText) {\n\t\t\troleText.setText(config.roleText(myPlayer, state));\n\t\t}\n\n\t\tif (controlsText && config.controlHints) {\n\t\t\tcontrolsText.setText(config.controlHints(myPlayer, state));\n\t\t}\n\t};\n\n\t// Subscribe to state changes to reactively update HUD\n\t// Uses onChange instead of watchMyPlayer to get full state access\n\tconst unsubscribers: Array<() => void> = [];\n\n\t// Track last values to avoid unnecessary updates\n\tlet lastRoleText: string | undefined;\n\tlet lastControlsText: string | undefined;\n\n\t// Watch roleText changes (reactive to both player and state changes)\n\tif (roleText && config.roleText) {\n\t\tconst unsubscribe = adapter.onChange((state: any) => {\n\t\t\tconst players = state?.[playersKey];\n\t\t\tconst myPlayer = players ? players[adapter.getMyPlayerId()] : undefined;\n\t\t\tconst text = config.roleText!(myPlayer, state);\n\n\t\t\t// Only update if text changed\n\t\t\tif (text !== lastRoleText) {\n\t\t\t\tlastRoleText = text;\n\t\t\t\troleText.setText(text);\n\t\t\t}\n\t\t});\n\t\tunsubscribers.push(unsubscribe);\n\n\t\t// Initial update\n\t\tconst initialState = adapter.getState();\n\t\tconst initialPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\t\tlastRoleText = config.roleText(initialPlayer, initialState);\n\t\troleText.setText(lastRoleText);\n\t}\n\n\t// Watch controlHints changes (reactive to both player and state changes)\n\tif (controlsText && config.controlHints) {\n\t\tconst unsubscribe = adapter.onChange((state: any) => {\n\t\t\tconst players = state?.[playersKey];\n\t\t\tconst myPlayer = players ? players[adapter.getMyPlayerId()] : undefined;\n\t\t\tconst text = config.controlHints!(myPlayer, state);\n\n\t\t\t// Only update if text changed\n\t\t\tif (text !== lastControlsText) {\n\t\t\t\tlastControlsText = text;\n\t\t\t\tcontrolsText.setText(text);\n\t\t\t}\n\t\t});\n\t\tunsubscribers.push(unsubscribe);\n\n\t\t// Initial update\n\t\tconst initialState = adapter.getState();\n\t\tconst initialPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\t\tlastControlsText = config.controlHints(initialPlayer, initialState);\n\t\tcontrolsText.setText(lastControlsText);\n\t}\n\n\t// Return HUD interface\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\t// Unsubscribe from all watchers\n\t\t\tunsubscribers.forEach((unsub) => unsub());\n\t\t\ttitleText?.destroy();\n\t\t\troleText?.destroy();\n\t\t\tcontrolsText?.destroy();\n\t\t},\n\t\tgetTitleText: () => titleText,\n\t\tgetRoleText: () => roleText,\n\t\tgetControlsText: () => controlsText\n\t};\n}\n", "/**\n * PlayerStatsPanel - Display current player's stats/powerups overlay\n *\n * Eliminates the boilerplate of manually tracking and displaying player stats.\n * Perfect for showing equipped powerups, abilities, ammo, inventory, etc.\n *\n * Features:\n * - Auto-reactive to player stat changes\n * - Smart positioning (corners, custom coords)\n * - Icon-based display with optional tooltips\n * - Conditional visibility and highlighting\n * - Type-safe player property access\n *\n * @example\n * ```ts\n * import { createPlayerStatsPanel } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.statsPanel = createPlayerStatsPanel(this.adapter, this, {\n *   position: 'top-left',\n *   stats: {\n *     bombs: {\n *       icon: '\uD83D\uDCA3',\n *       getValue: (player) => `${player.activeBombs}/${player.bombCount}`,\n *       tooltip: 'Bombs (current/max)'\n *     },\n *     speed: {\n *       icon: '\u26A1',\n *       getValue: (player) => `${Math.round(player.speed * 100)}%`,\n *       highlight: (player) => player.speed > 1.0\n *     }\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport type StatPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | { x: number; y: number };\n\nexport interface StatConfig<TPlayer = any> {\n\t/** Icon/emoji to display */\n\ticon: string;\n\n\t/**\n\t * Get the value to display next to the icon\n\t * @param player - Current player data\n\t * @returns String to display (e.g., \"3/5\", \"120%\", \"\u2713\")\n\t */\n\tgetValue: (player: TPlayer) => string | number;\n\n\t/**\n\t * Optional tooltip text (for accessibility/clarity)\n\t */\n\ttooltip?: string;\n\n\t/**\n\t * Show this stat only when condition is true\n\t * Useful for abilities that are only visible when active\n\t */\n\tvisible?: (player: TPlayer) => boolean;\n\n\t/**\n\t * Highlight this stat when condition is true (e.g., boosted)\n\t * Adds a glow/color effect\n\t */\n\thighlight?: (player: TPlayer) => boolean;\n}\n\nexport interface PlayerStatsPanelConfig<TPlayer = any> {\n\t/**\n\t * Position of the stats panel\n\t * - 'top-left', 'top-right', 'bottom-left', 'bottom-right'\n\t * - Or custom {x, y} coordinates\n\t */\n\tposition: StatPosition;\n\n\t/**\n\t * Stats to display, keyed by stat name\n\t */\n\tstats: Record<string, StatConfig<TPlayer>>;\n\n\t/**\n\t * Optional styling\n\t */\n\tstyle?: {\n\t\t/** Background color (CSS format) */\n\t\tbackgroundColor?: string;\n\t\t/** Padding around content */\n\t\tpadding?: number;\n\t\t/** Icon font size */\n\t\ticonSize?: number;\n\t\t/** Value text font size */\n\t\tfontSize?: string;\n\t\t/** Spacing between stat items */\n\t\tspacing?: number;\n\t\t/** Highlight color when stat.highlight() returns true */\n\t\thighlightColor?: string;\n\t};\n\n\t/**\n\t * Key in state where players are stored (default: 'players')\n\t */\n\tplayersKey?: string;\n}\n\nexport interface PlayerStatsPanel {\n\t/** Update panel (automatically called when player changes) */\n\tupdate: () => void;\n\t/** Destroy panel elements */\n\tdestroy: () => void;\n\t/** Get container game object */\n\tgetContainer: () => Phaser.GameObjects.Container | null;\n}\n\n/**\n * Create a player stats panel for displaying current player's stats/powerups\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Panel configuration\n * @returns PlayerStatsPanel instance\n */\nexport function createPlayerStatsPanel<TPlayer = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: PlayerStatsPanelConfig<TPlayer>\n): PlayerStatsPanel {\n\tconst playersKey = config.playersKey || 'players';\n\n\t// Default styling\n\tconst style = {\n\t\tbackgroundColor: config.style?.backgroundColor || 'rgba(0, 0, 0, 0.7)',\n\t\tpadding: config.style?.padding ?? 8,\n\t\ticonSize: config.style?.iconSize ?? 24,\n\t\tfontSize: config.style?.fontSize || '16px',\n\t\tspacing: config.style?.spacing ?? 6,\n\t\thighlightColor: config.style?.highlightColor || '#fbbf24'\n\t};\n\n\t// Calculate position\n\tconst getPosition = (): { x: number; y: number } => {\n\t\tif (typeof config.position === 'object' && 'x' in config.position) {\n\t\t\treturn config.position;\n\t\t}\n\n\t\tconst camera = scene.cameras.main;\n\t\tconst padding = 20;\n\n\t\tswitch (config.position) {\n\t\t\tcase 'top-left':\n\t\t\t\treturn { x: padding, y: padding };\n\t\t\tcase 'top-right':\n\t\t\t\treturn { x: camera.width - padding, y: padding };\n\t\t\tcase 'bottom-left':\n\t\t\t\treturn { x: padding, y: camera.height - padding };\n\t\t\tcase 'bottom-right':\n\t\t\t\treturn { x: camera.width - padding, y: camera.height - padding };\n\t\t\tdefault:\n\t\t\t\treturn { x: padding, y: padding };\n\t\t}\n\t};\n\n\tconst pos = getPosition();\n\n\t// Create container\n\tconst container = scene.add.container(pos.x, pos.y);\n\n\t// Background (will be sized dynamically)\n\tconst background = scene.add.rectangle(0, 0, 100, 100, 0x000000, 0.7);\n\tcontainer.add(background);\n\n\t// Track stat elements\n\tconst statElements: Map<\n\t\tstring,\n\t\t{\n\t\t\ticonText: Phaser.GameObjects.Text;\n\t\t\tvalueText: Phaser.GameObjects.Text;\n\t\t\thighlight?: Phaser.GameObjects.Rectangle;\n\t\t}\n\t> = new Map();\n\n\t// Update function\n\tconst update = () => {\n\t\tconst state = adapter.getState();\n\t\tconst myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n\t\tif (!myPlayer) {\n\t\t\t// Hide panel if no player\n\t\t\tcontainer.setVisible(false);\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.setVisible(true);\n\n\t\t// Calculate layout\n\t\tlet currentY = style.padding;\n\t\tlet maxWidth = 0;\n\t\tconst visibleStats: Array<[string, StatConfig<TPlayer>]> = [];\n\n\t\t// First pass: determine visible stats\n\t\tfor (const [statName, statConfig] of Object.entries(config.stats)) {\n\t\t\tif (statConfig.visible && !statConfig.visible(myPlayer)) {\n\t\t\t\t// Hide this stat\n\t\t\t\tconst element = statElements.get(statName);\n\t\t\t\tif (element) {\n\t\t\t\t\telement.iconText.setVisible(false);\n\t\t\t\t\telement.valueText.setVisible(false);\n\t\t\t\t\telement.highlight?.setVisible(false);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvisibleStats.push([statName, statConfig]);\n\t\t}\n\n\t\t// Second pass: create/update visible stats\n\t\tfor (const [statName, statConfig] of visibleStats) {\n\t\t\tlet element = statElements.get(statName);\n\n\t\t\tif (!element) {\n\t\t\t\t// Create new stat element\n\t\t\t\tconst iconText = scene.add.text(style.padding, currentY, statConfig.icon, {\n\t\t\t\t\tfontSize: `${style.iconSize}px`\n\t\t\t\t});\n\n\t\t\t\tconst valueText = scene.add.text(\n\t\t\t\t\tstyle.padding + style.iconSize + 4,\n\t\t\t\t\tcurrentY,\n\t\t\t\t\tString(statConfig.getValue(myPlayer)),\n\t\t\t\t\t{\n\t\t\t\t\t\tfontSize: style.fontSize,\n\t\t\t\t\t\tcolor: '#ffffff'\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Highlight rectangle (behind text, shown conditionally)\n\t\t\t\tconst highlight = scene.add.rectangle(\n\t\t\t\t\t0,\n\t\t\t\t\tcurrentY + style.iconSize / 2,\n\t\t\t\t\t0,\n\t\t\t\t\tstyle.iconSize + 4,\n\t\t\t\t\tparseInt(style.highlightColor.replace('#', '0x'), 16),\n\t\t\t\t\t0.3\n\t\t\t\t);\n\t\t\t\thighlight.setOrigin(0, 0.5);\n\t\t\t\thighlight.setVisible(false);\n\n\t\t\t\tcontainer.add([highlight, iconText, valueText]);\n\n\t\t\t\telement = { iconText, valueText, highlight };\n\t\t\t\tstatElements.set(statName, element);\n\t\t\t}\n\n\t\t\t// Update text\n\t\t\telement.iconText.setText(statConfig.icon);\n\t\t\telement.valueText.setText(String(statConfig.getValue(myPlayer)));\n\n\t\t\t// Update visibility\n\t\t\telement.iconText.setVisible(true);\n\t\t\telement.valueText.setVisible(true);\n\n\t\t\t// Update position\n\t\t\telement.iconText.setPosition(style.padding, currentY);\n\t\t\telement.valueText.setPosition(style.padding + style.iconSize + 4, currentY);\n\n\t\t\t// Update highlight\n\t\t\tconst shouldHighlight = statConfig.highlight ? statConfig.highlight(myPlayer) : false;\n\t\t\tif (element.highlight) {\n\t\t\t\telement.highlight.setVisible(shouldHighlight);\n\t\t\t\telement.highlight.setPosition(style.padding - 2, currentY + style.iconSize / 2);\n\t\t\t\tconst textWidth = element.valueText.width;\n\t\t\t\telement.highlight.width = style.iconSize + 4 + textWidth + 4;\n\t\t\t}\n\n\t\t\t// Track max width\n\t\t\tconst elementWidth = style.iconSize + 4 + element.valueText.width;\n\t\t\tmaxWidth = Math.max(maxWidth, elementWidth);\n\n\t\t\tcurrentY += style.iconSize + style.spacing;\n\t\t}\n\n\t\t// Size background\n\t\tconst bgWidth = maxWidth + style.padding * 2;\n\t\tconst bgHeight = currentY - style.spacing + style.padding;\n\t\tbackground.setSize(bgWidth, bgHeight);\n\n\t\t// Adjust container origin based on position\n\t\tif (config.position === 'top-right' || config.position === 'bottom-right') {\n\t\t\tbackground.setOrigin(1, 0);\n\t\t\tcontainer.x = pos.x;\n\t\t} else {\n\t\t\tbackground.setOrigin(0, 0);\n\t\t}\n\t};\n\n\t// Subscribe to state changes\n\tconst unsubscribe = adapter.onChange(() => {\n\t\tupdate();\n\t});\n\n\t// Initial update\n\tupdate();\n\n\t// Return interface\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\tunsubscribe();\n\t\t\tcontainer.destroy();\n\t\t},\n\t\tgetContainer: () => container\n\t};\n}\n", "/**\n * CollectibleManager - Automatic collectible collision detection & visual feedback\n *\n * Eliminates common bugs in collectible/powerup systems:\n * - Forgetting isHost() checks \u2192 desync bugs\n * - Manual coordinate transformations\n * - No built-in visual feedback\n * - Each game reimplements the same collision logic\n *\n * Features:\n * - Automatic host-only collision detection (prevents desyncs!)\n * - Supports grid-based and continuous coordinate spaces\n * - Built-in visual feedback (particles, sounds, popups)\n * - Type-safe configuration\n *\n * @example\n * ```ts\n * import { createCollectibleManager } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.collectibles = createCollectibleManager(this.adapter, this, {\n *   powerup: {\n *     stateKey: 'powerups',\n *     collectAction: 'collectPowerup',\n *     \n *     getPosition: (item) => ({\n *       x: item.x * TILE_SIZE + TILE_SIZE / 2,\n *       y: item.y * TILE_SIZE + TILE_SIZE / 2\n *     }),\n *     \n *     radius: 20,\n *     collisionType: 'grid', // or 'continuous'\n *     \n *     onCollect: (item) => ({\n *       popup: `+${item.type.toUpperCase()}!`,\n *       sound: 'pickup'\n *     })\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini-kit/core';\n\nexport type CollisionType = 'grid' | 'continuous';\n\nexport interface CollectibleConfig<TItem = any, TPlayer = any> {\n\t/**\n\t * Key in state where collectibles are stored\n\t * e.g., 'powerups', 'coins', 'items'\n\t */\n\tstateKey: string;\n\n\t/**\n\t * Action name to submit when collectible is collected\n\t * e.g., 'collectPowerup', 'collectCoin'\n\t */\n\tcollectAction: string;\n\n\t/**\n\t * Get world position of collectible\n\t * For grid-based, convert grid coords to world coords\n\t */\n\tgetPosition: (item: TItem) => { x: number; y: number };\n\n\t/**\n\t * Collision radius in world units\n\t */\n\tradius: number;\n\n\t/**\n\t * Collision type\n\t * - 'grid': Snap positions to grid, exact cell match\n\t * - 'continuous': Use radius-based collision in continuous space\n\t */\n\tcollisionType?: CollisionType;\n\n\t/**\n\t * Optional: Get player position (defaults to player.x, player.y)\n\t */\n\tgetPlayerPosition?: (player: TPlayer) => { x: number; y: number };\n\n\t/**\n\t * Optional: Visual feedback when collected\n\t */\n\tonCollect?: (item: TItem, scene: Phaser.Scene) => {\n\t\t/** Popup text to show (e.g., \"+BOMB!\") */\n\t\tpopup?: string;\n\t\t/** Sound key to play */\n\t\tsound?: string;\n\t\t/** Particle effect key */\n\t\tparticle?: string;\n\t} | void;\n\n\t/**\n\t * Optional: ID field name (default: 'id')\n\t */\n\tidField?: string;\n}\n\nexport interface CollectibleManagerConfig {\n\t/**\n\t * Collectible types to manage\n\t * Key is a friendly name, value is the config\n\t */\n\t[collectibleType: string]: CollectibleConfig;\n}\n\nexport interface CollectibleManager {\n\t/** Update collision detection (automatically called in adapter.update) */\n\tupdate: () => void;\n\t/** Manually trigger collection (for testing) */\n\tcollect: (collectibleType: string, itemId: any) => void;\n\t/** Destroy manager */\n\tdestroy: () => void;\n}\n\n/**\n * Create a collectible manager with automatic host-only collision detection\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Collectible configurations\n * @returns CollectibleManager instance\n */\nexport function createCollectibleManager(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: CollectibleManagerConfig\n): CollectibleManager {\n\tconst runtime = adapter.getRuntime();\n\tlet unsubscribe: (() => void) | undefined;\n\n\t/**\n\t * Check collision between player and collectible\n\t */\n\tconst checkCollision = (\n\t\tplayerPos: { x: number; y: number },\n\t\titemPos: { x: number; y: number },\n\t\tradius: number,\n\t\tcollisionType: CollisionType\n\t): boolean => {\n\t\tif (collisionType === 'grid') {\n\t\t\t// Grid-based: exact cell match (with rounding)\n\t\t\tconst playerGridX = Math.round(playerPos.x / radius);\n\t\t\tconst playerGridY = Math.round(playerPos.y / radius);\n\t\t\tconst itemGridX = Math.round(itemPos.x / radius);\n\t\t\tconst itemGridY = Math.round(itemPos.y / radius);\n\n\t\t\treturn playerGridX === itemGridX && playerGridY === itemGridY;\n\t\t} else {\n\t\t\t// Continuous: radius-based collision\n\t\t\tconst dx = playerPos.x - itemPos.x;\n\t\t\tconst dy = playerPos.y - itemPos.y;\n\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\treturn distance < radius;\n\t\t}\n\t};\n\n\t/**\n\t * Show visual feedback\n\t */\n\tconst showFeedback = (\n\t\titemPos: { x: number; y: number },\n\t\tfeedback: { popup?: string; sound?: string; particle?: string }\n\t) => {\n\t\t// Popup text\n\t\tif (feedback.popup) {\n\t\t\tconst text = scene.add.text(itemPos.x, itemPos.y - 20, feedback.popup, {\n\t\t\t\tfontSize: '16px',\n\t\t\t\tcolor: '#fbbf24',\n\t\t\t\tfontStyle: 'bold',\n\t\t\t\tstroke: '#000',\n\t\t\t\tstrokeThickness: 3\n\t\t\t});\n\t\t\ttext.setOrigin(0.5);\n\n\t\t\t// Animate up and fade out\n\t\t\tscene.tweens.add({\n\t\t\t\ttargets: text,\n\t\t\t\ty: itemPos.y - 50,\n\t\t\t\talpha: 0,\n\t\t\t\tduration: 800,\n\t\t\t\tease: 'Cubic.easeOut',\n\t\t\t\tonComplete: () => text.destroy()\n\t\t\t});\n\t\t}\n\n\t\t// Sound\n\t\tif (feedback.sound && scene.sound) {\n\t\t\ttry {\n\t\t\t\tscene.sound.play(feedback.sound);\n\t\t\t} catch (e) {\n\t\t\t\t// Sound not loaded, ignore\n\t\t\t}\n\t\t}\n\n\t\t// Particles (simple implementation)\n\t\tif (feedback.particle) {\n\t\t\t// Create simple particle effect using graphics\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst angle = (i / 8) * Math.PI * 2;\n\t\t\t\tconst speed = 50 + Math.random() * 50;\n\t\t\t\tconst vx = Math.cos(angle) * speed;\n\t\t\t\tconst vy = Math.sin(angle) * speed;\n\n\t\t\t\tconst particle = scene.add.circle(itemPos.x, itemPos.y, 3, 0xfbbf24);\n\t\t\t\tscene.tweens.add({\n\t\t\t\t\ttargets: particle,\n\t\t\t\t\tx: itemPos.x + vx,\n\t\t\t\t\ty: itemPos.y + vy,\n\t\t\t\t\talpha: 0,\n\t\t\t\t\tscale: 0,\n\t\t\t\t\tduration: 400,\n\t\t\t\t\tease: 'Cubic.easeOut',\n\t\t\t\t\tonComplete: () => particle.destroy()\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Main update function - checks collisions for current player\n\t * IMPORTANT: Only runs on HOST to prevent desyncs!\n\t */\n\tconst update = () => {\n\t\t// \u2705 AUTOMATIC HOST-ONLY CHECK - prevents desync bugs!\n\t\tif (!adapter.isHost()) return;\n\n\t\tconst state = runtime.getState();\n\t\tconst myPlayerId = runtime.getMyPlayerId();\n\t\tconst myPlayer = state.players?.[myPlayerId];\n\n\t\tif (!myPlayer) return;\n\n\t\t// Check each collectible type\n\t\tfor (const [collectibleType, collectibleConfig] of Object.entries(config)) {\n\t\t\tconst items = state[collectibleConfig.stateKey];\n\t\t\tif (!Array.isArray(items)) continue;\n\n\t\t\tconst idField = collectibleConfig.idField || 'id';\n\t\t\tconst playerPos = collectibleConfig.getPlayerPosition\n\t\t\t\t? collectibleConfig.getPlayerPosition(myPlayer)\n\t\t\t\t: { x: myPlayer.x, y: myPlayer.y };\n\n\t\t\t// Check collision with each item\n\t\t\tfor (const item of items) {\n\t\t\t\tconst itemPos = collectibleConfig.getPosition(item);\n\t\t\t\tconst collisionType = collectibleConfig.collisionType || 'continuous';\n\n\t\t\t\tif (checkCollision(playerPos, itemPos, collectibleConfig.radius, collisionType)) {\n\t\t\t\t\t// Collision detected! Submit action\n\t\t\t\t\tconst itemId = item[idField];\n\n\t\t\t\t\t// Show visual feedback (client-side)\n\t\t\t\t\tconst feedback = collectibleConfig.onCollect?.(item, scene);\n\t\t\t\t\tif (feedback) {\n\t\t\t\t\t\tshowFeedback(itemPos, feedback);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Submit action (server authoritative)\n\t\t\t\t\truntime.submitAction(collectibleConfig.collectAction, { [idField]: itemId });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Manual collection trigger (for testing/buttons)\n\t */\n\tconst collect = (collectibleType: string, itemId: any) => {\n\t\tconst collectibleConfig = config[collectibleType];\n\t\tif (!collectibleConfig) {\n\t\t\tconsole.warn(`Unknown collectible type: ${collectibleType}`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst idField = collectibleConfig.idField || 'id';\n\t\truntime.submitAction(collectibleConfig.collectAction, { [idField]: itemId });\n\t};\n\n\t/**\n\t * Auto-update on state changes (optional optimization)\n\t * We could also let the scene call update() manually\n\t */\n\t// unsubscribe = adapter.onChange(() => {\n\t//   update();\n\t// });\n\n\treturn {\n\t\tupdate,\n\t\tcollect,\n\t\tdestroy: () => {\n\t\t\tunsubscribe?.();\n\t\t}\n\t};\n}\n", "/**\n * RoundManager - Complete round-based game system with timer, announcements, and scoring\n *\n * Eliminates 200+ lines of boilerplate for round-based games.\n * Perfect for fighting games, battle royales, sports games, etc.\n *\n * Features:\n * - Round timer with visual warnings\n * - Automatic round end detection\n * - Freeze frames and announcements between rounds\n * - Score tracking UI\n * - Match winner detection\n * - Customizable UI and flow\n *\n * @example\n * ```ts\n * import { createRoundManager } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.rounds = createRoundManager(this.adapter, this, {\n *   roundsToWin: 3,\n *   \n *   // State keys\n *   timerStateKey: 'roundTimer',\n *   roundStateKey: 'round',\n *   \n *   // Win detection\n *   checkWinner: (state) => {\n *     const alive = Object.entries(state.players).filter(([, p]) => p.alive);\n *     if (alive.length === 1) return alive[0][0];\n *     if (state.roundTimer <= 0) return null; // Draw\n *     return undefined; // Continue\n *   },\n *   \n *   ui: {\n *     timer: {\n *       position: { x: 400, y: 50 },\n *       format: (ms) => `${Math.ceil(ms / 1000)}s`,\n *       warningAt: 30000\n *     }\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TimerUIConfig {\n\t/** Position of timer display */\n\tposition: { x: number; y: number };\n\n\t/**\n\t * Format timer value for display\n\t * @param milliseconds - Time remaining in milliseconds\n\t * @returns Formatted string (e.g., \"1:23\", \"90s\")\n\t */\n\tformat: (milliseconds: number) => string;\n\n\t/**\n\t * Show warning color when time is below this threshold (ms)\n\t * Default: 30000 (30 seconds)\n\t */\n\twarningAt?: number;\n\n\t/** Style for timer text */\n\tstyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n\t/** Warning style (overrides style when warning) */\n\twarningStyle?: Phaser.Types.GameObjects.Text.TextStyle;\n}\n\nexport interface AnnouncementUIConfig<TPlayer = any> {\n\t/**\n\t * Get announcement text when a player wins the round\n\t */\n\twinner: (player: TPlayer, winnerId: string) => string;\n\n\t/**\n\t * Get announcement text when round ends in a draw\n\t */\n\tdraw: () => string;\n\n\t/**\n\t * Get announcement text when a player wins the match\n\t */\n\tmatchWin: (player: TPlayer, winnerId: string) => string;\n\n\t/**\n\t * Duration to show announcement (ms)\n\t * Default: 3000\n\t */\n\tfreezeDuration?: number;\n\n\t/**\n\t * Position of announcement\n\t * Default: center of screen\n\t */\n\tposition?: { x: number; y: number };\n\n\t/** Style for announcement text */\n\tstyle?: Phaser.Types.GameObjects.Text.TextStyle;\n}\n\nexport interface ScoreboardUIConfig<TPlayer = any> {\n\t/** Position of scoreboard */\n\tposition: { x: number; y: number };\n\n\t/**\n\t * Format score display for each player\n\t * @param player - Player data\n\t * @param index - Player index\n\t * @param playerId - Player ID\n\t * @returns Formatted string\n\t */\n\tformat: (player: TPlayer, index: number, playerId: string) => string;\n\n\t/** Style for score text */\n\tstyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n\t/** Spacing between score lines */\n\tspacing?: number;\n}\n\nexport interface RoundManagerConfig<TPlayer = any, TState = any> {\n\t/**\n\t * Number of rounds to win the match\n\t */\n\troundsToWin: number;\n\n\t/**\n\t * State key where round timer is stored (in milliseconds)\n\t * Default: 'roundTimer'\n\t */\n\ttimerStateKey?: string;\n\n\t/**\n\t * State key where current round number is stored\n\t * Default: 'round'\n\t */\n\troundStateKey?: string;\n\n\t/**\n\t * State key where players are stored\n\t * Default: 'players'\n\t */\n\tplayersKey?: string;\n\n\t/**\n\t * State key where game over flag is stored\n\t * Default: 'gameOver'\n\t */\n\tgameOverKey?: string;\n\n\t/**\n\t * State key where winner ID is stored\n\t * Default: 'winner'\n\t */\n\twinnerKey?: string;\n\n\t/**\n\t * Check if round should end and determine winner\n\t * @param state - Full game state\n\t * @returns winnerId (string), null (draw), or undefined (continue playing)\n\t */\n\tcheckWinner: (state: TState) => string | null | undefined;\n\n\t/**\n\t * UI configuration\n\t */\n\tui: {\n\t\t/** Timer display config */\n\t\ttimer?: TimerUIConfig;\n\n\t\t/** Announcement config */\n\t\tannouncement?: AnnouncementUIConfig<TPlayer>;\n\n\t\t/** Scoreboard config */\n\t\tscoreboard?: ScoreboardUIConfig<TPlayer>;\n\t};\n}\n\nexport interface RoundManager {\n\t/** Update UI (automatically called on state changes) */\n\tupdate: () => void;\n\t/** Destroy UI elements */\n\tdestroy: () => void;\n\t/** Get timer text object */\n\tgetTimerText: () => Phaser.GameObjects.Text | null;\n\t/** Get announcement text object */\n\tgetAnnouncementText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a round manager with timer, announcements, and scoring\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Round manager configuration\n * @returns RoundManager instance\n */\nexport function createRoundManager<TPlayer = any, TState = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: RoundManagerConfig<TPlayer, TState>\n): RoundManager {\n\tconst runtime = adapter.getRuntime();\n\n\t// State keys\n\tconst timerKey = config.timerStateKey || 'roundTimer';\n\tconst roundKey = config.roundStateKey || 'round';\n\tconst playersKey = config.playersKey || 'players';\n\tconst gameOverKey = config.gameOverKey || 'gameOver';\n\tconst winnerKey = config.winnerKey || 'winner';\n\n\t// UI elements\n\tlet timerText: Phaser.GameObjects.Text | null = null;\n\tlet announcementText: Phaser.GameObjects.Text | null = null;\n\tconst scoreTexts: Phaser.GameObjects.Text[] = [];\n\n\t// Create timer UI\n\tif (config.ui.timer) {\n\t\tconst timerConfig = config.ui.timer;\n\t\tconst defaultStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n\t\t\tfontSize: '24px',\n\t\t\tcolor: '#ffffff',\n\t\t\tfontStyle: 'bold',\n\t\t\t...timerConfig.style\n\t\t};\n\n\t\ttimerText = scene.add.text(\n\t\t\ttimerConfig.position.x,\n\t\t\ttimerConfig.position.y,\n\t\t\t'',\n\t\t\tdefaultStyle\n\t\t);\n\t\ttimerText.setOrigin(0.5);\n\t}\n\n\t// Create announcement UI (hidden initially)\n\tif (config.ui.announcement) {\n\t\tconst announcementConfig = config.ui.announcement;\n\t\tconst camera = scene.cameras.main;\n\t\tconst pos = announcementConfig.position || { x: camera.width / 2, y: camera.height / 2 };\n\n\t\tconst defaultStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n\t\t\tfontSize: '48px',\n\t\t\tcolor: '#fbbf24',\n\t\t\tfontStyle: 'bold',\n\t\t\tstroke: '#000',\n\t\t\tstrokeThickness: 6,\n\t\t\t...announcementConfig.style\n\t\t};\n\n\t\tannouncementText = scene.add.text(pos.x, pos.y, '', defaultStyle);\n\t\tannouncementText.setOrigin(0.5);\n\t\tannouncementText.setVisible(false);\n\t\tannouncementText.setDepth(1000); // Always on top\n\t}\n\n\t// Freeze state\n\tlet isFrozen = false;\n\tlet freezeTimer = 0;\n\n\t/**\n\t * Show announcement and freeze gameplay\n\t */\n\tconst showAnnouncement = (text: string, duration: number) => {\n\t\tif (!announcementText) return;\n\n\t\tannouncementText.setText(text);\n\t\tannouncementText.setVisible(true);\n\n\t\t// Fade in\n\t\tannouncementText.setAlpha(0);\n\t\tscene.tweens.add({\n\t\t\ttargets: announcementText,\n\t\t\talpha: 1,\n\t\t\tduration: 200,\n\t\t\tease: 'Cubic.easeOut'\n\t\t});\n\n\t\t// Freeze gameplay\n\t\tisFrozen = true;\n\t\tfreezeTimer = duration;\n\n\t\t// Auto-hide after duration\n\t\tscene.time.delayedCall(duration, () => {\n\t\t\tif (!announcementText) return;\n\n\t\t\t// Fade out\n\t\t\tscene.tweens.add({\n\t\t\t\ttargets: announcementText,\n\t\t\t\talpha: 0,\n\t\t\t\tduration: 300,\n\t\t\t\tease: 'Cubic.easeIn',\n\t\t\t\tonComplete: () => {\n\t\t\t\t\tannouncementText?.setVisible(false);\n\t\t\t\t\tisFrozen = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * Update all UI elements\n\t */\n\tconst update = () => {\n\t\tconst state = runtime.getState() as any;\n\n\t\t// Update timer\n\t\tif (timerText && config.ui.timer) {\n\t\t\tconst timerValue = state[timerKey] || 0;\n\t\t\tconst formatted = config.ui.timer.format(timerValue);\n\t\t\ttimerText.setText(formatted);\n\n\t\t\t// Apply warning style\n\t\t\tconst warningAt = config.ui.timer.warningAt ?? 30000;\n\t\t\tif (timerValue <= warningAt && config.ui.timer.warningStyle) {\n\t\t\t\ttimerText.setStyle(config.ui.timer.warningStyle);\n\t\t\t} else if (config.ui.timer.style) {\n\t\t\t\ttimerText.setStyle(config.ui.timer.style);\n\t\t\t}\n\t\t}\n\n\t\t// Update scoreboard\n\t\tif (config.ui.scoreboard) {\n\t\t\tconst scoreConfig = config.ui.scoreboard;\n\t\t\tconst players = state[playersKey] || {};\n\t\t\tconst playerEntries = Object.entries(players) as [string, TPlayer][];\n\n\t\t\t// Remove old score texts\n\t\t\tscoreTexts.forEach((text) => text.destroy());\n\t\t\tscoreTexts.length = 0;\n\n\t\t\t// Create new score texts\n\t\t\tlet yOffset = 0;\n\t\t\tconst spacing = scoreConfig.spacing ?? 25;\n\n\t\t\tplayerEntries.forEach(([playerId, player], index) => {\n\t\t\t\tconst text = scene.add.text(\n\t\t\t\t\tscoreConfig.position.x,\n\t\t\t\t\tscoreConfig.position.y + yOffset,\n\t\t\t\t\tscoreConfig.format(player, index, playerId),\n\t\t\t\t\tscoreConfig.style || { fontSize: '16px', color: '#ffffff' }\n\t\t\t\t);\n\n\t\t\t\tscoreTexts.push(text);\n\t\t\t\tyOffset += spacing;\n\t\t\t});\n\t\t}\n\n\t\t// Check for round end (host only)\n\t\tif (adapter.isHost() && !isFrozen && !state[gameOverKey]) {\n\t\t\tconst winnerId = config.checkWinner(state);\n\n\t\t\tif (winnerId !== undefined) {\n\t\t\t\t// Round ended!\n\t\t\t\tconst players = state[playersKey] || {};\n\n\t\t\t\tif (winnerId === null) {\n\t\t\t\t\t// Draw\n\t\t\t\t\tif (config.ui.announcement) {\n\t\t\t\t\t\tconst text = config.ui.announcement.draw();\n\t\t\t\t\t\tconst duration = config.ui.announcement.freezeDuration ?? 3000;\n\t\t\t\t\t\tshowAnnouncement(text, duration);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Submit endRound action with null winner\n\t\t\t\t\truntime.submitAction('endRound', { winnerId: null });\n\t\t\t\t} else {\n\t\t\t\t\t// Player won\n\t\t\t\t\tconst winner = players[winnerId];\n\n\t\t\t\t\t// Check for match win\n\t\t\t\t\tconst score = (winner as any).score || 0;\n\t\t\t\t\tconst isMatchWin = score + 1 >= config.roundsToWin;\n\n\t\t\t\t\tif (config.ui.announcement) {\n\t\t\t\t\t\tconst text = isMatchWin\n\t\t\t\t\t\t\t? config.ui.announcement.matchWin(winner, winnerId)\n\t\t\t\t\t\t\t: config.ui.announcement.winner(winner, winnerId);\n\t\t\t\t\t\tconst duration = config.ui.announcement.freezeDuration ?? 3000;\n\t\t\t\t\t\tshowAnnouncement(text, duration);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Submit endRound action\n\t\t\t\t\truntime.submitAction('endRound', { winnerId });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Show game over announcement\n\t\tif (state[gameOverKey] && state[winnerKey]) {\n\t\t\tconst players = state[playersKey] || {};\n\t\t\tconst winner = players[state[winnerKey]];\n\n\t\t\tif (winner && config.ui.announcement && announcementText && !announcementText.visible) {\n\t\t\t\tconst text = config.ui.announcement.matchWin(winner, state[winnerKey]);\n\t\t\t\tannouncementText.setText(text);\n\t\t\t\tannouncementText.setVisible(true);\n\t\t\t\tannouncementText.setAlpha(1);\n\t\t\t}\n\t\t}\n\t};\n\n\t// Subscribe to state changes\n\tconst unsubscribe = adapter.onChange(() => {\n\t\tupdate();\n\t});\n\n\t// Initial update\n\tupdate();\n\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\tunsubscribe();\n\t\t\ttimerText?.destroy();\n\t\t\tannouncementText?.destroy();\n\t\t\tscoreTexts.forEach((text) => text.destroy());\n\t\t},\n\t\tgetTimerText: () => timerText,\n\t\tgetAnnouncementText: () => announcementText\n\t};\n}\n", "/**\n * SpeedDisplay - Reactive speed/velocity display helper\n *\n * Automatically updates when PhysicsManager velocity changes.\n * Separates physics logic from presentation concerns.\n *\n * ## How it works:\n *\n * - **Host:** Subscribes to `onVelocityChange` events for instant updates (no network delay)\n * - **Clients:** Subscribes to state changes, reads `state.players[id].velocity` synced from host\n *\n * This hybrid approach ensures:\n * - Host gets instant feedback (local events, no network overhead)\n * - Clients get accurate sync (velocity automatically synced via state)\n * - No manual update() calls needed - fully reactive!\n *\n * @example\n * ```ts\n * import { createSpeedDisplay } from '@martini-kit/phaser';\n *\n * // In scene.create() - after creating PhysicsManager\n * this.speedDisplay = createSpeedDisplay(\n *   this.physicsManager,\n *   this.adapter,\n *   this,\n *   {\n *     position: { x: 400, y: 50 },\n *     format: (velocity) => `${Math.round(velocity)} mph`,\n *     style: { fontSize: '20px', color: '#4a9eff' }\n *   }\n * );\n *\n * // No update() needed - automatically reacts to velocity changes!\n *\n * // In scene shutdown/destroy:\n * this.speedDisplay.destroy();\n * ```\n */\n\nimport type { PhysicsManager } from './PhysicsManager.js';\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpeedDisplayConfig {\n  /**\n   * Position of the speed display text\n   * Default: { x: 400, y: 50 }\n   */\n  position?: { x: number; y: number };\n\n  /**\n   * Format function to convert velocity to display string\n   * Default: (velocity) => `Speed: ${Math.round(velocity)}`\n   */\n  format?: (velocity: number) => string;\n\n  /**\n   * Phaser text style\n   * Default: { fontSize: '20px', color: '#fff' }\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n}\n\nexport interface SpeedDisplay {\n  /**\n   * Manually update the display (rarely needed - auto-updates via events)\n   */\n  update: () => void;\n\n  /**\n   * Destroy the display and cleanup listeners\n   */\n  destroy: () => void;\n\n  /**\n   * Get the underlying Phaser text object\n   */\n  getText: () => Phaser.GameObjects.Text;\n}\n\n/**\n * Create a speed display that reacts to PhysicsManager velocity changes\n *\n * @param physicsManager - PhysicsManager instance to subscribe to\n * @param adapter - PhaserAdapter instance (for getting local player ID)\n * @param scene - Phaser scene to create text in\n * @param config - Display configuration\n * @returns SpeedDisplay instance with update/destroy methods\n */\nexport function createSpeedDisplay(\n  physicsManager: PhysicsManager,\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: SpeedDisplayConfig = {}\n): SpeedDisplay {\n  // Default config\n  const position = config.position ?? { x: 400, y: 50 };\n  const format = config.format ?? ((v: number) => `Speed: ${Math.round(v)}`);\n  const style = config.style ?? { fontSize: '20px', color: '#fff' };\n\n  // Create text object\n  const text = scene.add.text(position.x, position.y, format(0), style);\n\n  // Set origin\n  if (config.origin !== undefined) {\n    if (typeof config.origin === 'number') {\n      text.setOrigin(config.origin);\n    } else {\n      text.setOrigin(config.origin.x, config.origin.y);\n    }\n  } else {\n    text.setOrigin(0.5); // default: centered\n  }\n\n  // Set depth\n  if (config.depth !== undefined) {\n    text.setDepth(config.depth);\n  }\n\n  // Subscribe to velocity changes (host only - events don't cross network)\n  const unsubscribeVelocity = physicsManager.onVelocityChange((playerId, velocity) => {\n    if (playerId === adapter.getLocalPlayerId()) {\n      text.setText(format(velocity));\n    }\n  });\n\n  // Subscribe to state changes (clients get velocity from state)\n  const unsubscribeState = adapter.onChange((state: any) => {\n    const localPlayerId = adapter.getLocalPlayerId();\n    const player = state.players?.[localPlayerId];\n    if (player && player.velocity !== undefined) {\n      text.setText(format(player.velocity));\n    }\n  });\n\n  // Manual update function\n  const update = () => {\n    const velocity = physicsManager.getVelocity(adapter.getLocalPlayerId());\n    text.setText(format(velocity));\n  };\n\n  // Initial update\n  update();\n\n  return {\n    update,\n    destroy: () => {\n      unsubscribeVelocity();\n      unsubscribeState();\n      text.destroy();\n    },\n    getText: () => text\n  };\n}\n", "/**\n * SpriteAttachment - Generic system for attaching auto-updating components to sprites\n *\n * This is the foundation for all sprite attachments (arrows, health bars, name tags, etc.)\n * It provides a unified \"pit of success\" pattern with automatic updates and cleanup.\n *\n * ## Why Use SpriteAttachment?\n *\n * - **Auto-update by default** - No manual update() calls needed\n * - **Auto-cleanup** - Destroys when sprite/scene is destroyed\n * - **Type-safe** - Full TypeScript support\n * - **Reusable** - One pattern for all attachment types\n * - **Efficient** - Uses Phaser's event system\n *\n * ## Creating Custom Attachments\n *\n * @example Basic attachment\n * ```ts\n * import { createSpriteAttachment, SpriteAttachment } from '@martini-kit/phaser';\n *\n * function createCustomIndicator(\n *   scene: Phaser.Scene,\n *   sprite: any\n * ): SpriteAttachment {\n *   const circle = scene.add.circle(sprite.x, sprite.y, 10, 0xff0000);\n *\n *   return createSpriteAttachment(scene, sprite, {\n *     update: () => {\n *       // Follow the sprite\n *       circle.setPosition(sprite.x, sprite.y + 30);\n *     },\n *     destroy: () => {\n *       circle.destroy();\n *     }\n *   });\n * }\n * ```\n *\n * @example With manual update mode\n * ```ts\n * const attachment = createSpriteAttachment(scene, sprite, {\n *   update: () => { ... },\n *   destroy: () => { ... },\n *   autoUpdate: false  // Disable auto-update\n * });\n *\n * // Then in your scene's update loop:\n * attachment.update();\n * ```\n */\n\nimport type Phaser from 'phaser';\n\n/**\n * Core interface for sprite attachments\n *\n * Any component that follows the sprite (arrows, health bars, name tags, etc.)\n * should implement this interface.\n */\nexport interface SpriteAttachment {\n  /**\n   * Update the attachment's position, rotation, or other properties\n   * based on the parent sprite's current state.\n   *\n   * Called automatically every frame if autoUpdate is enabled.\n   */\n  update: () => void;\n\n  /**\n   * Clean up resources and destroy the attachment.\n   *\n   * Called automatically when sprite/scene is destroyed if autoUpdate is enabled.\n   */\n  destroy: () => void;\n\n  /**\n   * Get the underlying Phaser game object (if any)\n   *\n   * Optional - only needed if the attachment has a visual representation\n   */\n  getGameObject?: () => Phaser.GameObjects.GameObject | null;\n}\n\n/**\n * Configuration for sprite attachment auto-update behavior\n */\nexport interface SpriteAttachmentConfig {\n  /**\n   * Automatically update the attachment every frame\n   *\n   * When true (default), the attachment subscribes to the scene's update event\n   * and automatically calls update() each frame.\n   *\n   * When false, you must manually call attachment.update() in your scene loop.\n   *\n   * @default true\n   */\n  autoUpdate?: boolean;\n}\n\n/**\n * Create a sprite attachment with automatic updates and cleanup\n *\n * This is the foundation function used by all attachment helpers\n * (attachDirectionalIndicator, createHealthBar, createNameTag, etc.)\n *\n * **Automatic Lifecycle Management:**\n * - Calls `update()` every frame via scene events (if autoUpdate: true)\n * - Calls `destroy()` when sprite is destroyed\n * - Calls `destroy()` when scene shuts down\n * - Prevents double-destroy and memory leaks\n *\n * @param scene - Phaser scene\n * @param sprite - Sprite to attach to\n * @param attachment - Attachment implementation (update + destroy)\n * @param config - Auto-update configuration\n * @returns Enhanced attachment with lifecycle management\n *\n * @example Creating a simple follower circle\n * ```ts\n * const circle = scene.add.circle(sprite.x, sprite.y, 10, 0xff0000);\n *\n * const attachment = createSpriteAttachment(scene, sprite, {\n *   update: () => {\n *     circle.setPosition(sprite.x + 20, sprite.y);\n *   },\n *   destroy: () => {\n *     circle.destroy();\n *   }\n * });\n * // That's it! Circle auto-follows sprite and auto-cleans up\n * ```\n */\nexport function createSpriteAttachment(\n  scene: Phaser.Scene,\n  sprite: any,\n  attachment: SpriteAttachment,\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment {\n  const autoUpdate = config.autoUpdate ?? true;\n\n  // Track destruction state to prevent double-destroy\n  let isDestroyed = false;\n\n  // Wrap the original destroy to track state\n  const originalDestroy = attachment.destroy;\n  const wrappedDestroy = () => {\n    if (isDestroyed) return;\n    isDestroyed = true;\n\n    // Remove event listener if auto-update is enabled\n    if (updateHandler) {\n      scene.events.off('update', updateHandler);\n      updateHandler = null;\n    }\n\n    // Call original destroy\n    originalDestroy();\n  };\n\n  // Auto-update setup\n  let updateHandler: (() => void) | null = null;\n\n  if (autoUpdate) {\n    // Initial update\n    attachment.update();\n\n    // Create update handler\n    updateHandler = () => {\n      if (!isDestroyed) {\n        attachment.update();\n      }\n    };\n\n    // Subscribe to scene update event\n    scene.events.on('update', updateHandler);\n\n    // Cleanup when sprite is destroyed\n    if (sprite.once) {\n      sprite.once('destroy', () => {\n        wrappedDestroy();\n      });\n    }\n\n    // Cleanup when scene shuts down\n    scene.events.once('shutdown', () => {\n      if (updateHandler) {\n        scene.events.off('update', updateHandler);\n        updateHandler = null;\n      }\n    });\n  } else {\n    // Manual mode - just do initial update\n    attachment.update();\n  }\n\n  // Return wrapped attachment\n  return {\n    update: attachment.update,\n    destroy: wrappedDestroy,\n    getGameObject: attachment.getGameObject\n  };\n}\n\n/**\n * Helper to create multiple attachments at once\n *\n * Useful when you want to attach several components to the same sprite\n * (e.g., arrow + health bar + name tag).\n *\n * @example\n * ```ts\n * createSpriteAttachments(scene, sprite, [\n *   createDirectionalArrow(scene, sprite),\n *   createHealthBar(scene, sprite, { maxHealth: 100 }),\n *   createNameTag(scene, sprite, { text: 'Player 1' })\n * ]);\n * ```\n */\nexport function createSpriteAttachments(\n  scene: Phaser.Scene,\n  sprite: any,\n  attachments: SpriteAttachment[],\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment[] {\n  return attachments.map((attachment) =>\n    createSpriteAttachment(scene, sprite, attachment, config)\n  );\n}\n\n/**\n * Composite attachment that manages multiple child attachments\n *\n * Useful for complex attachments that have multiple visual components.\n *\n * @example\n * ```ts\n * const composite = createCompositeAttachment(scene, sprite, [\n *   { update: () => updateArrow(), destroy: () => arrow.destroy() },\n *   { update: () => updateGlow(), destroy: () => glow.destroy() }\n * ]);\n * // All children auto-update and auto-destroy together\n * ```\n */\nexport function createCompositeAttachment(\n  scene: Phaser.Scene,\n  sprite: any,\n  children: SpriteAttachment[],\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment {\n  // Create wrapped versions of all children with autoUpdate disabled\n  // (the composite will handle updates)\n  const wrappedChildren = children.map((child) =>\n    createSpriteAttachment(scene, sprite, child, { autoUpdate: false })\n  );\n\n  // Create composite that updates/destroys all children\n  return createSpriteAttachment(\n    scene,\n    sprite,\n    {\n      update: () => {\n        for (const child of wrappedChildren) {\n          child.update();\n        }\n      },\n      destroy: () => {\n        for (const child of wrappedChildren) {\n          child.destroy();\n        }\n      },\n      getGameObject: () => {\n        // Return first child's game object (if any)\n        return wrappedChildren[0]?.getGameObject?.() ?? null;\n      }\n    },\n    config\n  );\n}\n", "/**\n * DirectionalIndicator - Arrow/indicator that shows sprite direction\n *\n * Automatically handles Phaser's rotation convention (0 = right/+X axis)\n * so you don't have to think about rotation offsets.\n *\n * ## Phaser Rotation Convention\n *\n * Phaser uses a coordinate system where:\n * - 0 radians = pointing RIGHT (positive X axis)\n * - \u03C0/2 radians = pointing DOWN (positive Y axis)\n * - \u03C0 radians = pointing LEFT (negative X axis)\n * - -\u03C0/2 radians = pointing UP (negative Y axis)\n *\n * This helper automatically adds a +\u03C0/2 offset to triangle/arrow shapes\n * (which naturally point UP) so they align with the sprite's rotation.\n *\n * ## Auto-Update (Pit of Success!)\n *\n * By default, indicators automatically update every frame via scene events.\n * **No manual update() calls needed!** Just attach and forget.\n *\n * @example Automatic updates (recommended - default behavior)\n * ```ts\n * import { attachDirectionalIndicator } from '@martini-kit/phaser';\n *\n * // In SpriteManager onCreate or onAdd:\n * onCreate: (key, data) => {\n *   const car = this.add.rectangle(data.x, data.y, 30, 20, data.color);\n *\n *   // That's it! Arrow auto-updates every frame\n *   attachDirectionalIndicator(this, car, {\n *     shape: 'triangle',\n *     offset: 20,\n *     color: 0xffffff\n *     // autoUpdate: true is the default\n *   });\n *\n *   return car;\n * }\n * ```\n *\n * @example Manual updates (if you need fine control)\n * ```ts\n * onCreate: (key, data) => {\n *   const car = this.add.rectangle(data.x, data.y, 30, 20, data.color);\n *\n *   car.directionArrow = attachDirectionalIndicator(this, car, {\n *     shape: 'triangle',\n *     offset: 20,\n *     color: 0xffffff,\n *     autoUpdate: false  // Disable auto-update\n *   });\n *\n *   return car;\n * },\n *\n * // Then in your scene's update loop:\n * update() {\n *   for (const [, sprite] of this.spriteManager.getAll()) {\n *     sprite.directionArrow?.update();\n *   }\n * }\n * ```\n */\n\nimport type Phaser from 'phaser';\nimport { createSpriteAttachment, type SpriteAttachment } from './SpriteAttachment';\n\nexport interface DirectionalIndicatorConfig {\n  /**\n   * Shape of the indicator\n   * - 'triangle': Classic arrow shape (default)\n   * - 'arrow': Longer arrow with tail\n   * - 'chevron': V-shaped chevron\n   */\n  shape?: 'triangle' | 'arrow' | 'chevron';\n\n  /**\n   * Distance from sprite center\n   * Default: 20\n   */\n  offset?: number;\n\n  /**\n   * Indicator color\n   * Default: 0xffffff (white)\n   */\n  color?: number;\n\n  /**\n   * Indicator size/scale\n   * Default: 1.0\n   */\n  size?: number;\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Automatically update the indicator every frame\n   *\n   * When true (default), the indicator subscribes to the scene's update event\n   * and automatically follows the sprite's position/rotation each frame.\n   * No manual update() calls needed!\n   *\n   * When false, you must manually call indicator.update() in your scene loop.\n   *\n   * @default true\n   */\n  autoUpdate?: boolean;\n}\n\nexport interface DirectionalIndicator extends SpriteAttachment {\n  /**\n   * Get the underlying Phaser game object\n   *\n   * @override Always defined for DirectionalIndicator (not optional)\n   */\n  getGameObject: () => Phaser.GameObjects.GameObject;\n}\n\n/**\n * Attach a directional indicator to a sprite\n *\n * Automatically handles Phaser's rotation convention where:\n * - 0 radians = pointing right (+X axis)\n * - Math.PI/2 = pointing down (+Y axis)\n * - Math.PI = pointing left (-X axis)\n * - -Math.PI/2 = pointing up (-Y axis)\n *\n * By default (autoUpdate: true), the indicator automatically updates every frame.\n * No manual update() calls needed - it \"just works\"!\n *\n * @param scene - Phaser scene\n * @param sprite - Sprite to attach indicator to\n * @param config - Indicator configuration\n * @returns DirectionalIndicator instance\n */\nexport function attachDirectionalIndicator(\n  scene: Phaser.Scene,\n  sprite: any,\n  config: DirectionalIndicatorConfig = {}\n): DirectionalIndicator {\n  const shape = config.shape ?? 'triangle';\n  const offset = config.offset ?? 20;\n  const color = config.color ?? 0xffffff;\n  const size = config.size ?? 1.0;\n  const autoUpdate = config.autoUpdate ?? true;\n\n  let indicator: Phaser.GameObjects.GameObject & {\n    setPosition?: (x: number, y: number) => any;\n    setRotation?: (rotation: number) => any;\n  };\n\n  // Create the appropriate shape\n  switch (shape) {\n    case 'triangle': {\n      // Triangle pointing UP (negative Y) in default orientation\n      // We'll add \u03C0/2 rotation offset in update() to match Phaser's convention\n      const triangle = scene.add.triangle(\n        sprite.x,\n        sprite.y,\n        0, -5,        // Top point (tip)\n        -4, 5,        // Bottom left\n        4, 5,         // Bottom right\n        color\n      );\n      triangle.setOrigin(0.5);\n      if (config.depth !== undefined) {\n        triangle.setDepth(config.depth);\n      }\n      indicator = triangle;\n      break;\n    }\n\n    case 'arrow': {\n      // Longer arrow with distinct head and tail\n      const container = scene.add.container(sprite.x, sprite.y);\n\n      // Arrow shaft (horizontal line)\n      const shaft = scene.add.rectangle(-3 * size, 0, 10 * size, 2 * size, color);\n      shaft.setOrigin(0.5);\n\n      // Arrow head (triangle)\n      const head = scene.add.triangle(\n        5 * size, 0,\n        0, 0,              // Point\n        -3 * size, -3 * size, // Top\n        -3 * size, 3 * size,  // Bottom\n        color\n      );\n      head.setOrigin(0.5);\n\n      container.add([shaft, head]);\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n      indicator = container;\n      break;\n    }\n\n    case 'chevron': {\n      // V-shaped chevron\n      const graphics = scene.add.graphics();\n      graphics.lineStyle(2 * size, color);\n      // Draw > shape (pointing right)\n      graphics.beginPath();\n      graphics.moveTo(-4 * size, -4 * size);\n      graphics.lineTo(4 * size, 0);\n      graphics.lineTo(-4 * size, 4 * size);\n      graphics.strokePath();\n      graphics.setPosition(sprite.x, sprite.y);\n      if (config.depth !== undefined) {\n        graphics.setDepth(config.depth);\n      }\n      indicator = graphics;\n      break;\n    }\n  }\n\n  // Update function - positions indicator in front of sprite\n  const update = () => {\n    // Calculate position in front of sprite (in the direction it's facing)\n    const indicatorX = sprite.x + Math.cos(sprite.rotation) * offset;\n    const indicatorY = sprite.y + Math.sin(sprite.rotation) * offset;\n\n    indicator.setPosition?.(indicatorX, indicatorY);\n\n    // Add \u03C0/2 rotation offset because:\n    // - Triangle points UP (negative Y) at rotation 0\n    // - Phaser's 0 rotation points RIGHT (positive X)\n    // - So we need +90 degrees (\u03C0/2 radians) to align them\n    indicator.setRotation?.(sprite.rotation + Math.PI / 2);\n  };\n\n  // Use generic SpriteAttachment system for lifecycle management\n  return createSpriteAttachment(\n    scene,\n    sprite,\n    {\n      update,\n      destroy: () => {\n        indicator.destroy();\n      },\n      getGameObject: () => indicator\n    },\n    { autoUpdate }\n  ) as DirectionalIndicator;\n}\n", "/**\n * @martini-kit/phaser - Phaser 3 adapter for multiplayer games\n *\n * Provides high-level helpers for syncing sprites and handling multiplayer in Phaser.\n *\n * @packageDocumentation\n */\n\nexport { PhaserAdapter } from './PhaserAdapter.js';\nexport type { SpriteTrackingOptions, PhaserAdapterConfig } from './PhaserAdapter.js';\n\n// Helpers\nexport { SpriteManager } from './helpers/SpriteManager.js';\nexport type { SpriteManagerConfig, SpriteData } from './helpers/SpriteManager.js';\nexport { InputManager } from './helpers/InputManager.js';\nexport type { ActionBinding, KeyBinding, KeyBindings, CursorBindings } from './helpers/InputManager.js';\nexport { PhysicsManager } from './helpers/PhysicsManager.js';\nexport type { PhysicsManagerConfig, PlatformerBehaviorConfig, TopDownBehaviorConfig, RacingBehaviorConfig, CustomBehaviorConfig } from './helpers/PhysicsManager.js';\nexport { CollisionManager } from './helpers/CollisionManager.js';\nexport type { CollisionManagerConfig, CollisionRule } from './helpers/CollisionManager.js';\nexport { PlayerUIManager } from './helpers/PlayerUIManager.js';\nexport type { PlayerUIManagerConfig, TextUIConfig, BarUIConfig } from './helpers/PlayerUIManager.js';\nexport { StateDrivenSpawner } from './helpers/StateDrivenSpawner.js';\nexport type { StateDrivenSpawnerConfig } from './helpers/StateDrivenSpawner.js';\nexport { HealthBarManager } from './helpers/HealthBarManager.js';\nexport type { HealthBarConfig } from './helpers/HealthBarManager.js';\nexport { GridClickHelper } from './helpers/GridClickHelper.js';\nexport type { GridClickConfig } from './helpers/GridClickHelper.js';\nexport { GridCollisionManager, GridMovementManager } from './helpers/GridCollisionManager.js';\nexport type { GridCollisionConfig, GridMovementConfig, GridEntity, MovementInput, GridPosition } from './helpers/GridCollisionManager.js';\nexport { GridLockedMovementManager } from './helpers/GridLockedMovementManager.js';\nexport type { GridLockedMovementConfig, GridLockedEntity } from './helpers/GridLockedMovementManager.js';\n\n// Input Profiles\nexport { registerProfile, getProfile, listProfiles, BUILT_IN_PROFILES } from './helpers/InputProfiles.js';\nexport type { InputProfile, ProfileOptions } from './helpers/InputProfiles.js';\n\n// HUD Helper\nexport { createPlayerHUD } from './helpers/HUDHelper.js';\nexport type { PlayerHUD, PlayerHUDConfig, HUDLayout, HUDTextStyle } from './helpers/HUDHelper.js';\n\n// Player Stats Panel Helper\nexport { createPlayerStatsPanel } from './helpers/PlayerStatsPanel.js';\nexport type { PlayerStatsPanel, PlayerStatsPanelConfig, StatConfig, StatPosition } from './helpers/PlayerStatsPanel.js';\n\n// Collectible Manager Helper\nexport { createCollectibleManager } from './helpers/CollectibleManager.js';\nexport type { CollectibleManager, CollectibleManagerConfig, CollectibleConfig, CollisionType } from './helpers/CollectibleManager.js';\n\n// Round Manager Helper\nexport { createRoundManager } from './helpers/RoundManager.js';\nexport type { RoundManager, RoundManagerConfig, TimerUIConfig, AnnouncementUIConfig, ScoreboardUIConfig } from './helpers/RoundManager.js';\n\n\n// Speed Display Helper\nexport { createSpeedDisplay } from './helpers/SpeedDisplay.js';\nexport type { SpeedDisplay, SpeedDisplayConfig } from './helpers/SpeedDisplay.js';\n\n// Sprite Attachment System (Generic)\nexport { createSpriteAttachment, createSpriteAttachments, createCompositeAttachment } from './helpers/SpriteAttachment.js';\nexport type { SpriteAttachment, SpriteAttachmentConfig } from './helpers/SpriteAttachment.js';\n\n// Directional Indicator Helper\nexport { attachDirectionalIndicator } from './helpers/DirectionalIndicator.js';\nexport type { DirectionalIndicator, DirectionalIndicatorConfig } from './helpers/DirectionalIndicator.js';\n\n// Camera Follower Helper\nexport { createCameraFollower } from './helpers/CameraFollower.js';\nexport type { CameraFollower, CameraFollowerConfig, CameraFollowerTarget } from './helpers/CameraFollower.js';\n\n// Dual Runtime Factory\nexport { createDualRuntimePreview } from './helpers/DualRuntimeFactory.js';\nexport type { DualRuntimePreview, DualRuntimePreviewConfig } from './helpers/DualRuntimeFactory.js';\n\n// Lobby UI Helper\nexport { LobbyUI, attachLobbyUI } from './helpers/LobbyUI.js';\nexport type { LobbyUIConfig } from './helpers/LobbyUI.js';\n\n// Runtime initialization (transport abstraction)\nexport { initializeGame } from './runtime.js';\nexport type { MartiniKitConfig, GameConfig } from './runtime.js';\n\n// Re-export core types for convenience\nexport type { GameDefinition, Transport, GameRuntime } from '@martini-kit/core';\n", "/**\n * DualRuntimeFactory - Create host/client preview setups in one line\n *\n * Eliminates the 40+ lines of boilerplate for spinning up dual runtimes\n * that every demo and IDE route currently reimplements.\n *\n * This is the ROOT CAUSE of IDE drift - when demos update their wiring,\n * IDE routes don't, because they've all copy-pasted the setup code.\n *\n * Usage:\n * ```ts\n * const preview = createDualRuntimePreview({\n *   game: arenaBlasterGame,\n *   hostContainer,\n *   clientContainer,\n *   onHostReady: () => console.log('Host ready'),\n *   onClientReady: () => console.log('Client ready')\n * });\n *\n * // That's it! Returns:\n * // - hostRuntime\n * // - clientRuntime\n * // - hostTransport\n * // - clientTransport\n * // - cleanup function\n * ```\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\n\nexport interface DualRuntimePreviewConfig {\n  /**\n   * The game definition to run\n   */\n  game: GameDefinition;\n\n  /**\n   * Optional room ID (auto-generated if not provided)\n   */\n  roomId?: string;\n\n  /**\n   * Optional callbacks for status updates\n   */\n  onHostReady?: () => void;\n  onClientReady?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface DualRuntimePreview {\n  /**\n   * Host runtime instance\n   */\n  hostRuntime: GameRuntime;\n\n  /**\n   * Client runtime instance\n   */\n  clientRuntime: GameRuntime;\n\n  /**\n   * Host transport instance\n   */\n  hostTransport: LocalTransport;\n\n  /**\n   * Client transport instance\n   */\n  clientTransport: LocalTransport;\n\n  /**\n   * Host player ID\n   */\n  hostPlayerId: string;\n\n  /**\n   * Client player ID\n   */\n  clientPlayerId: string;\n\n  /**\n   * Generated room ID\n   */\n  roomId: string;\n\n  /**\n   * Cleanup function - call on unmount\n   */\n  cleanup: () => void;\n}\n\n/**\n * Create a dual runtime preview (host + client)\n *\n * This eliminates the ~40 lines of boilerplate that every demo/IDE route\n * currently reimplements. By using this factory, IDE routes are guaranteed\n * to stay in sync with demo implementations.\n *\n * @example\n * ```ts\n * const preview = createDualRuntimePreview({\n *   game: arenaBlasterGame,\n *   onHostReady: () => setHostStatus('ready'),\n *   onClientReady: () => setClientStatus('ready'),\n *   onError: (err) => setError(err.message)\n * });\n *\n * // Use preview.hostRuntime, preview.clientRuntime, etc.\n *\n * // Cleanup on unmount:\n * onCleanup(() => preview.cleanup());\n * ```\n */\nexport function createDualRuntimePreview(\n  config: DualRuntimePreviewConfig\n): DualRuntimePreview {\n  try {\n    // Generate room ID if not provided\n    const roomId = config.roomId || `dual-preview-${Math.random().toString(36).substring(2, 8)}`;\n\n    // Create Host instance with LocalTransport\n    const hostTransport = new LocalTransport({\n      roomId,\n      isHost: true,\n    });\n\n    // Create Client instance with LocalTransport\n    const clientTransport = new LocalTransport({\n      roomId,\n      isHost: false,\n    });\n\n    // Get both player IDs to initialize both runtimes\n    // This is CRITICAL for host-authoritative architecture:\n    // Both runtimes need to know about ALL players from the start\n    const hostPlayerId = hostTransport.getPlayerId();\n    const clientPlayerId = clientTransport.getPlayerId();\n\n    const hostRuntime = new GameRuntime(config.game, hostTransport, {\n      isHost: true,\n      playerIds: [hostPlayerId, clientPlayerId],\n    });\n\n    config.onHostReady?.();\n\n    const clientRuntime = new GameRuntime(config.game, clientTransport, {\n      isHost: false,\n      playerIds: [hostPlayerId, clientPlayerId],\n    });\n\n    config.onClientReady?.();\n\n    // Cleanup function\n    const cleanup = () => {\n      // Add any necessary cleanup here\n      // (LocalTransport doesn't currently expose cleanup, but we include this for future-proofing)\n    };\n\n    return {\n      hostRuntime,\n      clientRuntime,\n      hostTransport,\n      clientTransport,\n      hostPlayerId,\n      clientPlayerId,\n      roomId,\n      cleanup,\n    };\n  } catch (err) {\n    const error = err instanceof Error ? err : new Error('Failed to create dual runtime preview');\n    config.onError?.(error);\n    throw error;\n  }\n}\n", "/**\n * LobbyUI - Simple, reusable lobby UI for Phaser games\n *\n * Shows lobby state, player list, ready indicators, and start button\n *\n * @example\n * ```ts\n * this.lobbyUI = this.adapter.createLobbyUI({\n *   title: 'Paddle Battle',\n *   subtitle: 'Waiting for players...',\n *   position: { x: 400, y: 200 }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\nimport type { LobbyState, PlayerPresence } from '@martini-kit/core';\n\nexport interface LobbyUIConfig {\n  /** Title text */\n  title?: string;\n\n  /** Subtitle text (shown below title) */\n  subtitle?: string;\n\n  /** Position of the lobby UI */\n  position?: { x: number; y: number };\n\n  /** Title style */\n  titleStyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /** Subtitle style */\n  subtitleStyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /** Player list style */\n  playerStyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /** Button style */\n  buttonStyle?: {\n    fill: number;\n    textColor: string;\n    fontSize: string;\n  };\n\n  /** Show instructions */\n  showInstructions?: boolean;\n}\n\nexport class LobbyUI {\n  private container: Phaser.GameObjects.Container;\n  private titleText?: Phaser.GameObjects.Text;\n  private subtitleText?: Phaser.GameObjects.Text;\n  private playerListText?: Phaser.GameObjects.Text;\n  private readyButton?: Phaser.GameObjects.Container;\n  private readyButtonText?: Phaser.GameObjects.Text;\n  private startButton?: Phaser.GameObjects.Container;\n  private startButtonText?: Phaser.GameObjects.Text;\n  private instructionsText?: Phaser.GameObjects.Text;\n  private statusText?: Phaser.GameObjects.Text;\n\n  private isReady: boolean = false;\n  private config: Required<LobbyUIConfig>;\n\n  constructor(\n    private adapter: PhaserAdapter,\n    private scene: Phaser.Scene,\n    config: LobbyUIConfig = {}\n  ) {\n    // Default config\n    this.config = {\n      title: config.title || 'Lobby',\n      subtitle: config.subtitle || 'Waiting for players...',\n      position: config.position || { x: 400, y: 200 },\n      titleStyle: config.titleStyle || {\n        fontSize: '48px',\n        color: '#ffffff',\n        fontStyle: 'bold'\n      },\n      subtitleStyle: config.subtitleStyle || {\n        fontSize: '24px',\n        color: '#aaaaaa'\n      },\n      playerStyle: config.playerStyle || {\n        fontSize: '20px',\n        color: '#ffffff'\n      },\n      buttonStyle: config.buttonStyle || {\n        fill: 0x4ecdc4,\n        textColor: '#ffffff',\n        fontSize: '20px'\n      },\n      showInstructions: config.showInstructions !== false\n    };\n\n    // Create container\n    this.container = this.scene.add.container(\n      this.config.position.x,\n      this.config.position.y\n    );\n    this.container.setDepth(1000); // High depth to render on top\n\n    this.createUI();\n  }\n\n  private createUI(): void {\n    let yOffset = 0;\n\n    // Title\n    if (this.config.title) {\n      this.titleText = this.scene.add.text(0, yOffset, this.config.title, this.config.titleStyle);\n      this.titleText.setOrigin(0.5, 0);\n      this.container.add(this.titleText);\n      yOffset += 60;\n    }\n\n    // Subtitle\n    if (this.config.subtitle) {\n      this.subtitleText = this.scene.add.text(0, yOffset, this.config.subtitle, this.config.subtitleStyle);\n      this.subtitleText.setOrigin(0.5, 0);\n      this.container.add(this.subtitleText);\n      yOffset += 40;\n    }\n\n    // Status text (shows timer, player count, etc.)\n    this.statusText = this.scene.add.text(0, yOffset, '', {\n      fontSize: '18px',\n      color: '#ffff00'\n    });\n    this.statusText.setOrigin(0.5, 0);\n    this.container.add(this.statusText);\n    yOffset += 30;\n\n    // Player list\n    this.playerListText = this.scene.add.text(0, yOffset, '', this.config.playerStyle);\n    this.playerListText.setOrigin(0.5, 0);\n    this.playerListText.setAlign('center');\n    this.container.add(this.playerListText);\n    yOffset += 150; // Reserve space for player list\n\n    // Ready button\n    this.readyButton = this.createButton(0, yOffset, 'Ready', () => {\n      this.toggleReady();\n    });\n    this.container.add(this.readyButton);\n    yOffset += 60;\n\n    // Start button (host only)\n    this.startButton = this.createButton(0, yOffset, 'Start Game', () => {\n      this.startGame();\n    });\n    this.startButton.setVisible(false); // Hidden by default\n    this.container.add(this.startButton);\n    yOffset += 60;\n\n    // Instructions\n    if (this.config.showInstructions) {\n      this.instructionsText = this.scene.add.text(\n        0,\n        yOffset,\n        'Click Ready when you are ready to play',\n        {\n          fontSize: '16px',\n          color: '#888888',\n          align: 'center'\n        }\n      );\n      this.instructionsText.setOrigin(0.5, 0);\n      this.container.add(this.instructionsText);\n    }\n  }\n\n  private createButton(\n    x: number,\n    y: number,\n    text: string,\n    onClick: () => void\n  ): Phaser.GameObjects.Container {\n    const buttonContainer = this.scene.add.container(x, y);\n\n    // Button background\n    const bg = this.scene.add.rectangle(0, 0, 200, 50, this.config.buttonStyle.fill);\n    bg.setStrokeStyle(2, 0xffffff);\n    bg.setInteractive({ useHandCursor: true });\n\n    // Button text\n    const buttonText = this.scene.add.text(0, 0, text, {\n      fontSize: this.config.buttonStyle.fontSize,\n      color: this.config.buttonStyle.textColor,\n      fontStyle: 'bold'\n    });\n    buttonText.setOrigin(0.5);\n\n    // Store reference to text for updates\n    if (text === 'Ready') {\n      this.readyButtonText = buttonText;\n    } else if (text === 'Start Game') {\n      this.startButtonText = buttonText;\n    }\n\n    // Hover effects\n    bg.on('pointerover', () => {\n      bg.setFillStyle(this.config.buttonStyle.fill, 0.8);\n    });\n\n    bg.on('pointerout', () => {\n      bg.setFillStyle(this.config.buttonStyle.fill, 1);\n    });\n\n    bg.on('pointerdown', onClick);\n\n    buttonContainer.add([bg, buttonText]);\n    return buttonContainer;\n  }\n\n  private toggleReady(): void {\n    this.isReady = !this.isReady;\n    const runtime = (this.adapter as any).runtime;\n    runtime.submitAction('__lobbyReady', { ready: this.isReady });\n\n    // Update button appearance\n    if (this.readyButtonText) {\n      this.readyButtonText.setText(this.isReady ? 'Not Ready' : 'Ready');\n    }\n  }\n\n  private startGame(): void {\n    const runtime = (this.adapter as any).runtime;\n    runtime.submitAction('__lobbyStart');\n  }\n\n  /**\n   * Update the lobby UI based on current state\n   * Call this in your scene's update() or onChange() callback\n   */\n  update(lobbyState: LobbyState): void {\n    // Update player list\n    this.updatePlayerList(lobbyState);\n\n    // Update status text\n    this.updateStatusText(lobbyState);\n\n    // Show/hide start button for host\n    if (this.startButton) {\n      const isHost = this.adapter.isHost();\n      const canStart = this.canStartGame(lobbyState);\n      this.startButton.setVisible(isHost && !lobbyState.config.requireAllReady);\n\n      if (this.startButtonText) {\n        this.startButtonText.setAlpha(canStart ? 1 : 0.5);\n      }\n    }\n  }\n\n  private updatePlayerList(lobbyState: LobbyState): void {\n    if (!this.playerListText) return;\n\n    const players = Object.values(lobbyState.players) as PlayerPresence[];\n    const myId = this.adapter.getMyPlayerId();\n\n    const lines: string[] = ['Players:'];\n    players.forEach((player, index) => {\n      const isMe = player.playerId === myId;\n      const readyIndicator = player.ready ? '\u2713' : '\u25CB';\n      const namePrefix = isMe ? 'You' : `Player ${index + 1}`;\n      lines.push(`${readyIndicator} ${namePrefix}`);\n    });\n\n    this.playerListText.setText(lines.join('\\n'));\n  }\n\n  private updateStatusText(lobbyState: LobbyState): void {\n    if (!this.statusText) return;\n\n    const playerCount = Object.keys(lobbyState.players).length;\n    const minPlayers = lobbyState.config.minPlayers;\n    const readyCount = Object.values(lobbyState.players).filter((p: any) => p.ready).length;\n\n    let status = '';\n\n    // Player count\n    if (playerCount < minPlayers) {\n      status = `Waiting for players (${playerCount}/${minPlayers})`;\n    } else {\n      status = `${playerCount} players`;\n    }\n\n    // Ready count\n    if (lobbyState.config.requireAllReady) {\n      status += ` | Ready: ${readyCount}/${playerCount}`;\n    }\n\n    // Auto-start timer (if applicable)\n    if (lobbyState.config.autoStartTimeout && playerCount >= minPlayers) {\n      status += ' | Auto-start enabled';\n    }\n\n    this.statusText.setText(status);\n  }\n\n  private canStartGame(lobbyState: LobbyState): boolean {\n    const playerCount = Object.keys(lobbyState.players).length;\n    const minPlayers = lobbyState.config.minPlayers;\n\n    if (playerCount < minPlayers) {\n      return false;\n    }\n\n    if (lobbyState.config.requireAllReady) {\n      const allReady = Object.values(lobbyState.players).every((p: any) => p.ready);\n      return allReady;\n    }\n\n    return true;\n  }\n\n  /**\n   * Show the lobby UI\n   */\n  show(): void {\n    this.container.setVisible(true);\n  }\n\n  /**\n   * Hide the lobby UI\n   */\n  hide(): void {\n    this.container.setVisible(false);\n  }\n\n  /**\n   * Destroy the lobby UI\n   */\n  destroy(): void {\n    this.container.destroy();\n  }\n\n  /**\n   * Check if lobby UI is visible\n   */\n  isVisible(): boolean {\n    return this.container.visible;\n  }\n}\n\n/**\n * Helper method to create LobbyUI on PhaserAdapter\n */\nexport function attachLobbyUI(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config?: LobbyUIConfig\n): LobbyUI {\n  return new LobbyUI(adapter, scene, config);\n}\n", "/**\n * @martini-kit/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\nimport { TrysteroTransport } from '@martini-kit/transport-trystero';\nimport { IframeBridgeTransport } from '@martini-kit/transport-iframe-bridge';\nimport type { Transport } from '@martini-kit/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniKitConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n    rtcConfig?: RTCConfiguration; // For Trystero\n    relayUrls?: string[]; // For Trystero\n  };\n\n  /**\n   * Minimum players required before starting the game loop/rendering.\n   * Useful for P2P transports where peers join asynchronously.\n   */\n  minPlayers?: number;\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\ntype CleanupHandle = () => void;\n\nconst GLOBAL_GAME_KEY = '__martini-kit_CURRENT_GAME__';\n\nfunction getExistingCleanup(): CleanupHandle | null {\n  if (typeof globalThis === 'undefined') return null;\n  const existing = (globalThis as any)[GLOBAL_GAME_KEY];\n  return typeof existing?.cleanup === 'function' ? existing.cleanup : null;\n}\n\nfunction setGlobalCleanup(cleanup: CleanupHandle): void {\n  if (typeof globalThis === 'undefined') return;\n  (globalThis as any)[GLOBAL_GAME_KEY] = { cleanup };\n}\n\nfunction clearGlobalCleanup(): void {\n  if (typeof globalThis === 'undefined') return;\n  delete (globalThis as any)[GLOBAL_GAME_KEY];\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini-kit/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport async function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): Promise<{ runtime: GameRuntime<TState>; phaser: Phaser.Game }> {\n  const hot = typeof import.meta !== 'undefined' ? (import.meta as any).hot : undefined;\n\n  // During HMR, ensure any prior game instance is cleaned up before creating a new one\n  const previousCleanup = getExistingCleanup();\n  if (previousCleanup) {\n    previousCleanup();\n  }\n\n  // Fallback: if a transport is still registered globally (e.g., HMR edge), disconnect it\n  const leakedTransport = (globalThis as any)['__martini-kit_TRANSPORT__'];\n  if (leakedTransport) {\n    console.debug('[Martini] Found leaked transport, cleaning up...', leakedTransport);\n    if (typeof leakedTransport.disconnect === 'function') {\n      leakedTransport.disconnect();\n    } else if (typeof leakedTransport.destroy === 'function') {\n      leakedTransport.destroy();\n    }\n    // Force clear the global to ensure it's gone\n    delete (globalThis as any)['__martini-kit_TRANSPORT__'];\n    console.debug('[Martini] Transport cleanup complete, global cleared');\n  }\n\n  // Read platform-injected config\n  const platformConfig = (window as any)['__martini-kit_CONFIG__'] as MartiniKitConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __martini-kit_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Wait for transport readiness (important for P2P host discovery)\n  if (typeof (transport as any).waitForReady === 'function') {\n    await (transport as any).waitForReady();\n  }\n\n  // Seed only self; peers will be added via onPeerJoin to avoid double-seeding/ordering bugs\n  const initialPlayerIds = [transport.getPlayerId()];\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: initialPlayerIds\n    }\n  );\n\n  // Optionally wait for minimum players before continuing\n  // Skip if lobby system is enabled - it handles player coordination\n  const hasLobby = config.game.lobby !== undefined;\n  const minPlayers = platformConfig.minPlayers && platformConfig.minPlayers > 0 ? platformConfig.minPlayers : 1;\n\n  if (!hasLobby && minPlayers > 1) {\n    try {\n      await runtime.waitForPlayers(minPlayers, { timeoutMs: 10000 });\n    } catch (err) {\n      console.warn('[Martini] waitForPlayers timed out:', err);\n    }\n  }\n\n  // Resolve Phaser from import or global (Sandpack can fail to hydrate default import)\n  const PhaserLib = Phaser ?? (typeof window !== 'undefined' ? (window as any).Phaser : undefined);\n  if (!PhaserLib) {\n    throw new Error('Phaser failed to load. Ensure the Phaser script is available in the sandbox.');\n  }\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: PhaserLib.Scale.FIT,\n    autoCenter: PhaserLib.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  // Default input configuration ensures pointer/mouse/touch events work\n  // especially when running inside iframes (IDE environment)\n  const defaultInput = {\n    activePointers: 3 // Enable mouse + 2 touch pointers by default\n  };\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: PhaserLib.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    input: defaultInput,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  const phaserGame = new PhaserLib.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any)['__martini-kit_IDE__']) {\n    (window as any)['__martini-kit_IDE__'].registerRuntime(runtime);\n  }\n\n  const disconnectTransport = () => {\n    if ('disconnect' in transport && typeof (transport as any).disconnect === 'function') {\n      (transport as any).disconnect();\n    } else if ('destroy' in transport && typeof (transport as any).destroy === 'function') {\n      (transport as any).destroy();\n    }\n  };\n\n  const handleIdeDisconnect = (event: MessageEvent) => {\n    if (event.data?.type === 'martini-kit:transport:disconnect') {\n      disconnectTransport();\n    }\n  };\n\n  const handleBeforeUnload = () => {\n    disconnectTransport();\n  };\n\n  // Auto-cleanup: Disconnect transport when navigating away\n  // Two mechanisms for defense-in-depth:\n  // 1. Message from parent (IDE-initiated cleanup)\n  // 2. beforeunload event (direct browser navigation)\n  if (typeof window !== 'undefined') {\n    // Listen for IDE cleanup message\n    window.addEventListener('message', handleIdeDisconnect);\n\n    // Fallback: Disconnect on browser navigation/close\n    window.addEventListener('beforeunload', handleBeforeUnload);\n  }\n\n  let cleanedUp = false;\n  const cleanup = () => {\n    if (cleanedUp) return;\n    cleanedUp = true;\n\n    clearGlobalCleanup();\n\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('message', handleIdeDisconnect);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    }\n\n    runtime.destroy();\n    disconnectTransport();\n    phaserGame.destroy(true);\n  };\n\n  setGlobalCleanup(cleanup);\n\n  if (hot?.dispose) {\n    hot.dispose(() => {\n      cleanup();\n    });\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniKitConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'trystero':\n      return new TrysteroTransport({\n        appId: config.appId || 'martini-kit',\n        roomId: config.roomId,\n        isHost: config.isHost,\n        rtcConfig: config.rtcConfig,\n        relayUrls: config.relayUrls\n      });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local', 'iframe-bridge', and 'trystero' are supported in IDE mode.`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["state", "collection", "createCameraFollower", "GameRuntime", "LocalTransport"]
}
