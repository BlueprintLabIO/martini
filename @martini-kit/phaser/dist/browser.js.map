{
  "version": 3,
  "sources": ["../src/helpers/CameraFollower.ts", "../src/helpers/SpriteManager.ts", "../src/helpers/InputProfiles.ts", "../src/helpers/InputManager.ts", "../src/helpers/PlayerUIManager.ts", "../src/helpers/CollisionManager.ts", "../src/helpers/PhysicsManager.ts", "../src/helpers/StateDrivenSpawner.ts", "../src/helpers/HealthBarManager.ts", "../src/helpers/GridClickHelper.ts", "../src/PhaserAdapter.ts", "../src/helpers/HUDHelper.ts", "../src/helpers/SpeedDisplay.ts", "../src/helpers/SpriteAttachment.ts", "../src/helpers/DirectionalIndicator.ts", "../src/index.ts", "../src/helpers/DualRuntimeFactory.ts", "../src/runtime.ts"],
  "sourcesContent": ["/**\n * CameraFollower - Automatic camera following for local player\n *\n * Eliminates manual camera positioning code and fixes initialization timing bugs.\n * Automatically waits for player state to be ready, then follows smoothly.\n *\n * ## How it works:\n *\n * - **Initialization:** Uses `waitForMetadata` to wait for player position, then sets initial camera position\n * - **Updates:** Automatically updates camera position every frame based on follow mode\n * - **Modes:**\n *   - `instant`: Camera snaps directly to target (no smoothing)\n *   - `lerp`: Camera smoothly interpolates to target (configurable smoothness)\n *   - `deadzone`: Camera only moves when target leaves deadzone rectangle\n *\n * ## Why this helper exists:\n *\n * Without this helper, games manually set camera position in `update()`, which causes:\n * 1. **Timing bug:** Camera not positioned in `create()`, causing off-screen sprites on navigation\n * 2. **Boilerplate:** Same camera code repeated in every game\n * 3. **Edge cases:** Forgetting to check if player exists, handle player removal, etc.\n *\n * This helper solves all of these automatically.\n *\n * @example\n * ```ts\n * import { createCameraFollower } from '@martini-kit/phaser';\n *\n * // In scene.create() - simplest usage\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer' // Auto-follows local player\n * });\n *\n * // With smooth lerp following\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   mode: 'lerp',\n *   lerpFactor: 0.1 // Lower = smoother, higher = snappier\n * });\n *\n * // With deadzone (camera only moves when player leaves center area)\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   mode: 'deadzone',\n *   deadzone: { width: 200, height: 150 }\n * });\n *\n * // Follow specific player by ID\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: { stateKey: 'players', playerId: 'player-123' }\n * });\n *\n * // Set world bounds\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   bounds: { width: 1600, height: 1200 }\n * });\n *\n * // In scene.update() - camera automatically updates, no manual code needed!\n * // But you can manually update if needed:\n * // this.cameraFollower.update();\n *\n * // In scene shutdown/destroy:\n * this.cameraFollower.destroy();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface CameraFollowerTarget {\n  /**\n   * State key where the player/entity lives (default: 'players')\n   */\n  stateKey?: string;\n\n  /**\n   * Player ID to follow (if not specified, follows local player)\n   */\n  playerId?: string;\n}\n\nexport interface CameraFollowerConfig {\n  /**\n   * Target to follow\n   * - 'myPlayer': Follow local player (default)\n   * - { stateKey: 'players', playerId: 'id' }: Follow specific player\n   */\n  target?: 'myPlayer' | CameraFollowerTarget;\n\n  /**\n   * Follow mode\n   * - 'instant': Camera snaps directly to target (default)\n   * - 'lerp': Camera smoothly interpolates to target\n   * - 'deadzone': Camera only moves when target leaves deadzone\n   */\n  mode?: 'instant' | 'lerp' | 'deadzone';\n\n  /**\n   * Lerp factor for smooth following (0-1)\n   * Lower = smoother but laggier\n   * Higher = snappier but jerkier\n   * Default: 0.1\n   * Only used when mode = 'lerp'\n   */\n  lerpFactor?: number;\n\n  /**\n   * Camera offset from target center\n   * Default: { x: 0, y: 0 }\n   */\n  offset?: { x: number; y: number };\n\n  /**\n   * World bounds for camera\n   * If specified, sets camera bounds to prevent showing outside world\n   */\n  bounds?: { width: number; height: number };\n\n  /**\n   * Deadzone dimensions (only used when mode = 'deadzone')\n   * Camera only moves when target leaves this rectangle\n   * Default: { width: 200, height: 150 }\n   */\n  deadzone?: { width: number; height: number };\n\n  /**\n   * Whether to center camera on target\n   * If true, camera centers on target position\n   * If false, target position is used as-is\n   * Default: true\n   */\n  centerOnTarget?: boolean;\n}\n\nexport interface CameraFollower {\n  /**\n   * Manually update camera position (automatically called each frame)\n   */\n  update: () => void;\n\n  /**\n   * Clean up and stop following\n   */\n  destroy: () => void;\n\n  /**\n   * Change the target being followed\n   */\n  setTarget: (playerId: string) => void;\n\n  /**\n   * Get current target player ID\n   */\n  getTarget: () => string | null;\n}\n\n/**\n * Create a camera follower that automatically tracks a player\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Camera follower configuration\n * @returns CameraFollower instance\n */\nexport function createCameraFollower(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: CameraFollowerConfig = {}\n): CameraFollower {\n  const {\n    target = 'myPlayer',\n    mode = 'instant',\n    lerpFactor = 0.1,\n    offset = { x: 0, y: 0 },\n    bounds,\n    deadzone = { width: 200, height: 150 },\n    centerOnTarget = true,\n  } = config;\n\n  // Resolve target player ID\n  let targetPlayerId: string;\n  let stateKey: string;\n\n  if (target === 'myPlayer') {\n    targetPlayerId = adapter.getMyPlayerId();\n    stateKey = 'players';\n  } else {\n    targetPlayerId = target.playerId || adapter.getMyPlayerId();\n    stateKey = target.stateKey || 'players';\n  }\n\n  const camera = scene.cameras.main;\n  let unsubscribe: (() => void) | null = null;\n  let initialized = false;\n  let destroyed = false;\n\n  // Set world bounds if specified\n  if (bounds) {\n    camera.setBounds(0, 0, bounds.width, bounds.height);\n  }\n\n  // Initialize camera position when player is ready\n  const initializeCamera = () => {\n    const state = adapter['runtime'].getState() as any;\n    const players = state?.[stateKey];\n    const player = players?.[targetPlayerId];\n\n    if (player && typeof player.x === 'number' && typeof player.y === 'number') {\n      // Set initial camera position immediately to prevent off-screen rendering\n      setCameraPosition(player.x, player.y, true);\n      initialized = true;\n    }\n  };\n\n  // Wait for player to exist, then initialize camera\n  unsubscribe = adapter.waitForMetadata(\n    stateKey,\n    targetPlayerId,\n    ['x', 'y'],\n    (playerData) => {\n      if (!initialized && !destroyed) {\n        setCameraPosition(playerData.x, playerData.y, true);\n        initialized = true;\n      }\n    }\n  );\n\n  // Also try to initialize immediately in case player already exists\n  initializeCamera();\n\n  /**\n   * Set camera position based on target coordinates\n   */\n  function setCameraPosition(targetX: number, targetY: number, instant: boolean = false) {\n    if (destroyed) return;\n\n    const viewportWidth = camera.width;\n    const viewportHeight = camera.height;\n\n    // Calculate desired camera position\n    let desiredScrollX: number;\n    let desiredScrollY: number;\n\n    if (centerOnTarget) {\n      // Center camera on target\n      desiredScrollX = targetX - viewportWidth / 2 + offset.x;\n      desiredScrollY = targetY - viewportHeight / 2 + offset.y;\n    } else {\n      // Use target position directly\n      desiredScrollX = targetX + offset.x;\n      desiredScrollY = targetY + offset.y;\n    }\n\n    // Apply follow mode\n    if (instant || mode === 'instant') {\n      camera.scrollX = desiredScrollX;\n      camera.scrollY = desiredScrollY;\n    } else if (mode === 'lerp') {\n      camera.scrollX += (desiredScrollX - camera.scrollX) * lerpFactor;\n      camera.scrollY += (desiredScrollY - camera.scrollY) * lerpFactor;\n    } else if (mode === 'deadzone') {\n      // Calculate target position in screen space\n      const targetScreenX = targetX - camera.scrollX;\n      const targetScreenY = targetY - camera.scrollY;\n\n      const deadzoneLeft = (viewportWidth - deadzone.width) / 2;\n      const deadzoneRight = deadzoneLeft + deadzone.width;\n      const deadzoneTop = (viewportHeight - deadzone.height) / 2;\n      const deadzoneBottom = deadzoneTop + deadzone.height;\n\n      // Only move camera if target is outside deadzone\n      if (targetScreenX < deadzoneLeft) {\n        camera.scrollX += targetScreenX - deadzoneLeft;\n      } else if (targetScreenX > deadzoneRight) {\n        camera.scrollX += targetScreenX - deadzoneRight;\n      }\n\n      if (targetScreenY < deadzoneTop) {\n        camera.scrollY += targetScreenY - deadzoneTop;\n      } else if (targetScreenY > deadzoneBottom) {\n        camera.scrollY += targetScreenY - deadzoneBottom;\n      }\n    }\n  }\n\n  /**\n   * Update camera position based on current player position\n   */\n  function update() {\n    if (destroyed || !initialized) return;\n\n    const state = adapter['runtime'].getState() as any;\n    const players = state?.[stateKey];\n    const player = players?.[targetPlayerId];\n\n    if (player && typeof player.x === 'number' && typeof player.y === 'number') {\n      setCameraPosition(player.x, player.y);\n    }\n  }\n\n  /**\n   * Auto-update camera every frame\n   */\n  const updateEvent = scene.events.on('update', update);\n\n  /**\n   * Clean up resources\n   */\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n\n    scene.events.off('update', update);\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = null;\n    }\n  }\n\n  /**\n   * Change the target being followed\n   */\n  function setTarget(newPlayerId: string) {\n    targetPlayerId = newPlayerId;\n    initialized = false;\n\n    // Clean up old subscription\n    if (unsubscribe) {\n      unsubscribe();\n    }\n\n    // Wait for new player and reinitialize\n    unsubscribe = adapter.waitForMetadata(\n      stateKey,\n      targetPlayerId,\n      ['x', 'y'],\n      (playerData) => {\n        if (!initialized && !destroyed) {\n          setCameraPosition(playerData.x, playerData.y, true);\n          initialized = true;\n        }\n      }\n    );\n  }\n\n  /**\n   * Get current target player ID\n   */\n  function getTarget(): string | null {\n    return targetPlayerId;\n  }\n\n  return {\n    update,\n    destroy,\n    setTarget,\n    getTarget,\n  };\n}\n", "/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Optional: Called after sprite is fully created and ready (onCreate + onCreatePhysics done)\n   * Fires for BOTH initial sprites and late-joining sprites\n   * Use this for inter-sprite setup (collisions, custom logic, event wiring, etc.)\n   *\n   * @example\n   * ```ts\n   * onAdd: (sprite, key, data, context) => {\n   *   // Attach particle emitter\n   *   const trail = this.add.particles(sprite.x, sprite.y, 'particle');\n   *   trail.startFollow(sprite);\n   *\n   *   // Per-sprite collision with unique object\n   *   if (this.boss) {\n   *     this.physics.add.collider(sprite, this.boss);\n   *   }\n   * }\n   * ```\n   */\n  onAdd?: (\n    sprite: any,\n    key: string,\n    data: TData,\n    context: {\n      manager: SpriteManager<TData>;\n      allSprites: Map<string, any>;\n    }\n  ) => void;\n\n  /**\n   * Optional: Keys from the initial data object to sync exactly once\n   * Useful for metadata like player roles that should be available on clients.\n   */\n  staticProperties?: (keyof TData & string)[];\n\n  /**\n   * **Unified Sync Configuration**\n   *\n   * Controls automatic property synchronization between sprites and state.\n   *\n   * @example\n   * ```ts\n   * // Default: Sync sprite \u2192 state (physics-driven, host only)\n   * sync: {\n   *   properties: ['x', 'y', 'rotation', 'alpha'],  // default\n   *   interval: 50  // ms, default\n   * }\n   *\n   * // Adaptive sync: Only sync when sprite moves\n   * sync: {\n   *   properties: ['x', 'y'],\n   *   adaptive: true,  // Skip sync for idle sprites\n   *   adaptiveThreshold: 1  // pixels per frame\n   * }\n   *\n   * // State-driven: Sync state \u2192 sprite (rare, use StateDrivenSpawner instead)\n   * sync: {\n   *   properties: ['x', 'y'],\n   *   direction: 'toSprite'\n   * }\n   * ```\n   */\n  sync?: {\n    /**\n     * Properties to sync (default: ['x', 'y', 'rotation', 'alpha'])\n     */\n    properties?: string[];\n\n    /**\n     * Sync direction (default: 'toState' for SpriteManager)\n     * - 'toState': Sprite properties \u2192 State (physics-driven, host only)\n     * - 'toSprite': State properties \u2192 Sprite (state-driven, rare)\n     */\n    direction?: 'toState' | 'toSprite';\n\n    /**\n     * Sync interval in milliseconds (default: 50ms / 20 FPS)\n     */\n    interval?: number;\n\n    /**\n     * Enable adaptive sync (default: false)\n     * When true, skips sync for idle sprites (reduces bandwidth)\n     */\n    adaptive?: boolean;\n\n    /**\n     * Movement threshold for adaptive sync (default: 1 pixel/frame)\n     * Only syncs if sprite moved more than this distance\n     */\n    adaptiveThreshold?: number;\n  };\n\n\n  /**\n   * Optional label configuration. When provided, SpriteManager renders labels above sprites.\n   */\n  label?: {\n    getText: (data: TData) => string;\n    offset?: { x?: number; y?: number };\n    style?: Phaser.Types.GameObjects.Text.TextStyle;\n  };\n\n  /**\n   * Optional: Namespace for sprite data in state (default: '_sprites')\n   * Use different namespaces to prevent collisions between multiple managers\n   *\n   * @example\n   * ```ts\n   * const playerMgr = adapter.createSpriteManager({\n   *   namespace: 'players',  // \u2192 state.players.*\n   *   onCreate: ...\n   * });\n   *\n   * const enemyMgr = adapter.createSpriteManager({\n   *   namespace: 'enemies',  // \u2192 state.enemies.*\n   *   onCreate: ...\n   * });\n   * ```\n   */\n  namespace?: string;\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private spriteData = new Map<string, TData>();\n  private labels = new Map<\n    string,\n    { text: Phaser.GameObjects.Text; offset?: { x?: number; y?: number } }\n  >();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n  public readonly namespace: string;\n\n  /**\n   * Track sprites created locally via add() method\n   * This eliminates the need to know player IDs for filtering\n   */\n  private localSprites = new Set<string>();\n\n  /**\n   * Phaser Group containing all sprites managed by this SpriteManager.\n   * Use this for collision detection:\n   * @example\n   * ```ts\n   * this.physics.add.collider(ball, playerManager.group);\n   * ```\n   *\n   * The group automatically includes all sprites added to this manager,\n   * both early-joining and late-joining, solving the \"forgot to add collider\n   * for new player\" bug.\n   */\n  public readonly group: Phaser.GameObjects.Group;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n    this.namespace = config.namespace || '_sprites';\n\n    // Create Phaser group for collision management\n    const scene = adapter.getScene();\n    this.group = scene.add.group();\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Track that we created this sprite locally\n    this.localSprites.add(key);\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n    this.spriteData.set(key, data);\n    this.createLabel(key, data, sprite);\n\n    // Add to group for collision management\n    this.group.add(sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    if (this.config.staticProperties?.length) {\n      const staticData: Partial<TData> = {};\n      for (const prop of this.config.staticProperties) {\n        if (prop in data) {\n          staticData[prop] = data[prop];\n        }\n      }\n      if (Object.keys(staticData).length > 0) {\n        this.adapter.setSpriteStaticData(key, staticData, this.namespace);\n      }\n    }\n\n    // Track for automatic sync (host only)\n    const syncProperties = this.config.sync?.properties || ['x', 'y', 'rotation', 'alpha'];\n    const syncInterval = this.config.sync?.interval;\n    const adaptiveSync = this.config.sync?.adaptive;\n    const adaptiveSyncThreshold = this.config.sync?.adaptiveThreshold;\n\n    this.adapter.trackSprite(sprite, key, {\n      properties: syncProperties,\n      syncInterval: syncInterval,\n      namespace: this.namespace,\n      adaptiveSync: adaptiveSync,\n      adaptiveSyncThreshold: adaptiveSyncThreshold\n    });\n\n    // Call onAdd hook (if provided)\n    if (this.config.onAdd) {\n      this.config.onAdd(sprite, key, data, {\n        manager: this,\n        allSprites: this.sprites\n      });\n    }\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n    const label = this.labels.get(key);\n    if (label) {\n      label.text.destroy();\n      this.labels.delete(key);\n    }\n    this.spriteData.delete(key);\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key, this.namespace);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   *\n   * Automatically calls update methods on attached components (arrows, health bars, etc.)\n   * if they use the `_update*` naming convention and autoUpdate is disabled.\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n    this.updateLabels();\n\n    // Auto-call attached component updates (fallback for manual mode)\n    // Note: If attachDirectionalIndicator is using autoUpdate: true (default),\n    // this is redundant but harmless. This provides backward compatibility\n    // for code that set autoUpdate: false and expects manual updates.\n    for (const sprite of this.sprites.values()) {\n      if (typeof sprite._updateArrow === 'function') {\n        sprite._updateArrow();\n      }\n      // Future: _updateHealthBar, _updateNameTag, etc.\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteData = state[this.namespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      // Skip sprites we created locally (pit of success: no player ID needed!)\n      if (this.localSprites.has(key)) {\n        continue;\n      }\n\n      if (!this.sprites.has(key)) {\n        // FIX #1: Wait for static properties before creating sprites (pit of success!)\n        // This prevents the \"sprite created before metadata arrives\" race condition.\n        // Matches the pattern used by PlayerUIManager (lines 200-207).\n        if (this.config.staticProperties?.length) {\n          const hasAllStatic = this.config.staticProperties.every(prop => prop in data);\n          if (!hasAllStatic) {\n            // Static metadata not ready yet - skip creation until next sync\n            continue;\n          }\n        }\n\n        // Create new sprite (now guaranteed to have all static properties!)\n        const sprite = this.config.onCreate(key, data as TData);\n        this.sprites.set(key, sprite);\n        this.spriteData.set(key, data as TData);\n        this.group.add(sprite); // Add to group on client side too\n        this.adapter.registerRemoteSprite(key, sprite, this.namespace);\n        this.createLabel(key, data as TData, sprite);\n\n        // Call onAdd hook (if provided) - runs for late-joining sprites on clients\n        if (this.config.onAdd) {\n          this.config.onAdd(sprite, key, data as TData, {\n            manager: this,\n            allSprites: this.sprites\n          });\n        }\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data as TData);\n        }\n        this.spriteData.set(key, data as TData);\n      }\n\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n\n  private createLabel(key: string, data: TData, sprite: any): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n\n    const scene = this.adapter.getScene();\n    if (!scene?.add?.text) return;\n\n    const textValue = labelConfig.getText(data);\n    const style = labelConfig.style || { fontSize: '12px', color: '#ffffff' };\n    const label = scene.add.text(sprite.x, sprite.y, textValue, style).setOrigin(0.5);\n    this.labels.set(key, { text: label, offset: labelConfig.offset });\n  }\n\n  private updateLabels(): void {\n    for (const key of this.labels.keys()) {\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n  }\n\n  private updateLabelText(key: string): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const data = this.spriteData.get(key);\n    if (!data) return;\n\n    const next = labelConfig.getText(data);\n    if (labelEntry.text.text !== next) {\n      labelEntry.text.setText(next);\n    }\n  }\n\n  private updateLabelPosition(key: string): void {\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    const offsetX = labelEntry.offset?.x ?? 0;\n    const offsetY = labelEntry.offset?.y ?? -20;\n    labelEntry.text.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n  }\n}\n", "/**\n * Input Profiles - Pre-defined control schemes\n *\n * Eliminates manual key binding boilerplate by providing standard control patterns.\n */\n\nimport type { KeyBindings } from './InputManager.js';\n\nexport interface AggregatedProfileConfig {\n  /** Profile type */\n  type: 'aggregated';\n\n  /** Action name to submit */\n  action: string;\n\n  /** Map of field names to key codes */\n  keys: Record<string, string>;\n\n  /** Continuous or oneshot mode */\n  mode?: 'continuous' | 'oneshot';\n}\n\nexport interface PerKeyProfileConfig {\n  /** Profile type */\n  type: 'per-key';\n\n  /** Key bindings for this profile */\n  bindings: KeyBindings;\n}\n\nexport interface InputProfile {\n  /** Profile name */\n  name: string;\n\n  /** Profile configuration (aggregated or per-key) */\n  config: AggregatedProfileConfig | PerKeyProfileConfig;\n\n  /** Description of the control scheme */\n  description?: string;\n}\n\nexport interface ProfileOptions {\n  /** Override specific keys */\n  overrides?: Partial<KeyBindings>;\n\n  /** Player number (1-based). Changes arrow keys to WASD for player 2 */\n  player?: 1 | 2;\n\n  /** Override action names */\n  action?: string;\n}\n\n/**\n * Built-in input profiles\n */\nexport const BUILT_IN_PROFILES: Record<string, InputProfile> = {\n  platformer: {\n    name: 'platformer',\n    description: 'Side-scrolling platformer controls (Arrow keys + Space for jump)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'Space'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  platformerWASD: {\n    name: 'platformerWASD',\n    description: 'Platformer controls with WASD',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDown: {\n    name: 'topDown',\n    description: '4-directional movement (Arrow keys)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'ArrowUp',\n        down: 'ArrowDown'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDownWASD: {\n    name: 'topDownWASD',\n    description: '4-directional movement (WASD)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W',\n        down: 'S'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  shooter: {\n    name: 'shooter',\n    description: 'Top-down shooter (WASD for move, Space for shoot)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'Space': { action: 'shoot', mode: 'oneshot' },\n      }\n    }\n  },\n\n  twinStick: {\n    name: 'twinStick',\n    description: 'Twin-stick shooter (WASD for move, Arrow keys for aim)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'ArrowLeft': { action: 'aim', input: { x: -1 }, mode: 'continuous' },\n        'ArrowRight': { action: 'aim', input: { x: 1 }, mode: 'continuous' },\n        'ArrowUp': { action: 'aim', input: { y: -1 }, mode: 'continuous' },\n        'ArrowDown': { action: 'aim', input: { y: 1 }, mode: 'continuous' },\n      }\n    }\n  }\n};\n\n/**\n * Custom profile registry\n */\nconst customProfiles = new Map<string, InputProfile>();\n\n/**\n * Register a custom input profile\n *\n * @param name - Profile name\n * @param profile - Profile configuration\n *\n * @example\n * ```ts\n * registerProfile('custom-platformer', {\n *   name: 'custom-platformer',\n *   bindings: {\n *     'A': { action: 'move', input: { left: true }, mode: 'continuous' },\n *     'D': { action: 'move', input: { right: true }, mode: 'continuous' },\n *     'W': { action: 'jump', mode: 'oneshot' },\n *   }\n * });\n * ```\n */\nexport function registerProfile(name: string, profile: InputProfile): void {\n  customProfiles.set(name, profile);\n}\n\n/**\n * Get a profile by name (checks custom profiles first, then built-in)\n *\n * @param name - Profile name\n * @returns Profile or undefined if not found\n */\nexport function getProfile(name: string): InputProfile | undefined {\n  return customProfiles.get(name) || BUILT_IN_PROFILES[name];\n}\n\n/**\n * Apply profile options to a profile config\n *\n * @param profile - Original profile\n * @param options - Profile options\n * @returns Modified profile config\n */\nexport function applyProfileOptions(\n  profile: InputProfile,\n  options?: ProfileOptions\n): AggregatedProfileConfig | PerKeyProfileConfig {\n  if (!options) return profile.config;\n\n  const config = profile.config;\n\n  // For aggregated profiles\n  if (config.type === 'aggregated') {\n    let keys = { ...config.keys };\n\n    // Apply player number (swap arrow keys for WASD)\n    if (options.player === 2) {\n      const keyMap: Record<string, string> = {\n        'ArrowLeft': 'A',\n        'ArrowRight': 'D',\n        'ArrowUp': 'W',\n        'ArrowDown': 'S',\n        'Space': 'Space', // Keep Space unchanged\n      };\n\n      const newKeys: Record<string, string> = {};\n      for (const [field, key] of Object.entries(keys)) {\n        newKeys[field] = keyMap[key] || key;\n      }\n      keys = newKeys;\n    }\n\n    return {\n      type: 'aggregated',\n      action: options.action || config.action,\n      keys,\n      mode: config.mode\n    };\n  }\n\n  // For per-key profiles\n  let bindings = { ...config.bindings };\n\n  // Apply player number (swap arrow keys for WASD)\n  if (options.player === 2) {\n    const keyMap: Record<string, string> = {\n      'ArrowLeft': 'A',\n      'ArrowRight': 'D',\n      'ArrowUp': 'W',\n      'ArrowDown': 'S',\n    };\n\n    const newBindings: KeyBindings = {};\n    for (const [key, binding] of Object.entries(bindings)) {\n      const newKey = keyMap[key] || key;\n      newBindings[newKey] = binding;\n    }\n    bindings = newBindings;\n  }\n\n  // Apply action override\n  if (options.action) {\n    for (const key of Object.keys(bindings)) {\n      const binding = bindings[key];\n      if (typeof binding === 'object') {\n        bindings[key] = { ...binding, action: options.action };\n      }\n    }\n  }\n\n  // Apply key overrides\n  if (options.overrides) {\n    for (const [key, binding] of Object.entries(options.overrides)) {\n      if (binding !== undefined) {\n        bindings[key] = binding;\n      }\n    }\n  }\n\n  return {\n    type: 'per-key',\n    bindings\n  };\n}\n\n/**\n * Merge multiple profiles into one\n *\n * @param profileNames - Array of profile names to merge\n * @returns Merged bindings (only works with per-key profiles)\n *\n * @example\n * ```ts\n * const bindings = mergeProfiles(['shooter', 'twinStick']);\n * // Combines multiple per-key profiles\n * ```\n */\nexport function mergeProfiles(profileNames: string[]): KeyBindings {\n  const merged: KeyBindings = {};\n\n  for (const name of profileNames) {\n    const profile = getProfile(name);\n    if (profile && profile.config.type === 'per-key') {\n      Object.assign(merged, profile.config.bindings);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * List all available profiles\n *\n * @returns Array of profile names\n */\nexport function listProfiles(): string[] {\n  return [\n    ...Object.keys(BUILT_IN_PROFILES),\n    ...Array.from(customProfiles.keys())\n  ];\n}\n", "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini-kit/core';\nimport { getProfile, applyProfileOptions, mergeProfiles as mergeProfileBindings, type ProfileOptions } from './InputProfiles.js';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport interface AggregatedBinding {\n  keyMap: Record<string, string>;\n  state: Record<string, any>;\n  mode: 'continuous' | 'oneshot';\n  targetId?: string;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n  private aggregatedBindings = new Map<string, AggregatedBinding>(); // NEW: Track aggregated state\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n    }\n  }\n\n  /**\n   * Bind multiple keys that aggregate into a single input state\n   * Perfect for platformers, twin-stick shooters, fighting games\n   *\n   * Key codes: Use standard DOM key names (ArrowLeft, ArrowRight, ArrowUp, ArrowDown, Space).\n   * Letter keys (A-Z) are automatically uppercased. Arrow keys and Space are automatically\n   * converted to Phaser's internal format (LEFT, RIGHT, UP, DOWN, SPACE).\n   *\n   * @example\n   * ```ts\n   * // Platformer controls - use ArrowLeft/ArrowRight/Space\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'ArrowLeft',\n   *   right: 'ArrowRight',\n   *   up: 'Space'\n   * });\n   * // Automatically tracks: { left: true/false, right: true/false, up: true/false }\n   *\n   * // Top-down movement - letter keys work as-is\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'A',\n   *   right: 'D',\n   *   up: 'W',\n   *   down: 'S'\n   * });\n   * ```\n   */\n  bindKeysAggregated(\n    action: string,\n    keyMap: Record<string, string>,\n    options?: {\n      initialState?: Record<string, any>;\n      mode?: 'continuous' | 'oneshot';\n      targetId?: string;\n    }\n  ): void {\n    // Build initial state (default to false for each field)\n    const state = options?.initialState ||\n      Object.fromEntries(\n        Object.keys(keyMap).map(field => [field, false])\n      );\n\n    this.aggregatedBindings.set(action, {\n      keyMap,\n      state,\n      mode: options?.mode || 'continuous',\n      targetId: options?.targetId\n    });\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n\n    // Handle aggregated bindings (multi-key state tracking)\n    for (const [action, binding] of this.aggregatedBindings.entries()) {\n      let stateChanged = false;\n\n      // Check each key in the map and update state\n      for (const [field, keyCode] of Object.entries(binding.keyMap)) {\n        // IMPORTANT: Convert user-friendly key names to Phaser's internal key codes\n        // Phaser uses uppercase constants (e.g., 'LEFT' not 'ArrowLeft')\n        // This mapping allows users to use standard DOM key names while Phaser expects its own format\n        // See: https://photonstorm.github.io/phaser3-docs/Phaser.Input.Keyboard.KeyCodes.html\n        let phaserKeyCode = keyCode;\n        const keyCodeMap: Record<string, string> = {\n          'ArrowLeft': 'LEFT',\n          'ArrowRight': 'RIGHT',\n          'ArrowUp': 'UP',\n          'ArrowDown': 'DOWN',\n          'Space': 'SPACE'\n        };\n\n        if (keyCodeMap[keyCode]) {\n          phaserKeyCode = keyCodeMap[keyCode];\n        }\n\n        const keyObj = this.scene.input.keyboard?.addKey(phaserKeyCode, false);\n        if (!keyObj) {\n          console.warn(`[InputManager] Failed to create key object for: ${keyCode} (mapped to ${phaserKeyCode})`);\n          continue;\n        }\n\n        const pressed = keyObj.isDown;\n\n        // Update state if changed\n        if (binding.state[field] !== pressed) {\n          binding.state[field] = pressed;\n          stateChanged = true;\n        }\n      }\n\n      // Submit aggregated state ONLY when changed (10x devtools improvement!)\n      // This prevents 60 actions/second when idle\n      if (stateChanged) {\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Use a pre-defined input profile\n   *\n   * @param profileName - Name of the profile ('platformer', 'topDown', 'shooter', etc.)\n   * @param options - Optional customization\n   *\n   * @example\n   * ```ts\n   * // Simple usage\n   * inputManager.useProfile('platformer');\n   *\n   * // With player 2 (uses WASD instead of arrows)\n   * inputManager.useProfile('platformer', { player: 2 });\n   *\n   * // With custom action name\n   * inputManager.useProfile('platformer', { action: 'move' });\n   *\n   * // With key overrides\n   * inputManager.useProfile('platformer', {\n   *   overrides: {\n   *     'Space': { action: 'jump', mode: 'oneshot' }\n   *   }\n   * });\n   * ```\n   */\n  useProfile(profileName: string, options?: ProfileOptions): void {\n    const profile = getProfile(profileName);\n\n    if (!profile) {\n      console.warn(`[InputManager] Profile \"${profileName}\" not found. Available profiles:`, [\n        'platformer', 'platformerWASD', 'topDown', 'topDownWASD', 'shooter', 'twinStick'\n      ]);\n      return;\n    }\n\n    const config = applyProfileOptions(profile, options);\n\n    if (config.type === 'aggregated') {\n      // Use aggregated binding for multi-key state tracking\n      this.bindKeysAggregated(config.action, config.keys, {\n        mode: config.mode\n      });\n    } else {\n      // Use per-key binding for separate actions\n      this.bindKeys(config.bindings);\n    }\n  }\n\n  /**\n   * Merge multiple profiles into one\n   *\n   * @param profileNames - Array of profile names\n   *\n   * @example\n   * ```ts\n   * // Combine platformer movement with shooter actions\n   * inputManager.mergeProfiles(['platformer', 'shooter']);\n   * ```\n   */\n  mergeProfiles(profileNames: string[]): void {\n    const merged = mergeProfileBindings(profileNames);\n    this.bindKeys(merged);\n  }\n\n  /**\n   * Bind edge-triggered actions (fire once on press, not every frame)\n   * Perfect for shoot, jump, interact, etc.\n   *\n   * @example\n   * ```ts\n   * // Shoot on space press\n   * inputManager.bindEdgeTrigger('Space', 'shoot');\n   *\n   * // Jump on up arrow press\n   * inputManager.bindEdgeTrigger('ArrowUp', 'jump');\n   *\n   * // Multiple edge triggers\n   * inputManager.bindEdgeTriggers({\n   *   'Space': 'shoot',\n   *   'E': 'interact',\n   *   'R': 'reload'\n   * });\n   * ```\n   */\n  bindEdgeTrigger(key: string, action: string, input?: any): void {\n    this.keyBindings.set(key.toUpperCase(), {\n      action,\n      input,\n      mode: 'oneshot'\n    });\n  }\n\n  /**\n   * Bind multiple edge-triggered actions at once\n   */\n  bindEdgeTriggers(bindings: Record<string, string | { action: string; input?: any }>): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      if (typeof binding === 'string') {\n        this.bindEdgeTrigger(key, binding);\n      } else {\n        this.bindEdgeTrigger(key, binding.action, binding.input);\n      }\n    }\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * **NEW: Bridge input to actions automatically**\n   *\n   * Eliminates manual edge detection and action submission boilerplate.\n   * Integrates with input profiles for complete automation.\n   *\n   * @example\n   * ```ts\n   * // Simple: Use existing profile bindings\n   * inputManager.useProfile('topDown');\n   * inputManager.bridgeToActions({\n   *   move: 'continuous',  // submits every frame from profile\n   *   shoot: 'edge'        // submits once on press from profile\n   * });\n   *\n   * // Advanced: Custom key mapping\n   * inputManager.bridgeToActions({\n   *   move: { type: 'continuous', keys: { left: 'A', right: 'D', up: 'W', down: 'S' } },\n   *   shoot: { type: 'edge', key: 'SPACE' }\n   * });\n   * ```\n   */\n  bridgeToActions(config: Record<string, 'continuous' | 'edge' | {\n    type: 'continuous' | 'edge';\n    key?: string;\n    keys?: Record<string, string>;\n  }>): void {\n    for (const [action, actionConfig] of Object.entries(config)) {\n      const normalized = typeof actionConfig === 'string'\n        ? { type: actionConfig }\n        : actionConfig;\n\n      if (normalized.type === 'continuous') {\n        // For continuous actions, check if we have aggregated bindings\n        const aggregated = this.aggregatedBindings.get(action);\n        if (aggregated) {\n          // Already configured via useProfile/bindKeysAggregated\n          continue;\n        }\n\n        // Set up new aggregated binding if keys provided\n        if (normalized.keys) {\n          this.bindKeysAggregated(action, normalized.keys, { mode: 'continuous' });\n        }\n      } else if (normalized.type === 'edge') {\n        // For edge triggers, set up binding if key provided\n        if (normalized.key) {\n          this.bindEdgeTrigger(normalized.key, action);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n", "/**\n * PlayerUIManager - Automatic UI synchronization for players\n *\n * Eliminates bugs caused by:\n * - Creating UI before player metadata (side, team, etc.) is synced\n * - Forgetting to update UI when player data changes\n * - Manual loops to create/update/destroy UI elements\n *\n * Features:\n * - Waits for staticProperties before creating UI (no race conditions!)\n * - Auto-repositions UI when metadata changes\n * - Auto-creates UI for late-joining players\n * - Auto-destroys UI when players leave\n *\n * Usage:\n * ```ts\n * const playerUI = adapter.createPlayerUIManager({\n *   score: {\n *     position: (player) => ({\n *       x: player.side === 'left' ? 200 : 600,\n *       y: 80\n *     }),\n *     getText: (player) => String(player.score || 0),\n *     style: { fontSize: '48px', color: '#fff' }\n *   },\n *\n *   health: {\n *     position: (player) => ({ x: player.x, y: player.y - 30 }),\n *     width: 50,\n *     height: 5,\n *     getValue: (player) => player.health / player.maxHealth,\n *     backgroundColor: 0x333333,\n *     foregroundColor: 0x00ff00\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TextUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   * Called when UI is created AND when metadata changes\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Text content function\n   */\n  getText: (player: any, playerId: string) => string;\n\n  /**\n   * Phaser text style\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   * Example: ['side', 'team'] - waits until these are synced\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface BarUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Value function (0-1 range)\n   */\n  getValue: (player: any, playerId: string) => number;\n\n  /**\n   * Bar dimensions\n   */\n  width: number;\n  height: number;\n\n  /**\n   * Colors\n   */\n  backgroundColor: number;\n  foregroundColor: number;\n\n  /**\n   * Bar origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface PlayerUIManagerConfig {\n  /**\n   * UI elements keyed by name\n   * Each element can be text or bar type\n   */\n  [elementName: string]: TextUIConfig | BarUIConfig;\n}\n\ntype UIElement = {\n  type: 'text' | 'bar';\n  config: TextUIConfig | BarUIConfig;\n  gameObject: any; // Phaser.GameObjects.Text | Container with rectangles\n};\n\nexport class PlayerUIManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: PlayerUIManagerConfig;\n  private playerElements: Map<string, Map<string, UIElement>> = new Map(); // playerId -> elementName -> UIElement\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, scene: any, config: PlayerUIManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config;\n\n    // Subscribe to state changes\n    this.unsubscribe = adapter.onChange((state: any) => {\n      this.syncFromState(state);\n    });\n  }\n\n  /**\n   * Get UI element for a specific player\n   */\n  get(playerId: string, elementName: string): any {\n    return this.playerElements.get(playerId)?.get(elementName)?.gameObject;\n  }\n\n  /**\n   * Manually update all UI (also called automatically on state changes)\n   */\n  update(): void {\n    const state = this.adapter.getRuntime().getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Destroy all UI elements\n    for (const [playerId, elements] of this.playerElements.entries()) {\n      for (const [elementName, element] of elements.entries()) {\n        this.destroyElement(element);\n      }\n    }\n    this.playerElements.clear();\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * Sync UI from state\n   */\n  private syncFromState(state: any): void {\n    if (!state.players) return;\n\n    const existingPlayers = new Set(this.playerElements.keys());\n\n    // Create/update UI for each player\n    for (const [playerId, playerData] of Object.entries(state.players) as [string, any][]) {\n      existingPlayers.delete(playerId);\n\n      // Get or create element map for this player\n      let elements = this.playerElements.get(playerId);\n      if (!elements) {\n        elements = new Map();\n        this.playerElements.set(playerId, elements);\n      }\n\n      // Create/update each UI element\n      for (const [elementName, elementConfig] of Object.entries(this.config)) {\n        const existing = elements.get(elementName);\n\n        // Check if required metadata exists\n        const requiredMetadata = (elementConfig as any).requiredMetadata || [];\n        const hasMetadata = requiredMetadata.every((key: string) => key in playerData);\n\n        if (!hasMetadata) {\n          // Metadata not ready yet - skip creation\n          continue;\n        }\n\n        if (!existing) {\n          // Create new UI element\n          const element = this.createElement(elementName, elementConfig, playerId, playerData);\n          if (element) {\n            elements.set(elementName, element);\n          }\n        } else {\n          // Update existing UI element\n          this.updateElement(existing, playerId, playerData);\n        }\n      }\n    }\n\n    // Remove UI for players who left\n    for (const playerId of existingPlayers) {\n      const elements = this.playerElements.get(playerId);\n      if (elements) {\n        for (const element of elements.values()) {\n          this.destroyElement(element);\n        }\n      }\n      this.playerElements.delete(playerId);\n    }\n  }\n\n  /**\n   * Create a UI element\n   */\n  private createElement(\n    elementName: string,\n    config: TextUIConfig | BarUIConfig,\n    playerId: string,\n    playerData: any\n  ): UIElement | null {\n    const pos = config.position(playerData, playerId);\n\n    if (this.isTextConfig(config)) {\n      // Create text element\n      const text = this.scene.add.text(\n        pos.x,\n        pos.y,\n        config.getText(playerData, playerId),\n        config.style || {}\n      );\n\n      if (config.origin !== undefined) {\n        if (typeof config.origin === 'number') {\n          text.setOrigin(config.origin);\n        } else {\n          text.setOrigin(config.origin.x, config.origin.y);\n        }\n      }\n\n      if (config.depth !== undefined) {\n        text.setDepth(config.depth);\n      }\n\n      return {\n        type: 'text',\n        config,\n        gameObject: text\n      };\n    } else {\n      // Create bar element (container with two rectangles)\n      const container = this.scene.add.container(pos.x, pos.y);\n\n      const bg = this.scene.add.rectangle(0, 0, config.width, config.height, config.backgroundColor);\n      const fg = this.scene.add.rectangle(\n        0,\n        0,\n        config.width * config.getValue(playerData, playerId),\n        config.height,\n        config.foregroundColor\n      );\n\n      if (config.origin !== undefined) {\n        const originX = typeof config.origin === 'number' ? config.origin : config.origin.x;\n        const originY = typeof config.origin === 'number' ? config.origin : config.origin.y;\n        bg.setOrigin(originX, originY);\n        fg.setOrigin(originX, originY);\n      }\n\n      container.add([bg, fg]);\n\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n\n      // Store references for updates\n      (container as any)._bg = bg;\n      (container as any)._fg = fg;\n\n      return {\n        type: 'bar',\n        config,\n        gameObject: container\n      };\n    }\n  }\n\n  /**\n   * Update a UI element\n   */\n  private updateElement(element: UIElement, playerId: string, playerData: any): void {\n    const pos = element.config.position(playerData, playerId);\n\n    if (element.type === 'text') {\n      const config = element.config as TextUIConfig;\n      const text = element.gameObject;\n\n      text.setPosition(pos.x, pos.y);\n      text.setText(config.getText(playerData, playerId));\n    } else {\n      const config = element.config as BarUIConfig;\n      const container = element.gameObject;\n      const fg = (container as any)._fg;\n\n      container.setPosition(pos.x, pos.y);\n\n      // Update bar width based on value\n      const value = Math.max(0, Math.min(1, config.getValue(playerData, playerId)));\n      fg.width = config.width * value;\n    }\n  }\n\n  /**\n   * Destroy a UI element\n   */\n  private destroyElement(element: UIElement): void {\n    if (element.gameObject && element.gameObject.destroy) {\n      element.gameObject.destroy();\n    }\n  }\n\n  /**\n   * Type guard for TextUIConfig\n   */\n  private isTextConfig(config: TextUIConfig | BarUIConfig): config is TextUIConfig {\n    return 'getText' in config;\n  }\n}\n", "/**\n * CollisionManager - Declarative collision rule system\n *\n * Eliminates \"forgot to add collider for late-joining player\" bugs by:\n * - Declaring collision rules ONCE\n * - Auto-applying rules to all sprites (early and late-joining)\n * - Supporting sprites, SpriteManagers, and Phaser groups\n *\n * Usage:\n * ```ts\n * const collisionManager = adapter.createCollisionManager();\n *\n * // Register a ball sprite\n * collisionManager.registerSprite('ball', this.ball);\n *\n * // Declare collision rules ONCE\n * collisionManager.addCollision('ball', this.spriteManager);\n * // \u261D\uFE0F Automatically adds colliders for all current AND future paddles!\n *\n * // With custom handler\n * collisionManager.addCollision(this.bulletGroup, this.enemyGroup, {\n *   onCollide: (bullet, enemy) => {\n *     enemy.takeDamage(bullet.damage);\n *     bullet.destroy();\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface CollisionRule {\n  a: string | SpriteManager | any; // Phaser.Physics.Arcade.Group or sprite\n  b: string | SpriteManager | any;\n  handler?: (objA: any, objB: any) => void;\n}\n\nexport interface CollisionManagerConfig {\n  /**\n   * Optional: Global collision handler\n   * Called for all collisions if no specific handler provided\n   */\n  onCollide?: (obj1: any, obj2: any) => void;\n}\n\nexport class CollisionManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: CollisionManagerConfig;\n  private rules: CollisionRule[] = [];\n  private colliders: any[] = []; // Phaser.Physics.Arcade.Collider instances\n  private namedSprites: Map<string, any> = new Map(); // key -> sprite\n  private spriteToColliders: WeakMap<any, Set<any>> = new WeakMap(); // sprite -> Set of colliders\n\n  constructor(adapter: PhaserAdapter, scene: any, config?: CollisionManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config || {};\n  }\n\n  /**\n   * Register a sprite by name (for string-based collision rules)\n   *\n   * @example\n   * ```ts\n   * collisionManager.registerSprite('ball', this.ball);\n   * collisionManager.addCollision('ball', paddleManager);\n   * ```\n   */\n  registerSprite(key: string, sprite: any): void {\n    this.namedSprites.set(key, sprite);\n    // Re-apply all rules to create colliders for this newly registered sprite\n    for (const rule of this.rules) {\n      this.applyRule(rule);\n    }\n  }\n\n  /**\n   * Unregister a sprite by name\n   */\n  unregisterSprite(key: string): void {\n    const sprite = this.namedSprites.get(key);\n    if (sprite) {\n      this.removeCollidersForSprite(sprite);\n    }\n    this.namedSprites.delete(key);\n  }\n\n  /**\n   * Add collision between sprites/groups/managers\n   *\n   * Supports:\n   * - String keys (via registerSprite)\n   * - SpriteManager instances (auto-syncs with new sprites)\n   * - Phaser sprites or groups\n   */\n  addCollision(\n    a: string | SpriteManager | any,\n    b: string | SpriteManager | any,\n    options?: {\n      onCollide?: (obj1: any, obj2: any) => void;\n    }\n  ): void {\n    const rule: CollisionRule = {\n      a,\n      b,\n      handler: options?.onCollide\n    };\n\n    this.rules.push(rule);\n\n    // Apply rule immediately\n    // Note: If either side is a SpriteManager, resolveToObjects() will return\n    // the manager's Phaser Group, which automatically handles all sprites\n    // (both current and future) without needing lifecycle hooks\n    this.applyRule(rule);\n  }\n\n  /**\n   * Remove collision rule\n   */\n  removeCollision(a: string | SpriteManager | any, b: string | SpriteManager | any): void {\n    const ruleIndex = this.rules.findIndex(r =>\n      (r.a === a && r.b === b) || (r.a === b && r.b === a)\n    );\n\n    if (ruleIndex !== -1) {\n      this.rules.splice(ruleIndex, 1);\n      // Note: We don't remove existing colliders, just stop creating new ones\n    }\n  }\n\n  /**\n   * Cleanup all colliders\n   */\n  destroy(): void {\n    for (const collider of this.colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n    }\n    this.colliders.length = 0;\n    this.rules.length = 0;\n    this.namedSprites.clear();\n  }\n\n  /**\n   * Apply a single collision rule (create colliders)\n   */\n  private applyRule(rule: CollisionRule): void {\n    const objectsA = this.resolveToObjects(rule.a);\n    const objectsB = this.resolveToObjects(rule.b);\n\n    if (objectsA.length === 0 || objectsB.length === 0) {\n      // One or both sides have no objects yet\n      return;\n    }\n\n    const handler = rule.handler || this.config.onCollide;\n\n    // Create colliders for each combination\n    for (const objA of objectsA) {\n      for (const objB of objectsB) {\n        // Skip if collider already exists\n        if (this.hasCollider(objA, objB)) {\n          continue;\n        }\n\n        // Create the collider\n        const collider = this.scene.physics.add.collider(objA, objB, handler);\n        this.colliders.push(collider);\n\n        // Track colliders per sprite\n        this.trackCollider(objA, collider);\n        this.trackCollider(objB, collider);\n      }\n    }\n  }\n\n  /**\n   * Resolve a rule target to an array of Phaser objects\n   */\n  private resolveToObjects(target: string | SpriteManager | any): any[] {\n    if (typeof target === 'string') {\n      // It's a named sprite\n      const sprite = this.namedSprites.get(target);\n      return sprite ? [sprite] : [];\n    }\n\n    if (this.isSpriteManager(target)) {\n      // It's a SpriteManager - return its Phaser Group\n      // The group automatically handles all sprites (early and late-joining)\n      return [(target as SpriteManager).group];\n    }\n\n    // It's a raw Phaser object (sprite or group)\n    return [target];\n  }\n\n  /**\n   * Check if target is a SpriteManager\n   */\n  private isSpriteManager(target: any): boolean {\n    return target && typeof target === 'object' && 'getAll' in target && 'add' in target;\n  }\n\n  /**\n   * Check if a collider already exists between two objects\n   */\n  private hasCollider(objA: any, objB: any): boolean {\n    const collidersA = this.spriteToColliders.get(objA);\n    const collidersB = this.spriteToColliders.get(objB);\n\n    if (!collidersA || !collidersB) {\n      return false;\n    }\n\n    // Check if any collider is shared\n    for (const collider of collidersA) {\n      if (collidersB.has(collider)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Track that a collider belongs to a sprite\n   */\n  private trackCollider(sprite: any, collider: any): void {\n    let colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) {\n      colliders = new Set();\n      this.spriteToColliders.set(sprite, colliders);\n    }\n    colliders.add(collider);\n  }\n\n  /**\n   * Remove all colliders associated with a sprite\n   */\n  private removeCollidersForSprite(sprite: any): void {\n    const colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) return;\n\n    for (const collider of colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n      const index = this.colliders.indexOf(collider);\n      if (index !== -1) {\n        this.colliders.splice(index, 1);\n      }\n    }\n\n    this.spriteToColliders.delete(sprite);\n  }\n}\n", "/**\n * PhysicsManager - Automates physics behavior based on inputs\n *\n * Eliminates manual physics loops by automatically reading inputs from state\n * and applying pre-defined or custom physics behaviors.\n *\n * ## Position Syncing (PIT OF SUCCESS!)\n *\n * **NEW:** PhysicsManager now automatically syncs sprite positions BACK to state\n * (enabled by default). This prevents the \"bullets spawn from starting position\" bug\n * where actions reading `state.players[id].x/y` get stale data.\n *\n * **How it works:**\n * 1. PhysicsManager moves sprites via Phaser physics bodies\n * 2. After each physics update, sprite.x/y/rotation \u2192 state.players[id].x/y/rotation\n * 3. Actions can now read current positions from state reliably\n *\n * **When to disable:**\n * - Performance optimization for 100+ entities\n * - You're manually syncing positions elsewhere\n * - Set `syncPositionToState: false` in config\n *\n * ## Velocity Updates (Racing Behavior)\n *\n * PhysicsManager provides velocity data through TWO channels:\n *\n * 1. **Local Events** (`onVelocityChange`) - Host only, no network overhead\n *    - Fast, synchronous updates\n *    - Use for: Host-only displays, debug overlays, analytics\n *    - Example: Dev tools showing real-time physics metrics\n *\n * 2. **State Sync** (`state.players[id].velocity`) - Synced across network\n *    - Automatically written to game state\n *    - Use for: Client HUDs, multiplayer displays\n *    - Example: Speed display visible to all players\n *\n * Helpers like `createSpeedDisplay` use BOTH:\n * - Host: Fast event updates (instant feedback)\n * - Clients: State sync (receives velocity from host)\n *\n * @example\n * ```ts\n * // In scene.create()\n * this.physicsManager = this.adapter.createPhysicsManager({\n *   spriteManager: this.spriteManager,\n *   inputKey: 'inputs',\n *   stateKey: 'players', // optional, defaults to 'players'\n *   syncPositionToState: true // optional, defaults to true (PIT OF SUCCESS!)\n * });\n *\n * this.physicsManager.addBehavior('topDown', {\n *   speed: 200\n * });\n *\n * // Now actions can read current positions from state!\n * // shoot action: bullet.x = state.players[id].x \u2705 (always up to date)\n *\n * // In scene.update()\n * this.physicsManager.update();\n * ```\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PlatformerBehaviorConfig {\n  speed?: number;\n  jumpPower?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    jump?: string;\n  };\n}\n\nexport interface TopDownBehaviorConfig {\n  speed?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    up?: string;\n    down?: string;\n  };\n}\n\nexport interface RacingBehaviorConfig {\n  /** Acceleration rate when accelerating (default: 5) */\n  acceleration?: number;\n  /** Maximum speed (default: 200) */\n  maxSpeed?: number;\n  /** Turn speed in radians per frame (default: 0.05) */\n  turnSpeed?: number;\n  /** Friction/decay multiplier per frame (default: 0.98) */\n  friction?: number;\n  /** Keys for controls */\n  keys?: {\n    left?: string;\n    right?: string;\n    accelerate?: string;\n  };\n}\n\nexport interface CustomBehaviorConfig {\n  apply: (sprite: any, input: any, body: Phaser.Physics.Arcade.Body) => void;\n}\n\nexport type BehaviorConfig = PlatformerBehaviorConfig | TopDownBehaviorConfig | RacingBehaviorConfig | CustomBehaviorConfig;\n\nexport interface PhysicsManagerConfig {\n  /** SpriteManager to get sprites from */\n  spriteManager: SpriteManager;\n\n  /** Key in state to read inputs from (e.g., 'inputs') */\n  inputKey?: string;\n\n  /** Key prefix for sprite keys (defaults to 'player-') */\n  spriteKeyPrefix?: string;\n\n  /**\n   * Automatically sync sprite positions back to state (default: true)\n   *\n   * **PIT OF SUCCESS:** Enabled by default to prevent the \"bullets spawn from\n   * player's starting position\" bug. When PhysicsManager moves sprites via\n   * physics bodies, those positions need to be written back to state so that\n   * actions (like 'shoot') can read the current position.\n   *\n   * Disable only if you have a specific reason (e.g., performance optimization\n   * for 100+ entities, or you're manually syncing positions elsewhere).\n   *\n   * @default true\n   */\n  syncPositionToState?: boolean;\n\n  /**\n   * State key where player/entity data is stored (default: 'players')\n   * Used for syncing positions back to state when syncPositionToState is enabled\n   */\n  stateKey?: string;\n}\n\n/**\n * Simple event emitter for velocity changes\n */\nclass VelocityEmitter {\n  private listeners: Array<(playerId: string, velocity: number) => void> = [];\n\n  on(callback: (playerId: string, velocity: number) => void): () => void {\n    this.listeners.push(callback);\n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  emit(playerId: string, velocity: number): void {\n    for (const listener of this.listeners) {\n      listener(playerId, velocity);\n    }\n  }\n}\n\nexport class PhysicsManager {\n  private runtime: GameRuntime;\n  private spriteManager: SpriteManager;\n  private inputKey: string;\n  private spriteKeyPrefix: string;\n  private syncPositionToState: boolean;\n  private stateKey: string;\n  private behaviorType: 'platformer' | 'topDown' | 'racing' | 'custom' | null = null;\n  private behaviorConfig: BehaviorConfig | null = null;\n  private velocities: Map<string, number> = new Map(); // Track velocity for racing behavior\n  private velocityEmitter = new VelocityEmitter(); // Event emitter for velocity changes\n\n  constructor(runtime: GameRuntime, config: PhysicsManagerConfig) {\n    this.runtime = runtime;\n    this.spriteManager = config.spriteManager;\n    this.inputKey = config.inputKey || 'inputs';\n    this.spriteKeyPrefix = config.spriteKeyPrefix || 'player-';\n    this.syncPositionToState = config.syncPositionToState !== false; // default true\n    this.stateKey = config.stateKey || 'players';\n  }\n\n  /**\n   * Get velocity for a specific player (racing behavior only)\n   * Useful for displaying speed in HUD\n   *\n   * @param playerId - The player ID to get velocity for\n   * @returns Current velocity, or 0 if not found\n   *\n   * @example\n   * ```ts\n   * const speed = physicsManager.getVelocity(adapter.getLocalPlayerId());\n   * ```\n   */\n  getVelocity(playerId: string): number {\n    return this.velocities.get(playerId) || 0;\n  }\n\n  /**\n   * Get readonly access to all velocities (for debugging/UI)\n   * Returns a readonly map of player IDs to their current velocities\n   */\n  getVelocities(): ReadonlyMap<string, number> {\n    return this.velocities;\n  }\n\n  /**\n   * Subscribe to velocity changes (racing behavior only)\n   *\n   * **Important:** This is a LOCAL event that only fires on the HOST.\n   * Events do NOT cross the network boundary.\n   *\n   * Use cases:\n   * - Host-only displays (debug overlays, dev tools)\n   * - Performance-critical updates (no network overhead)\n   * - Analytics/telemetry (host-side tracking)\n   *\n   * For client displays, use `createSpeedDisplay()` helper which automatically\n   * handles both events (host) and state sync (clients).\n   *\n   * Alternatively, read `state.players[playerId].velocity` which is automatically\n   * synced across the network by PhysicsManager.\n   *\n   * @param callback - Called whenever a player's velocity changes (host only)\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Host-only analytics\n   * const unsubscribe = physicsManager.onVelocityChange((playerId, velocity) => {\n   *   if (velocity > 250) {\n   *     trackAchievement('speed_demon', playerId);\n   *   }\n   * });\n   *\n   * // Later, cleanup\n   * unsubscribe();\n   * ```\n   */\n  onVelocityChange(callback: (playerId: string, velocity: number) => void): () => void {\n    return this.velocityEmitter.on(callback);\n  }\n\n  /**\n   * Add a physics behavior\n   *\n   * @param type - Behavior type ('platformer', 'topDown', 'racing', 'custom')\n   * @param config - Behavior configuration\n   */\n  addBehavior(\n    type: 'platformer',\n    config?: PlatformerBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'topDown',\n    config?: TopDownBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'racing',\n    config?: RacingBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'custom',\n    config: CustomBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'platformer' | 'topDown' | 'racing' | 'custom',\n    config?: BehaviorConfig\n  ): void {\n    this.behaviorType = type;\n    this.behaviorConfig = config || {};\n  }\n\n  /**\n   * Update physics for all sprites (call in scene.update())\n   * Only runs on host.\n   */\n  update(): void {\n    // Only host applies physics\n    const transport = this.runtime.getTransport();\n    if (!transport.isHost()) return;\n\n    const state = this.runtime.getState() as any;\n    const inputs = state[this.inputKey];\n    if (!inputs) return;\n\n    // Apply physics to each player based on their input\n    for (const [playerId, playerInput] of Object.entries(inputs)) {\n      const sprite = this.spriteManager.get(`${this.spriteKeyPrefix}${playerId}`);\n      if (!sprite || !sprite.body) continue;\n\n      const body = sprite.body as Phaser.Physics.Arcade.Body;\n\n      if (this.behaviorType === 'platformer') {\n        this.applyPlatformerBehavior(body, playerInput as any, this.behaviorConfig as PlatformerBehaviorConfig);\n      } else if (this.behaviorType === 'topDown') {\n        this.applyTopDownBehavior(body, playerInput as any, this.behaviorConfig as TopDownBehaviorConfig);\n      } else if (this.behaviorType === 'racing') {\n        this.applyRacingBehavior(sprite, body, playerInput as any, playerId, this.behaviorConfig as RacingBehaviorConfig);\n      } else if (this.behaviorType === 'custom' && this.behaviorConfig) {\n        const customConfig = this.behaviorConfig as CustomBehaviorConfig;\n        customConfig.apply(sprite, playerInput, body);\n      }\n\n      // Sync sprite position back to state (PIT OF SUCCESS!)\n      // This ensures actions reading from state (e.g., shoot) get current positions\n      if (this.syncPositionToState) {\n        this.syncPositionToStateForPlayer(playerId, sprite);\n      }\n    }\n  }\n\n  private applyPlatformerBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: PlatformerBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const jumpPower = config.jumpPower || 350;\n    const keys = config.keys || { left: 'left', right: 'right', jump: 'up' };\n\n    // Horizontal movement\n    if (input[keys.left!]) {\n      body.setVelocityX(-speed);\n    } else if (input[keys.right!]) {\n      body.setVelocityX(speed);\n    } else {\n      body.setVelocityX(0);\n    }\n\n    // Jumping (only if on ground)\n    if (input[keys.jump!] && body.touching.down) {\n      body.setVelocityY(-jumpPower);\n    }\n  }\n\n  private applyTopDownBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: TopDownBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const keys = config.keys || { left: 'left', right: 'right', up: 'up', down: 'down' };\n\n    let vx = 0;\n    let vy = 0;\n\n    if (input[keys.left!]) vx = -speed;\n    if (input[keys.right!]) vx = speed;\n    if (input[keys.up!]) vy = -speed;\n    if (input[keys.down!]) vy = speed;\n\n    body.setVelocity(vx, vy);\n  }\n\n  private applyRacingBehavior(\n    sprite: any,\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    playerId: string,\n    config: RacingBehaviorConfig\n  ): void {\n    const acceleration = config.acceleration ?? 5;\n    const maxSpeed = config.maxSpeed ?? 200;\n    const turnSpeed = config.turnSpeed ?? 0.05;\n    const friction = config.friction ?? 0.98;\n    const keys = config.keys || { left: 'left', right: 'right', accelerate: 'up' };\n\n    // Get or initialize velocity for this player\n    const prevVelocity = this.velocities.get(playerId) || 0;\n    let velocity = prevVelocity;\n\n    // Rotation (turning)\n    if (input[keys.left!]) {\n      sprite.rotation -= turnSpeed;\n    }\n    if (input[keys.right!]) {\n      sprite.rotation += turnSpeed;\n    }\n\n    // Acceleration\n    if (input[keys.accelerate!]) {\n      velocity = Math.min(velocity + acceleration, maxSpeed);\n    } else {\n      // Apply friction when not accelerating\n      velocity *= friction;\n      // Snap to zero when very slow (avoid asymptotic decay)\n      if (velocity < 0.5) {\n        velocity = 0;\n      }\n    }\n\n    // Store velocity locally\n    this.velocities.set(playerId, velocity);\n\n    // Sync velocity to state so clients can display it\n    this.runtime.mutateState((state: any) => {\n      if (state.players && state.players[playerId]) {\n        state.players[playerId].velocity = velocity;\n      }\n    });\n\n    // Emit event for local reactive displays (host only)\n    this.velocityEmitter.emit(playerId, velocity);\n\n    // Apply velocity in the direction of rotation\n    const vx = Math.cos(sprite.rotation) * velocity;\n    const vy = Math.sin(sprite.rotation) * velocity;\n    body.setVelocity(vx, vy);\n  }\n\n  /**\n   * Sync sprite position and rotation back to state\n   * Called automatically after physics updates when syncPositionToState is enabled\n   */\n  private syncPositionToStateForPlayer(playerId: string, sprite: any): void {\n    this.runtime.mutateState((state: any) => {\n      const entities = state[this.stateKey];\n      if (entities && entities[playerId]) {\n        // Always sync position (this is what PhysicsManager controls)\n        entities[playerId].x = sprite.x;\n        entities[playerId].y = sprite.y;\n\n        // Only sync rotation for racing behavior, where sprite.rotation is modified by physics\n        // For topDown/platformer, rotation is typically managed by actions/game logic\n        if (this.behaviorType === 'racing' && sprite.rotation !== undefined) {\n          entities[playerId].rotation = sprite.rotation;\n        }\n      }\n    });\n  }\n}\n", "/**\n * StateDrivenSpawner - Automatic sprite spawning from state collections\n *\n * Eliminates the manual \"check for new players/bullets\" loop in every demo.\n * Watches a state collection (e.g., state.players, state.bullets) and automatically\n * creates/removes sprites as the collection changes.\n *\n * **PIT OF SUCCESS: Positions sync from state by default!**\n * Sprites automatically follow state.x/y changes unless you opt-out.\n *\n * **NEW: Automatic physics integration!**\n * Projectiles/moving entities automatically update from velocity - no manual position updates needed!\n *\n * Usage:\n * ```ts\n * // State-driven entities (default - positions sync automatically!)\n * const blobSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'players',\n *   spriteManager: this.spriteManager,\n *   keyPrefix: 'player-'\n *   // syncProperties: ['x', 'y'] is automatic! Just mutate state and sprites follow.\n * });\n *\n * // NEW: Velocity-based movement (projectiles, moving entities)\n * const bulletSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'bullets',\n *   spriteManager: this.bulletManager,\n *   keyField: 'id',\n *   physics: {\n *     velocityFromState: { x: 'velocityX', y: 'velocityY' }\n *   }\n * });\n *\n * // In scene.update():\n * bulletSpawner.update(delta); // Automatically updates positions from velocity!\n *\n * // Physics-driven entities (opt-out of position sync)\n * const paddleSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'players',\n *   spriteManager: this.spriteManager,\n *   keyPrefix: 'player-',\n *   syncProperties: [] // Empty = physics body controls position, not state\n * });\n *\n * // Custom properties (override default)\n * const bulletSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'bullets',\n *   spriteManager: this.bulletManager,\n *   syncProperties: ['x', 'y', 'rotation', 'alpha'] // Sync more than just position\n * });\n * ```\n *\n * This automatically:\n * - Creates sprites when new entries appear in state\n * - **Syncs x,y from state to sprites by default (opt-out with syncProperties: [])**\n * - **NEW: Updates positions from velocity automatically (opt-in with physics config)**\n * - Removes sprites when entries are deleted\n * - Works on both HOST (initial + late joins) and CLIENT (state sync)\n * - Handles arrays (bullets) and objects (players)\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PhysicsConfig {\n  /**\n   * Automatically update position from velocity in state\n   *\n   * @example\n   * ```ts\n   * velocityFromState: { x: 'velocityX', y: 'velocityY' }\n   * ```\n   *\n   * This will automatically apply:\n   * ```ts\n   * data.x += data.velocityX * deltaSeconds;\n   * data.y += data.velocityY * deltaSeconds;\n   * ```\n   */\n  velocityFromState?: { x: string; y: string };\n\n  /**\n   * Future: Acceleration support\n   * acceleration?: { x: string; y: string };\n   * friction?: number;\n   */\n}\n\nexport interface StateDrivenSpawnerConfig {\n  /**\n   * Path to the collection in state (e.g., 'players', 'bullets', 'powerUps')\n   */\n  stateKey: string;\n\n  /**\n   * The SpriteManager to spawn sprites into\n   */\n  spriteManager: SpriteManager;\n\n  /**\n   * Optional prefix for sprite keys (e.g., 'player-' \u2192 'player-abc123')\n   */\n  keyPrefix?: string;\n\n  /**\n   * For array collections, which field to use as the unique key\n   * (e.g., 'id' for bullets)\n   * If not provided, assumes state collection is an object and uses its keys\n   */\n  keyField?: string;\n\n  /**\n   * Optional filter function - only spawn if this returns true\n   * @example\n   * ```ts\n   * filter: (data) => data.isAlive // Only spawn living entities\n   * ```\n   */\n  filter?: (data: any) => boolean;\n\n  /**\n   * **Unified Sync Configuration**\n   *\n   * Controls automatic property synchronization from state to sprites.\n   * **DEFAULT: Syncs ['x', 'y'] from state to sprites** (PIT OF SUCCESS!)\n   *\n   * @example\n   * ```ts\n   * // Default: State \u2192 Sprite position sync (automatic!)\n   * // sync: { properties: ['x', 'y'], direction: 'toSprite' }\n   *\n   * // Physics-driven: No sync (physics body controls position)\n   * sync: { properties: [] }\n   *\n   * // Custom properties\n   * sync: { properties: ['x', 'y', 'rotation', 'alpha'] }\n   * ```\n   */\n  sync?: {\n    /**\n     * Properties to sync (default: ['x', 'y'])\n     */\n    properties?: string[];\n\n    /**\n     * Sync direction (always 'toSprite' for StateDrivenSpawner)\n     */\n    direction?: 'toSprite';\n  };\n\n\n  /**\n   * Custom update function for more complex sprite syncing\n   * If provided, this takes precedence over syncProperties\n   *\n   * @example\n   * ```ts\n   * onUpdateSprite: (sprite, data) => {\n   *   sprite.x = data.x;\n   *   sprite.y = data.y;\n   *   sprite.setAlpha(data.health / 100);\n   * }\n   * ```\n   */\n  onUpdateSprite?: (sprite: any, data: any) => void;\n\n  /**\n   * **NEW: Automatic physics integration**\n   *\n   * Automatically update entity positions from velocity in state.\n   * Eliminates manual `entity.x += entity.velocityX * deltaSeconds` boilerplate.\n   *\n   * **Benefits:**\n   * - 80% less code for projectiles/moving entities\n   * - \"Pit of success\" - velocity-based movement just works\n   * - Consistent with PhysicsManager mental model\n   *\n   * @example\n   * ```ts\n   * // Simple projectiles\n   * const bulletSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'bullets',\n   *   spriteManager: bulletManager,\n   *   keyField: 'id',\n   *   physics: {\n   *     velocityFromState: { x: 'velocityX', y: 'velocityY' }\n   *   }\n   * });\n   *\n   * // In update loop:\n   * bulletSpawner.updatePhysics(delta); // Automatically updates positions!\n   * ```\n   */\n  physics?: PhysicsConfig;\n}\n\nexport class StateDrivenSpawner {\n  private config: StateDrivenSpawnerConfig;\n  private adapter: PhaserAdapter;\n  private trackedKeys = new Set<string>();\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: StateDrivenSpawnerConfig) {\n    this.adapter = adapter;\n\n    // PIT OF SUCCESS: Default to syncing positions from state\n    if (!config.sync?.properties && !config.onUpdateSprite) {\n      // Default: sync x,y from state to sprites\n      config.sync = { properties: ['x', 'y'], direction: 'toSprite' };\n    }\n\n    this.config = config;\n\n    // HOST: Poll state every update to spawn new entries\n    // CLIENT: React to state changes via onChange\n    if (adapter.isHost()) {\n      // Host checks state directly (no onChange subscription needed)\n      // Just need to call update() from scene\n    } else {\n      // Client subscribes to state changes\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Call this in scene.update() (HOST ONLY)\n   * Checks for new entries in the state collection and spawns sprites\n   *\n   * @param delta - Optional delta time in milliseconds for physics updates\n   *\n   * @example\n   * ```ts\n   * update(time: number, delta: number) {\n   *   // Without physics: just sync spawning/despawning\n   *   spawner.update();\n   *\n   *   // With physics: update positions from velocity\n   *   spawner.update(delta);\n   * }\n   * ```\n   */\n  update(delta?: number): void {\n    if (!this.adapter.isHost()) {\n      return; // Client uses onChange subscription instead\n    }\n\n    // Update physics before syncing (so new positions are synced)\n    if (delta !== undefined && this.config.physics) {\n      this.updatePhysics(delta);\n    }\n\n    const state = this.adapter.getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * **NEW: Automatic physics updates**\n   *\n   * Updates entity positions from velocity in state.\n   * Call this in your scene.update() with delta time.\n   *\n   * **Only runs on HOST** - clients receive position updates via state sync.\n   *\n   * @param delta - Delta time in milliseconds\n   *\n   * @example\n   * ```ts\n   * update(time: number, delta: number) {\n   *   bulletSpawner.updatePhysics(delta);\n   *   bulletSpawner.update(); // Sync sprites to new positions\n   * }\n   * ```\n   */\n  updatePhysics(delta: number): void {\n    if (!this.adapter.isHost()) {\n      return; // Only host updates physics - clients get state sync\n    }\n\n    if (!this.config.physics?.velocityFromState) {\n      return; // No physics config\n    }\n\n    const state = this.adapter.getState();\n    const collection = state[this.config.stateKey];\n    if (!collection) return;\n\n    const deltaSeconds = delta / 1000;\n    const { x: velXKey, y: velYKey } = this.config.physics.velocityFromState;\n\n    // Determine if collection is array or object\n    const isArray = Array.isArray(collection);\n\n    // Extract entries\n    const entries: Array<[string, any]> = isArray\n      ? collection.map((item: any) => {\n          const key = this.config.keyField ? item[this.config.keyField] : item.id;\n          return [String(key), item];\n        })\n      : Object.entries(collection);\n\n    // Update positions from velocity\n    for (const [_, data] of entries) {\n      // Apply filter if provided\n      if (this.config.filter && !this.config.filter(data)) {\n        continue;\n      }\n\n      // Check if velocity properties exist in state\n      if (velXKey in data && velYKey in data) {\n        // Update position from velocity\n        // Initialize position if missing\n        if (!('x' in data)) data.x = 0;\n        if (!('y' in data)) data.y = 0;\n\n        data.x += data[velXKey] * deltaSeconds;\n        data.y += data[velYKey] * deltaSeconds;\n      }\n    }\n  }\n\n  /**\n   * Manually trigger a sync (useful for initial spawn in create())\n   */\n  sync(): void {\n    const state = this.adapter.getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Core sync logic - creates/removes sprites based on state\n   */\n  private syncFromState(state: any): void {\n    const collection = state[this.config.stateKey];\n    if (!collection) return;\n\n    const currentKeys = new Set<string>();\n\n    // Determine if collection is array or object\n    const isArray = Array.isArray(collection);\n\n    // Extract entries\n    const entries: Array<[string, any]> = isArray\n      ? collection.map((item: any) => {\n          const key = this.config.keyField ? item[this.config.keyField] : item.id;\n          return [String(key), item];\n        })\n      : Object.entries(collection);\n\n    // Create/update sprites for entries\n    for (const [rawKey, data] of entries) {\n      // Apply filter if provided\n      if (this.config.filter && !this.config.filter(data)) {\n        continue;\n      }\n\n      const spriteKey = this.config.keyPrefix ? `${this.config.keyPrefix}${rawKey}` : rawKey;\n      currentKeys.add(spriteKey);\n\n      // If sprite already exists, update its properties\n      if (this.trackedKeys.has(spriteKey)) {\n        this.updateSpriteFromState(spriteKey, data);\n        continue;\n      }\n\n      // Create sprite (only on HOST - SpriteManager handles client sync)\n      if (this.adapter.isHost()) {\n        this.config.spriteManager.add(spriteKey, data);\n        this.trackedKeys.add(spriteKey);\n      } else {\n        // On client, just track that we've seen it (SpriteManager creates it via state sync)\n        this.trackedKeys.add(spriteKey);\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const spriteKey of this.trackedKeys) {\n      if (!currentKeys.has(spriteKey)) {\n        this.config.spriteManager.remove(spriteKey);\n        this.trackedKeys.delete(spriteKey);\n      }\n    }\n  }\n\n  /**\n   * Update sprite properties from state data\n   * Only runs on HOST (clients get updates via SpriteManager sync)\n   */\n  private updateSpriteFromState(spriteKey: string, data: any): void {\n    // Only update on host - clients rely on SpriteManager's automatic sync\n    if (!this.adapter.isHost()) {\n      return;\n    }\n\n    const sprite = this.config.spriteManager.get(spriteKey);\n    if (!sprite) return;\n\n    // Custom update function takes precedence\n    if (this.config.onUpdateSprite) {\n      this.config.onUpdateSprite(sprite, data);\n      return;\n    }\n\n    // Sync properties using unified API\n    const syncProperties = this.config.sync?.properties;\n    if (syncProperties) {\n      for (const prop of syncProperties) {\n        if (prop in data && sprite[prop] !== undefined) {\n          sprite[prop] = data[prop];\n        }\n      }\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    this.unsubscribe?.();\n  }\n}\n", "/**\n * HealthBarManager - Auto-synced health bars for sprites\n *\n * Eliminates manual health bar creation, positioning, scaling, and color updates.\n * One-liner attachment like directional indicators, auto-updates from state.\n *\n * Usage:\n * ```ts\n * const healthBars = adapter.createHealthBarManager({\n *   spriteManager: this.spriteManager,\n *   healthKey: 'health',\n *   maxHealth: 100,\n *   offset: { x: 0, y: -30 },\n *   width: 50,\n *   height: 5\n * });\n *\n * // That's it! Health bars auto-create, auto-position, auto-scale, auto-color!\n * // Just call in update():\n * healthBars.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\nimport type Phaser from 'phaser';\n\nexport interface HealthBarConfig {\n  /**\n   * SpriteManager to attach health bars to\n   */\n  spriteManager: SpriteManager;\n\n  /**\n   * Path to health value in state (e.g., 'health', 'hp', 'lives')\n   */\n  healthKey: string;\n\n  /**\n   * Maximum health value for scaling\n   */\n  maxHealth: number;\n\n  /**\n   * Offset from sprite center\n   */\n  offset?: { x?: number; y?: number };\n\n  /**\n   * Health bar dimensions\n   */\n  width?: number;\n  height?: number;\n\n  /**\n   * Color thresholds for health bar\n   * Default: green > 50%, yellow > 25%, red <= 25%\n   */\n  colorThresholds?: {\n    high?: { value: number; color: number };\n    medium?: { value: number; color: number };\n    low?: { value: number; color: number };\n  };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Show background bar (darker shade)\n   */\n  showBackground?: boolean;\n\n  /**\n   * Background bar color\n   */\n  backgroundColor?: number;\n}\n\nexport class HealthBarManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: HealthBarConfig;\n  private healthBars = new Map<string, {\n    bar: Phaser.GameObjects.Rectangle;\n    background?: Phaser.GameObjects.Rectangle;\n  }>();\n\n  constructor(adapter: PhaserAdapter, config: HealthBarConfig) {\n    this.adapter = adapter;\n    this.scene = adapter.getScene();\n    this.config = {\n      offset: { x: 0, y: -30 },\n      width: 50,\n      height: 5,\n      colorThresholds: {\n        high: { value: 50, color: 0x48bb78 },   // Green\n        medium: { value: 25, color: 0xeab308 }, // Yellow\n        low: { value: 0, color: 0xef4444 }      // Red\n      },\n      depth: 100,\n      showBackground: true,\n      backgroundColor: 0x333333,\n      ...config\n    };\n\n    // Listen for sprite additions via SpriteManager\n    // We'll create health bars in update() when we detect new sprites\n  }\n\n  /**\n   * Update all health bars\n   * Call this in your scene's update() loop\n   */\n  update(): void {\n    const state = this.adapter.getState();\n    const sprites = this.config.spriteManager.getAll();\n\n    // Create health bars for new sprites\n    for (const [key, sprite] of sprites) {\n      if (!this.healthBars.has(key)) {\n        this.createHealthBar(key, sprite);\n      }\n    }\n\n    // Update existing health bars\n    for (const [key, healthBarObj] of this.healthBars.entries()) {\n      const sprite = sprites.get(key);\n      if (!sprite) {\n        // Sprite removed, cleanup\n        this.removeHealthBar(key);\n        continue;\n      }\n\n      // Extract player/entity ID from sprite key\n      const entityId = this.extractEntityId(key);\n      const entityState = this.getEntityState(state, entityId);\n\n      if (!entityState) {\n        continue;\n      }\n\n      // Get health value\n      const health = entityState[this.config.healthKey];\n      if (health === undefined) {\n        continue;\n      }\n\n      // Update position\n      const offsetX = this.config.offset?.x ?? 0;\n      const offsetY = this.config.offset?.y ?? -30;\n      healthBarObj.bar.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n\n      if (healthBarObj.background) {\n        healthBarObj.background.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n      }\n\n      // Update scale\n      const healthPercent = health / this.config.maxHealth;\n      healthBarObj.bar.setScale(Math.max(0, healthPercent), 1);\n\n      // Update color based on health\n      const color = this.getColorForHealth(healthPercent * 100);\n      healthBarObj.bar.setFillStyle(color);\n    }\n  }\n\n  /**\n   * Manually create a health bar for a sprite\n   */\n  private createHealthBar(key: string, sprite: any): void {\n    const width = this.config.width ?? 50;\n    const height = this.config.height ?? 5;\n    const offsetX = this.config.offset?.x ?? 0;\n    const offsetY = this.config.offset?.y ?? -30;\n\n    // Create background bar (if enabled)\n    let background: Phaser.GameObjects.Rectangle | undefined;\n    if (this.config.showBackground) {\n      background = this.scene.add.rectangle(\n        sprite.x + offsetX,\n        sprite.y + offsetY,\n        width,\n        height,\n        this.config.backgroundColor\n      );\n      background?.setDepth(this.config.depth ?? 100);\n    }\n\n    // Create foreground bar\n    const bar = this.scene.add.rectangle(\n      sprite.x + offsetX,\n      sprite.y + offsetY,\n      width,\n      height,\n      this.config.colorThresholds?.high?.color ?? 0x48bb78\n    );\n    bar.setDepth((this.config.depth ?? 100) + 1);\n    bar.setOrigin(0, 0.5); // Left-aligned for scale effect\n\n    // Adjust background origin to match\n    background?.setOrigin(0, 0.5);\n\n    this.healthBars.set(key, { bar, background });\n  }\n\n  /**\n   * Remove a health bar\n   */\n  private removeHealthBar(key: string): void {\n    const healthBarObj = this.healthBars.get(key);\n    if (healthBarObj) {\n      healthBarObj.bar.destroy();\n      healthBarObj.background?.destroy();\n      this.healthBars.delete(key);\n    }\n  }\n\n  /**\n   * Extract entity ID from sprite key\n   * Assumes format like \"player-abc123\" or \"enemy-xyz789\"\n   */\n  private extractEntityId(key: string): string {\n    const parts = key.split('-');\n    return parts.length > 1 ? parts.slice(1).join('-') : key;\n  }\n\n  /**\n   * Get entity state from game state\n   * Tries common state keys: players, enemies, entities\n   */\n  private getEntityState(state: any, entityId: string): any {\n    if (state.players?.[entityId]) {\n      return state.players[entityId];\n    }\n    if (state.enemies?.[entityId]) {\n      return state.enemies[entityId];\n    }\n    if (state.entities?.[entityId]) {\n      return state.entities[entityId];\n    }\n    return null;\n  }\n\n  /**\n   * Get color based on health percentage\n   */\n  private getColorForHealth(healthPercent: number): number {\n    const thresholds = this.config.colorThresholds!;\n\n    if (healthPercent > (thresholds.high?.value ?? 50)) {\n      return thresholds.high?.color ?? 0x48bb78;\n    } else if (healthPercent > (thresholds.medium?.value ?? 25)) {\n      return thresholds.medium?.color ?? 0xeab308;\n    } else {\n      return thresholds.low?.color ?? 0xef4444;\n    }\n  }\n\n  /**\n   * Cleanup all health bars\n   */\n  destroy(): void {\n    for (const key of this.healthBars.keys()) {\n      this.removeHealthBar(key);\n    }\n  }\n}\n", "/**\n * GridClickHelper - Robust grid/board click handling\n *\n * Solves the common problem of grid-based games where interactive rectangles\n * don't scale properly with the canvas. Uses pointer.worldX/worldY for\n * accurate coordinate-to-grid mapping that works in any scale mode.\n *\n * Perfect for: Connect Four, Chess, Tic-Tac-Toe, Minesweeper, Battleship,\n * Checkers, Go, Reversi, Sudoku, Bejeweled, etc.\n *\n * Usage:\n * ```ts\n * const gridHelper = adapter.createClickableGrid({\n *   columns: 7,\n *   rows: 6,\n *   cellWidth: 80,\n *   cellHeight: 80,\n *   offsetX: 100,\n *   offsetY: 100,\n *   onCellClick: (col, row) => {\n *     runtime.submitAction('dropToken', { col });\n *   },\n *   highlightColor: 0xffffff,\n *   highlightAlpha: 0.15\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface GridClickConfig {\n  /** Number of columns in the grid */\n  columns: number;\n\n  /** Number of rows in the grid */\n  rows: number;\n\n  /** Width of each cell in pixels */\n  cellWidth: number;\n\n  /** Height of each cell in pixels */\n  cellHeight: number;\n\n  /** X offset of the grid's top-left corner (in world coordinates) */\n  offsetX: number;\n\n  /** Y offset of the grid's top-left corner (in world coordinates) */\n  offsetY: number;\n\n  /** Callback when a cell is clicked - receives (col, row) */\n  onCellClick: (col: number, row: number) => void;\n\n  /**\n   * Optional: Validate if a cell can be clicked\n   * Return true to allow click, false to block\n   */\n  canClick?: (col: number, row: number) => boolean;\n\n  /**\n   * Optional: Validate if a cell can be highlighted on hover\n   * Return true to show highlight, false to hide\n   */\n  canHighlight?: (col: number, row: number) => boolean;\n\n  /** Optional: Highlight color (default: 0xffffff) */\n  highlightColor?: number;\n\n  /** Optional: Highlight alpha (default: 0.15) */\n  highlightAlpha?: number;\n\n  /** Optional: Show cursor pointer on hover (default: true) */\n  useHandCursor?: boolean;\n\n  /**\n   * Optional: Grid layout mode\n   * - 'top-left': (0,0) is top-left corner (default for most grids)\n   * - 'bottom-left': (0,0) is bottom-left corner (for Connect Four, platformers)\n   */\n  origin?: 'top-left' | 'bottom-left';\n\n  /**\n   * Optional: Cell click mode\n   * - 'down': Fire on pointerdown (default, feels responsive)\n   * - 'up': Fire on pointerup (better for drag operations)\n   */\n  clickMode?: 'down' | 'up';\n\n  /**\n   * Optional: Enable debug visualization\n   * Shows grid lines and cell coordinates\n   */\n  debug?: boolean;\n}\n\nexport class GridClickHelper {\n  private config: Required<GridClickConfig>;\n  private scene: Phaser.Scene;\n  private highlights: Phaser.GameObjects.Rectangle[] = [];\n  private debugGraphics?: Phaser.GameObjects.Graphics;\n  private debugTexts: Phaser.GameObjects.Text[] = [];\n\n  constructor(adapter: PhaserAdapter, scene: Phaser.Scene, config: GridClickConfig) {\n    this.scene = scene;\n\n    // Fill in defaults\n    this.config = {\n      ...config,\n      canClick: config.canClick ?? (() => true),\n      canHighlight: config.canHighlight ?? (() => true),\n      highlightColor: config.highlightColor ?? 0xffffff,\n      highlightAlpha: config.highlightAlpha ?? 0.15,\n      useHandCursor: config.useHandCursor ?? true,\n      origin: config.origin ?? 'top-left',\n      clickMode: config.clickMode ?? 'down',\n      debug: config.debug ?? false\n    };\n\n    this.setupHighlights();\n    this.setupInputHandlers();\n\n    if (this.config.debug) {\n      this.setupDebugVisualization();\n    }\n  }\n\n  /**\n   * Create highlight rectangles for visual feedback\n   */\n  private setupHighlights(): void {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, highlightColor, origin } = this.config;\n\n    for (let col = 0; col < columns; col++) {\n      for (let row = 0; row < rows; row++) {\n        const x = offsetX + col * cellWidth + cellWidth / 2;\n\n        // Handle different origin modes\n        const y = origin === 'bottom-left'\n          ? offsetY + (rows - 1 - row) * cellHeight + cellHeight / 2\n          : offsetY + row * cellHeight + cellHeight / 2;\n\n        const highlight = this.scene.add.rectangle(\n          x,\n          y,\n          cellWidth,\n          cellHeight,\n          highlightColor,\n          0 // Start invisible\n        );\n\n        // Store index for easy lookup\n        (highlight as any).gridCol = col;\n        (highlight as any).gridRow = row;\n\n        this.highlights.push(highlight);\n      }\n    }\n  }\n\n  /**\n   * Setup pointer event handlers using worldX/worldY for accurate mapping\n   */\n  private setupInputHandlers(): void {\n    const { useHandCursor, clickMode } = this.config;\n\n    // Handle pointer move for hover highlights\n    this.scene.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {\n      const cell = this.pointerToCell(pointer);\n\n      // Hide all highlights\n      this.highlights.forEach(h => h.setAlpha(0));\n\n      // Show highlight for hovered cell if valid\n      if (cell && this.config.canHighlight(cell.col, cell.row)) {\n        const highlight = this.getHighlight(cell.col, cell.row);\n        if (highlight) {\n          highlight.setAlpha(this.config.highlightAlpha);\n        }\n      }\n\n      // Update cursor\n      if (useHandCursor) {\n        const canClick = cell && this.config.canClick(cell.col, cell.row);\n        this.scene.input.setDefaultCursor(canClick ? 'pointer' : 'default');\n      }\n    });\n\n    // Handle clicks\n    const eventName = clickMode === 'down' ? 'pointerdown' : 'pointerup';\n    this.scene.input.on(eventName, (pointer: Phaser.Input.Pointer) => {\n      const cell = this.pointerToCell(pointer);\n\n      if (cell && this.config.canClick(cell.col, cell.row)) {\n        this.config.onCellClick(cell.col, cell.row);\n\n        // Flash the highlight for feedback\n        const highlight = this.getHighlight(cell.col, cell.row);\n        if (highlight) {\n          this.scene.tweens.add({\n            targets: highlight,\n            alpha: this.config.highlightAlpha * 2,\n            duration: 100,\n            yoyo: true\n          });\n        }\n      }\n    });\n\n    // Reset cursor when pointer leaves\n    this.scene.input.on('pointerout', () => {\n      this.highlights.forEach(h => h.setAlpha(0));\n      if (useHandCursor) {\n        this.scene.input.setDefaultCursor('default');\n      }\n    });\n  }\n\n  /**\n   * Convert pointer coordinates to grid cell\n   * Uses worldX/worldY for accurate mapping in any scale mode\n   */\n  private pointerToCell(pointer: Phaser.Input.Pointer): { col: number; row: number } | null {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, origin } = this.config;\n\n    // Use worldX/worldY to account for camera transforms and scaling\n    const col = Math.floor((pointer.worldX - offsetX) / cellWidth);\n    const rowFromTop = Math.floor((pointer.worldY - offsetY) / cellHeight);\n\n    // Convert to grid coordinates based on origin\n    const row = origin === 'bottom-left' ? rows - 1 - rowFromTop : rowFromTop;\n\n    // Validate bounds\n    if (col < 0 || col >= columns || row < 0 || row >= rows) {\n      return null;\n    }\n\n    return { col, row };\n  }\n\n  /**\n   * Get highlight rectangle for a specific cell\n   */\n  private getHighlight(col: number, row: number): Phaser.GameObjects.Rectangle | undefined {\n    return this.highlights.find(h => (h as any).gridCol === col && (h as any).gridRow === row);\n  }\n\n  /**\n   * Setup debug visualization (grid lines and coordinates)\n   */\n  private setupDebugVisualization(): void {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, origin } = this.config;\n\n    // Draw grid lines\n    this.debugGraphics = this.scene.add.graphics();\n    this.debugGraphics.lineStyle(1, 0xff00ff, 0.5);\n\n    // Vertical lines\n    for (let col = 0; col <= columns; col++) {\n      const x = offsetX + col * cellWidth;\n      this.debugGraphics.lineBetween(x, offsetY, x, offsetY + rows * cellHeight);\n    }\n\n    // Horizontal lines\n    for (let row = 0; row <= rows; row++) {\n      const y = offsetY + row * cellHeight;\n      this.debugGraphics.lineBetween(offsetX, y, offsetX + columns * cellWidth, y);\n    }\n\n    // Draw cell coordinates\n    for (let col = 0; col < columns; col++) {\n      for (let row = 0; row < rows; row++) {\n        const x = offsetX + col * cellWidth + 5;\n\n        // Handle different origin modes\n        const y = origin === 'bottom-left'\n          ? offsetY + (rows - 1 - row) * cellHeight + 5\n          : offsetY + row * cellHeight + 5;\n\n        const text = this.scene.add.text(x, y, `${col},${row}`, {\n          fontSize: '10px',\n          color: '#ff00ff',\n          backgroundColor: '#000000'\n        });\n        this.debugTexts.push(text);\n      }\n    }\n  }\n\n  /**\n   * Manually trigger a highlight (useful for showing valid moves, etc.)\n   */\n  showHighlight(col: number, row: number, alpha?: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setAlpha(alpha ?? this.config.highlightAlpha);\n    }\n  }\n\n  /**\n   * Hide a specific cell's highlight\n   */\n  hideHighlight(col: number, row: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setAlpha(0);\n    }\n  }\n\n  /**\n   * Hide all highlights\n   */\n  hideAllHighlights(): void {\n    this.highlights.forEach(h => h.setAlpha(0));\n  }\n\n  /**\n   * Update highlight color for a specific cell\n   */\n  setHighlightColor(col: number, row: number, color: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setFillStyle(color);\n    }\n  }\n\n  /**\n   * Destroy the helper and clean up resources\n   */\n  destroy(): void {\n    this.highlights.forEach(h => h.destroy());\n    this.debugGraphics?.destroy();\n    this.debugTexts.forEach(t => t.destroy());\n    this.highlights = [];\n    this.debugTexts = [];\n\n    // Remove input listeners\n    this.scene.input.off('pointermove');\n    this.scene.input.off('pointerdown');\n    this.scene.input.off('pointerup');\n    this.scene.input.off('pointerout');\n  }\n}\n\n/**\n * Factory function for creating a GridClickHelper\n * Called from PhaserAdapter.createClickableGrid()\n */\nexport function createClickableGrid(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: GridClickConfig\n): GridClickHelper {\n  return new GridClickHelper(adapter, scene, config);\n}\n", "/**\n * PhaserAdapter - Bridge between Phaser and @martini-kit/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\nimport { PlayerUIManager, type PlayerUIManagerConfig } from './helpers/PlayerUIManager.js';\nimport { CollisionManager, type CollisionManagerConfig } from './helpers/CollisionManager.js';\nimport { PhysicsManager, type PhysicsManagerConfig } from './helpers/PhysicsManager.js';\nimport { StateDrivenSpawner, type StateDrivenSpawnerConfig } from './helpers/StateDrivenSpawner.js';\nimport { HealthBarManager, type HealthBarConfig } from './helpers/HealthBarManager.js';\nimport { GridClickHelper, type GridClickConfig } from './helpers/GridClickHelper.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 50ms / 20 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Interpolate movement on clients for smoothness */\n  interpolate?: boolean;\n\n  /** Namespace to write sprite data to (default: uses adapter's spriteNamespace) */\n  namespace?: string;\n\n  /** Enable adaptive sync rate (default: false) - syncs faster when moving, slower when idle */\n  adaptiveSync?: boolean;\n\n  /** Movement threshold for adaptive sync (default: 1 pixel/frame) */\n  adaptiveSyncThreshold?: number;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Enable automatic interpolation for remote sprites (default: true)\n   * When enabled, remote sprites smoothly lerp to target positions\n   */\n  autoInterpolate?: boolean;\n\n  /**\n   * Interpolation lerp factor (default: 0.3)\n   * Lower = smoother but laggier, Higher = snappier but jerkier\n   * Range: 0.1 (very smooth) to 0.5 (very snappy)\n   */\n  lerpFactor?: number;\n\n  /**\n   * Interpolation mode (default: 'lerp')\n   * - 'lerp': Exponential smoothing (frame-rate dependent, legacy)\n   * - 'time-based': Linear interpolation at constant speed (frame-rate independent)\n   * - 'snapshot-buffer': Render past with buffered snapshots (smoothest, adds 50-100ms latency)\n   */\n  interpolationMode?: 'lerp' | 'time-based' | 'snapshot-buffer';\n\n  /**\n   * Interpolation speed in pixels per second (for 'time-based' mode, default: 400)\n   */\n  interpolationSpeed?: number;\n\n  /**\n   * Snapshot buffer size (for 'snapshot-buffer' mode, default: 3)\n   * Higher = smoother but more latency\n   */\n  snapshotBufferSize?: number;\n\n  /**\n   * Enable dead reckoning/extrapolation (default: true)\n   * Continues movement based on velocity during packet loss\n   */\n  enableDeadReckoning?: boolean;\n\n  /**\n   * Dead reckoning max duration in ms (default: 200)\n   * Maximum time to extrapolate without new data\n   */\n  deadReckoningMaxDuration?: number;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   autoInterpolate: true,           // optional, defaults to true\n *   lerpFactor: 0.3                  // optional, defaults to 0.3\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\n/** Snapshot for buffered interpolation */\ninterface SpriteSnapshot {\n  x: number;\n  y: number;\n  rotation?: number;\n  timestamp: number;\n}\n\n/** Enhanced remote sprite data with interpolation state */\ninterface RemoteSpriteData {\n  sprite: any;\n  namespace: string;\n  // Legacy lerp targets\n  _targetX?: number;\n  _targetY?: number;\n  _targetRotation?: number;\n  // Snapshot buffer for snapshot-buffer mode\n  snapshots?: SpriteSnapshot[];\n  // Dead reckoning state\n  velocityX?: number;\n  velocityY?: number;\n  lastUpdateTime?: number;\n}\n\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<string, { sprite: any; options: SpriteTrackingOptions; lastPosition?: { x: number; y: number } }> = new Map();\n  private remoteSprites: Map<string, RemoteSpriteData> = new Map();\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly autoInterpolate: boolean;\n  private readonly lerpFactor: number;\n  private readonly interpolationMode: 'lerp' | 'time-based' | 'snapshot-buffer';\n  private readonly interpolationSpeed: number;\n  private readonly snapshotBufferSize: number;\n  private readonly enableDeadReckoning: boolean;\n  private readonly deadReckoningMaxDuration: number;\n  private spriteManagers: Set<{ namespace: string }> = new Set(); // Track all registered SpriteManagers\n  private lastUpdateTime: number = Date.now();\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.autoInterpolate = config.autoInterpolate !== false; // default true\n    this.lerpFactor = config.lerpFactor ?? 0.3;\n    this.interpolationMode = config.interpolationMode || 'time-based';\n    this.interpolationSpeed = config.interpolationSpeed ?? 400; // pixels per second\n    this.snapshotBufferSize = config.snapshotBufferSize ?? 3;\n    this.enableDeadReckoning = config.enableDeadReckoning !== false; // default true\n    this.deadReckoningMaxDuration = config.deadReckoningMaxDuration ?? 200; // ms\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Get the local player's ID\n   * More discoverable alias for {@link myId}\n   */\n  getLocalPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Backwards-compatible helper - alias for {@link myId}\n   * @deprecated Use {@link getLocalPlayerId} instead for better discoverability\n   */\n  getMyPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Get the current player's state object from the runtime\n   *\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  getMyPlayer<TPlayer = any>(playersKey: string = 'players'): TPlayer | undefined {\n    const state = this.runtime.getState() as any;\n    const players = state?.[playersKey];\n    if (!players) return undefined;\n    return players[this.getMyPlayerId()];\n  }\n\n  /**\n   * Subscribe to changes in the current player's state\n   *\n   * @param callback Invoked whenever the local player's record changes\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  onMyPlayerChange<TPlayer = any>(\n    callback: (player: TPlayer | undefined) => void,\n    playersKey: string = 'players'\n  ): () => void {\n    let lastValue = this.getMyPlayer<TPlayer>(playersKey);\n    callback(lastValue);\n\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const nextValue = players ? players[this.getMyPlayerId()] : undefined;\n      if (nextValue === lastValue) {\n        return;\n      }\n      lastValue = nextValue;\n      callback(nextValue);\n    });\n  }\n\n  /**\n   * Watch a derived value from the current player's state with automatic change detection\n   *\n   * This is the reactive counterpart to `onMyPlayerChange`. It re-runs a selector function\n   * on every state change and only fires the callback when the selected value changes\n   * (using Object.is equality by default).\n   *\n   * Perfect for reactive UIs that need to respond to property mutations like size, health, score, etc.\n   *\n   * @param selector Function that extracts a value from the player state\n   * @param callback Invoked when the selected value changes\n   * @param options Optional configuration\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Watch player size changes\n   * adapter.watchMyPlayer(\n   *   (player) => player?.size,\n   *   (size) => {\n   *     hudText.setText(`Size: ${size}`);\n   *   }\n   * );\n   *\n   * // Watch multiple properties\n   * adapter.watchMyPlayer(\n   *   (player) => ({ size: player?.size, health: player?.health }),\n   *   (stats) => {\n   *     hudText.setText(`Size: ${stats.size}, HP: ${stats.health}`);\n   *   }\n   * );\n   *\n   * // Custom equality check\n   * adapter.watchMyPlayer(\n   *   (player) => player?.position,\n   *   (pos) => console.log('Position changed:', pos),\n   *   { equals: (a, b) => a?.x === b?.x && a?.y === b?.y }\n   * );\n   * ```\n   */\n  watchMyPlayer<TPlayer = any, TSelected = any>(\n    selector: (player: TPlayer | undefined) => TSelected,\n    callback: (selected: TSelected, prev: TSelected | undefined) => void,\n    options?: {\n      /** Key in state where players are stored (default: 'players') */\n      playersKey?: string;\n      /** Custom equality check (default: Object.is) */\n      equals?: (a: TSelected, b: TSelected) => boolean;\n    }\n  ): () => void {\n    const playersKey = options?.playersKey || 'players';\n    const equals = options?.equals || Object.is;\n\n    // Get initial value and fire callback\n    let lastSelected = selector(this.getMyPlayer<TPlayer>(playersKey));\n    callback(lastSelected, undefined);\n\n    // Subscribe to all state changes\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const player = players ? players[this.getMyPlayerId()] : undefined;\n      const nextSelected = selector(player);\n\n      // Only fire callback if selected value changed\n      if (!equals(nextSelected, lastSelected)) {\n        const prev = lastSelected;\n        lastSelected = nextSelected;\n        callback(nextSelected, prev);\n      }\n    });\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Expose the underlying Phaser scene\n   */\n  getScene(): any {\n    return this.scene;\n  }\n\n  /**\n   * Convert pointer screen coordinates to world coordinates\n   *\n   * IMPORTANT: Always use this helper (or pointer.worldX/worldY directly)\n   * when handling pointer input for game logic. Using pointer.x/y will break\n   * when the camera is scrolled/following a player.\n   *\n   * @param pointer - Phaser pointer object from input events\n   * @returns World coordinates { x: number, y: number }\n   *\n   * @example\n   * ```ts\n   * this.input.on('pointerdown', (pointer) => {\n   *   const worldPos = adapter.pointerToWorld(pointer);\n   *   runtime.submitAction('move', { x: worldPos.x, y: worldPos.y });\n   * });\n   * ```\n   */\n  pointerToWorld(pointer: { worldX: number; worldY: number }): { x: number; y: number } {\n    return {\n      x: pointer.worldX,\n      y: pointer.worldY\n    };\n  }\n\n  /**\n   * FIX #2: Wait for required metadata properties before executing callback\n   *\n   * This is a shared utility that prevents race conditions when creating UI/sprites\n   * that depend on static properties like role, team, side, etc.\n   *\n   * Extracted pattern from PlayerUIManager and HUDHelper for reuse across the SDK.\n   *\n   * @param stateKey - Key in state where the entity data lives (e.g., 'players')\n   * @param entityId - ID of the specific entity (e.g., player ID)\n   * @param requiredProperties - Array of property names that must exist before callback fires\n   * @param callback - Called when all required properties are present\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Wait for player metadata before creating UI\n   * adapter.waitForMetadata('players', playerId, ['role', 'team'], (data) => {\n   *   const color = data.role === 'fire' ? 0xff0000 : 0x0000ff;\n   *   const sprite = this.add.circle(data.x, data.y, 20, color);\n   * });\n   *\n   * // Wait for sprite static properties\n   * adapter.waitForMetadata('__sprites__.players', spriteKey, ['role'], (data) => {\n   *   const label = this.add.text(data.x, data.y, data.role.toUpperCase());\n   * });\n   * ```\n   */\n  waitForMetadata(\n    stateKey: string,\n    entityId: string,\n    requiredProperties: string[],\n    callback: (data: any) => void\n  ): () => void {\n    // Helper to check if all required properties exist\n    const hasAllProperties = (data: any): boolean => {\n      if (!data) return false;\n      return requiredProperties.every(prop => prop in data && data[prop] !== undefined);\n    };\n\n    // Check current state immediately\n    const state = this.runtime.getState() as any;\n    const collection = this.getNestedProperty(state, stateKey);\n    const currentData = collection?.[entityId];\n\n    if (hasAllProperties(currentData)) {\n      // All properties already present - fire immediately\n      callback(currentData);\n      return () => {}; // No-op unsubscribe\n    }\n\n    // Properties not ready yet - subscribe to state changes\n    return this.runtime.onChange((state: any) => {\n      const collection = this.getNestedProperty(state, stateKey);\n      const data = collection?.[entityId];\n\n      if (hasAllProperties(data)) {\n        callback(data);\n      }\n    });\n  }\n\n  /**\n   * Helper to get nested property from state (e.g., '__sprites__.players')\n   * @internal\n   */\n  private getNestedProperty(obj: any, path: string): any {\n    const parts = path.split('.');\n    let current = obj;\n    for (const part of parts) {\n      if (current == null) return undefined;\n      current = current[part];\n    }\n    return current;\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, { sprite, options, lastPosition: { x: sprite.x, y: sprite.y } });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 50;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // FIX #3 & #4: Do immediate first sync to guarantee ordering\n    // Previously, the first sync happened 50ms later via interval, which created\n    // a race condition where static data (from setSpriteStaticData) could arrive\n    // at clients before or after position data.\n    //\n    // Now we sync immediately, which guarantees the order:\n    // 1. setSpriteStaticData() writes static properties (e.g., role: 'fire')\n    // 2. trackSprite() immediately writes position (e.g., x, y)\n    // Both broadcasts happen synchronously in the correct order!\n    if (this.isHost()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Stop tracking a sprite\n   *\n   * @param key - Sprite key\n   * @param namespace - Optional namespace (defaults to spriteNamespace from config)\n   */\n  untrackSprite(key: string, namespace?: string): void {\n    const tracked = this.trackedSprites.get(key);\n    this.trackedSprites.delete(key);\n\n    // Use namespace from tracked options, parameter, or default\n    const ns = namespace || tracked?.options.namespace || this.spriteNamespace;\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[ns];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const { sprite, options, lastPosition } = tracked;\n\n      // Adaptive sync: skip if sprite hasn't moved much\n      if (options.adaptiveSync && lastPosition) {\n        const threshold = options.adaptiveSyncThreshold ?? 1;\n        const dx = Math.abs(sprite.x - lastPosition.x);\n        const dy = Math.abs(sprite.y - lastPosition.y);\n\n        if (dx < threshold && dy < threshold) {\n          continue; // Skip sync for idle sprite\n        }\n      }\n\n      this.syncSpriteToState(key, sprite, options);\n\n      // Update last position for adaptive sync\n      if (options.adaptiveSync) {\n        tracked.lastPosition = { x: sprite.x, y: sprite.y };\n      }\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Use namespace from options or default\n    const namespace = options.namespace || this.spriteNamespace;\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[namespace]) {\n        state[namespace] = {};\n      }\n      const sprites = state[namespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Set static metadata for a tracked sprite (host only)\n   *\n   * @param key - Sprite key\n   * @param data - Static data to set\n   * @param namespace - Optional namespace (defaults to spriteNamespace from config)\n   */\n  setSpriteStaticData(key: string, data: Record<string, any>, namespace?: string): void {\n    if (!this.isHost()) return;\n\n    const ns = namespace || this.spriteNamespace;\n    this.runtime.mutateState((state: any) => {\n      if (!state[ns]) {\n        state[ns] = {};\n      }\n      const sprites = state[ns];\n      sprites[key] = { ...data, ...sprites[key] };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   *\n   * MULTI-NAMESPACE SUPPORT: This method now handles sprites from all registered\n   * namespaces, including both the default namespace and custom namespaces from\n   * createSpriteRegistry(). This fixes the bug where sprites in custom namespaces\n   * (like __sprites__.players) weren't getting interpolation targets on clients.\n   */\n  private updateSpritesFromState(state: any): void {\n    if (this.isHost()) return;\n\n    // Collect all namespaces to check\n    const namespacesToCheck = new Set<string>();\n\n    // Add default namespace\n    namespacesToCheck.add(this.spriteNamespace);\n\n    // Add all registered SpriteManager namespaces\n    for (const manager of this.spriteManagers) {\n      namespacesToCheck.add(manager.namespace);\n    }\n\n    // Update sprites in each namespace\n    for (const namespace of namespacesToCheck) {\n      const sprites = state[namespace];\n      if (!sprites) continue; // Skip if this namespace doesn't exist in state\n\n      // Update tracked sprites (sprites that exist on this client)\n      for (const [key, tracked] of this.trackedSprites.entries()) {\n        const spriteData = sprites[key];\n        if (spriteData) {\n          this.applySpriteData(tracked.sprite, spriteData);\n        }\n      }\n\n      // Update remote sprites (sprites from other players)\n      // Store target positions for interpolation\n      const now = Date.now();\n      for (const [key, spriteData] of Object.entries(sprites)) {\n        // Skip if this is our own sprite\n        if (this.trackedSprites.has(key)) continue;\n\n        // If we have a remote sprite for this key, store target position\n        const remoteSpriteData = this.remoteSprites.get(key);\n        if (remoteSpriteData && remoteSpriteData.namespace === namespace) {\n          const sprite = remoteSpriteData.sprite;\n          const data = spriteData as any;\n\n          // Calculate velocity for dead reckoning\n          if (this.enableDeadReckoning && remoteSpriteData.lastUpdateTime) {\n            const dt = (now - remoteSpriteData.lastUpdateTime) / 1000; // seconds\n            if (dt > 0 && sprite._targetX !== undefined) {\n              remoteSpriteData.velocityX = (data.x - sprite._targetX) / dt;\n              remoteSpriteData.velocityY = (data.y - sprite._targetY) / dt;\n            }\n          }\n\n          // Snapshot buffer mode: Store snapshot instead of direct target\n          if (this.interpolationMode === 'snapshot-buffer') {\n            if (!remoteSpriteData.snapshots) {\n              remoteSpriteData.snapshots = [];\n            }\n\n            // Add new snapshot\n            remoteSpriteData.snapshots.push({\n              x: data.x,\n              y: data.y,\n              rotation: data.rotation,\n              timestamp: now\n            });\n\n            // Keep only last N snapshots\n            if (remoteSpriteData.snapshots.length > this.snapshotBufferSize) {\n              remoteSpriteData.snapshots.shift();\n            }\n\n            // First update - snap to position immediately\n            if (sprite.x === undefined) {\n              sprite.x = data.x;\n              sprite.y = data.y;\n              sprite.rotation = data.rotation || 0;\n            }\n          } else {\n            // Legacy lerp / time-based mode: Store target positions\n            sprite._targetX = data.x;\n            sprite._targetY = data.y;\n            sprite._targetRotation = data.rotation;\n\n            // First update - snap to position immediately\n            if (sprite._targetX !== undefined && sprite.x === undefined) {\n              sprite.x = sprite._targetX;\n              sprite.y = sprite._targetY;\n              sprite.rotation = sprite._targetRotation || 0;\n            }\n          }\n\n          remoteSpriteData.lastUpdateTime = now;\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   * @param namespace - Optional namespace (defaults to spriteNamespace config)\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any, namespace?: string): void {\n    this.remoteSprites.set(key, {\n      sprite,\n      namespace: namespace || this.spriteNamespace\n    });\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Note: If autoInterpolate is enabled in config, you don't need to call this manually.\n   *\n   * Supports three interpolation modes:\n   * - 'lerp': Exponential smoothing (legacy, frame-rate dependent)\n   * - 'time-based': Linear interpolation at constant speed (frame-rate independent)\n   * - 'snapshot-buffer': Buffered interpolation (smoothest, adds latency)\n   */\n  updateInterpolation(delta?: number): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    const now = Date.now();\n    const dt = delta ? delta / 1000 : (now - this.lastUpdateTime) / 1000; // Convert to seconds\n    this.lastUpdateTime = now;\n\n    for (const [key, remoteSpriteData] of this.remoteSprites.entries()) {\n      const sprite = remoteSpriteData.sprite;\n\n      if (this.interpolationMode === 'snapshot-buffer') {\n        // Snapshot buffer mode: Interpolate between buffered snapshots\n        this.updateSnapshotBufferInterpolation(sprite, remoteSpriteData, now);\n      } else if (this.interpolationMode === 'time-based') {\n        // Time-based mode: Linear interpolation at constant speed\n        this.updateTimeBasedInterpolation(sprite, remoteSpriteData, dt, now);\n      } else {\n        // Legacy lerp mode: Exponential smoothing\n        this.updateLerpInterpolation(sprite, remoteSpriteData);\n      }\n    }\n  }\n\n  /**\n   * Legacy exponential lerp interpolation (frame-rate dependent)\n   */\n  private updateLerpInterpolation(sprite: any, remoteSpriteData: RemoteSpriteData): void {\n    if (sprite._targetX !== undefined) {\n      sprite.x += (sprite._targetX - sprite.x) * this.lerpFactor;\n      sprite.y += (sprite._targetY - sprite.y) * this.lerpFactor;\n\n      if (sprite._targetRotation !== undefined) {\n        sprite.rotation += (sprite._targetRotation - sprite.rotation) * this.lerpFactor;\n      }\n    }\n  }\n\n  /**\n   * Time-based linear interpolation (frame-rate independent)\n   */\n  private updateTimeBasedInterpolation(\n    sprite: any,\n    remoteSpriteData: RemoteSpriteData,\n    dt: number,\n    now: number\n  ): void {\n    if (sprite._targetX === undefined) return;\n\n    // Calculate distance to target\n    const dx = sprite._targetX - sprite.x;\n    const dy = sprite._targetY - sprite.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < 0.1) {\n      // Snap to target if very close\n      sprite.x = sprite._targetX;\n      sprite.y = sprite._targetY;\n      if (sprite._targetRotation !== undefined) {\n        sprite.rotation = sprite._targetRotation;\n      }\n      return;\n    }\n\n    // Dead reckoning: Extrapolate if no recent updates\n    const timeSinceUpdate = now - (remoteSpriteData.lastUpdateTime || now);\n    if (\n      this.enableDeadReckoning &&\n      timeSinceUpdate > 0 &&\n      timeSinceUpdate < this.deadReckoningMaxDuration &&\n      remoteSpriteData.velocityX !== undefined\n    ) {\n      // Use velocity to extrapolate position\n      sprite.x += remoteSpriteData.velocityX * dt;\n      sprite.y += remoteSpriteData.velocityY! * dt;\n    } else {\n      // Normal interpolation: Move at constant speed towards target\n      const moveDistance = this.interpolationSpeed * dt;\n      const t = Math.min(moveDistance / distance, 1); // Clamp to 1 to prevent overshoot\n\n      sprite.x += dx * t;\n      sprite.y += dy * t;\n\n      // Rotation interpolation\n      if (sprite._targetRotation !== undefined) {\n        const dr = sprite._targetRotation - sprite.rotation;\n        sprite.rotation += dr * t;\n      }\n    }\n  }\n\n  /**\n   * Snapshot buffer interpolation (smoothest, renders in the past)\n   */\n  private updateSnapshotBufferInterpolation(\n    sprite: any,\n    remoteSpriteData: RemoteSpriteData,\n    now: number\n  ): void {\n    const snapshots = remoteSpriteData.snapshots;\n    if (!snapshots || snapshots.length < 2) return;\n\n    // Render 100ms in the past (or buffer size * sync interval)\n    const renderTime = now - 100;\n\n    // Find two snapshots to interpolate between\n    let snapshot0: SpriteSnapshot | null = null;\n    let snapshot1: SpriteSnapshot | null = null;\n\n    for (let i = 0; i < snapshots.length - 1; i++) {\n      if (snapshots[i].timestamp <= renderTime && snapshots[i + 1].timestamp >= renderTime) {\n        snapshot0 = snapshots[i];\n        snapshot1 = snapshots[i + 1];\n        break;\n      }\n    }\n\n    // Fallback to latest two snapshots\n    if (!snapshot0 || !snapshot1) {\n      snapshot0 = snapshots[snapshots.length - 2];\n      snapshot1 = snapshots[snapshots.length - 1];\n    }\n\n    // Interpolate between snapshots\n    const t0 = snapshot0.timestamp;\n    const t1 = snapshot1.timestamp;\n    const t = (renderTime - t0) / (t1 - t0);\n    const clamped = Math.max(0, Math.min(1, t));\n\n    sprite.x = snapshot0.x + (snapshot1.x - snapshot0.x) * clamped;\n    sprite.y = snapshot0.y + (snapshot1.y - snapshot0.y) * clamped;\n\n    if (snapshot0.rotation !== undefined && snapshot1.rotation !== undefined) {\n      sprite.rotation = snapshot0.rotation + (snapshot1.rotation - snapshot0.rotation) * clamped;\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const remoteSpriteData = this.remoteSprites.get(key);\n    if (remoteSpriteData?.sprite && remoteSpriteData.sprite.destroy) {\n      remoteSpriteData.sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   namespace: 'players',  // optional, defaults to '_sprites'\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    const manager = new SpriteManager(this, config);\n    // Register the namespace for multi-namespace interpolation support\n    this.registerSpriteManager(manager);\n    return manager;\n  }\n\n  /**\n   * Register a SpriteManager with this adapter for multi-namespace support\n   * Internal method - automatically called by createSpriteManager\n   */\n  registerSpriteManager(manager: { namespace: string }): void {\n    this.spriteManagers.add(manager);\n  }\n\n  /**\n   * Create a typed registry of sprite managers\n   *\n   * This provides type-safe collections of sprites with automatic namespacing.\n   * Each sprite type gets its own isolated namespace in the state tree.\n   *\n   * @example\n   * ```ts\n   * const sprites = adapter.createSpriteRegistry({\n   *   players: {\n   *     onCreate: (key, data: { x: number, y: number, role: string }) => {\n   *       const color = data.role === 'fire' ? 0xff3300 : 0x0033ff;\n   *       return this.add.circle(data.x, data.y, 20, color);\n   *     },\n   *     staticProperties: ['role'],\n   *     label: { getText: (d) => d.role.toUpperCase() }\n   *   },\n   *   enemies: {\n   *     onCreate: (key, data: { x: number, y: number, type: string }) => {\n   *       return this.add.sprite(data.x, data.y, data.type);\n   *     }\n   *   }\n   * });\n   *\n   * // Type-safe sprite creation\n   * sprites.players.add('p1', { x: 100, y: 100, role: 'fire' });\n   * sprites.enemies.add('e1', { x: 200, y: 200, type: 'goblin' });\n   *\n   * // Each collection has its own namespace:\n   * // state.__sprites__.players = { p1: { x: 100, y: 100, role: 'fire' } }\n   * // state.__sprites__.enemies = { e1: { x: 200, y: 200, type: 'goblin' } }\n   * ```\n   */\n  createSpriteRegistry<TRegistry extends Record<string, SpriteManagerConfig<any>>>(\n    config: TRegistry\n  ): {\n    [K in keyof TRegistry]: SpriteManager<\n      TRegistry[K] extends SpriteManagerConfig<infer TData> ? TData : never\n    >;\n  } {\n    const registry: any = {};\n\n    for (const [name, managerConfig] of Object.entries(config)) {\n      const manager = new SpriteManager(this, {\n        ...managerConfig,\n        namespace: `__sprites__.${name}`\n      });\n      // Register the namespace for multi-namespace interpolation support\n      this.registerSpriteManager(manager);\n      registry[name] = manager;\n    }\n\n    return registry;\n  }\n\n  /**\n   * Create a PlayerUIManager for automatically managed player HUD elements\n   */\n  createPlayerUIManager(config: PlayerUIManagerConfig): PlayerUIManager {\n    return new PlayerUIManager(this, this.scene, config);\n  }\n\n  /**\n   * Create a CollisionManager for declarative collision rules\n   */\n  createCollisionManager(config?: CollisionManagerConfig): CollisionManager {\n    return new CollisionManager(this, this.scene, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n\n  /**\n   * Create a PhysicsManager for automatic physics behaviors\n   */\n  createPhysicsManager(config: PhysicsManagerConfig): PhysicsManager {\n    return new PhysicsManager(this.runtime, config);\n  }\n\n  /**\n   * Create a StateDrivenSpawner for automatic sprite spawning from state collections\n   *\n   * Eliminates the manual \"check for new players/bullets\" loop.\n   * Watches a state collection and automatically creates/removes sprites.\n   *\n   * @example\n   * ```ts\n   * // Players (uses object keys)\n   * const playerSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'players',\n   *   spriteManager: this.spriteManager,\n   *   keyPrefix: 'player-'\n   * });\n   *\n   * // Bullets (uses array with id field)\n   * const bulletSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'bullets',\n   *   spriteManager: this.bulletManager,\n   *   keyPrefix: 'bullet-',\n   *   keyField: 'id'\n   * });\n   *\n   * // In update():\n   * playerSpawner.update(); // HOST only\n   * ```\n   */\n  createStateDrivenSpawner(config: StateDrivenSpawnerConfig): StateDrivenSpawner {\n    return new StateDrivenSpawner(this, config);\n  }\n\n  /**\n   * Create a GridClickHelper for robust grid/board click handling\n   *\n   * Solves the common problem where interactive rectangles don't scale properly\n   * with the canvas. Uses pointer.worldX/worldY for accurate coordinate mapping\n   * that works in any scale mode (FIT, RESIZE, etc).\n   *\n   * Perfect for: Connect Four, Chess, Tic-Tac-Toe, Minesweeper, Battleship, etc.\n   *\n   * @example\n   * ```ts\n   * const gridHelper = adapter.createClickableGrid({\n   *   columns: 7,\n   *   rows: 6,\n   *   cellWidth: 80,\n   *   cellHeight: 80,\n   *   offsetX: 100,\n   *   offsetY: 100,\n   *   onCellClick: (col, row) => {\n   *     runtime.submitAction('dropToken', { col });\n   *   },\n   *   highlightColor: 0xffffff,\n   *   highlightAlpha: 0.15,\n   *   origin: 'bottom-left' // For Connect Four\n   * });\n   * ```\n   */\n  createClickableGrid(config: GridClickConfig): GridClickHelper {\n    return new GridClickHelper(this, this.scene, config);\n  }\n\n  /**\n   * Create a HealthBarManager for automatic health bar management\n   *\n   * Auto-creates, positions, scales, and colors health bars for all sprites.\n   *\n   * @example\n   * ```ts\n   * const healthBars = adapter.createHealthBarManager({\n   *   spriteManager: this.spriteManager,\n   *   healthKey: 'health',\n   *   maxHealth: 100,\n   *   offset: { x: 0, y: -30 },\n   *   width: 50,\n   *   height: 5\n   * });\n   *\n   * // In update():\n   * healthBars.update();\n   * ```\n   */\n  createHealthBarManager(config: HealthBarConfig): HealthBarManager {\n    return new HealthBarManager(this, config);\n  }\n\n  /**\n   * Create a CameraFollower for automatic camera tracking\n   *\n   * Eliminates manual camera positioning and fixes initialization timing bugs.\n   * Automatically waits for player state, then follows smoothly.\n   *\n   * @example\n   * ```ts\n   * // Simplest usage - auto-follows local player\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer'\n   * });\n   *\n   * // With smooth lerp following\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer',\n   *   mode: 'lerp',\n   *   lerpFactor: 0.1\n   * });\n   *\n   * // With world bounds\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer',\n   *   bounds: { width: 1600, height: 1200 }\n   * });\n   *\n   * // No manual camera code needed in update()!\n   * // Camera automatically follows and handles all edge cases.\n   * ```\n   */\n  createCameraFollower(config: import('./helpers/CameraFollower.js').CameraFollowerConfig = {}): import('./helpers/CameraFollower.js').CameraFollower {\n    const { createCameraFollower } = require('./helpers/CameraFollower.js');\n    return createCameraFollower(this, this.scene, config);\n  }\n\n  /**\n   * Submit action ONLY when input changes (10x devtools improvement!)\n   *\n   * Automatically tracks previous input and only submits when changed.\n   * Prevents flooding devtools with 60 identical actions per second.\n   *\n   * @param actionName - Name of the action to submit\n   * @param input - Current input state\n   * @param targetId - Optional target player ID\n   *\n   * @example\n   * ```ts\n   * // In scene.update()\n   * const input = {\n   *   left: keys.left.isDown,\n   *   right: keys.right.isDown,\n   *   up: keys.up.isDown\n   * };\n   * adapter.submitActionOnChange('move', input); // Only sends when input changes!\n   * ```\n   */\n  submitActionOnChange(actionName: string, input: any, targetId?: string): void {\n    // Use a private map to track previous inputs per action\n    if (!(this as any)._previousInputs) {\n      (this as any)._previousInputs = new Map<string, string>();\n    }\n\n    const key = targetId ? `${actionName}:${targetId}` : actionName;\n    const inputJson = JSON.stringify(input);\n    const previousJson = (this as any)._previousInputs.get(key);\n\n    // Only submit if input changed\n    if (inputJson !== previousJson) {\n      (this as any)._previousInputs.set(key, inputJson);\n      this.runtime.submitAction(actionName, input, targetId);\n    }\n  }\n}\n", "/**\n * HUD Helper - Unified player HUD/UI for multiplayer games\n *\n * Eliminates the manual HUD boilerplate by automatically creating and managing\n * title, role, and control hint text based on the current player state.\n *\n * @example\n * ```ts\n * import { createPlayerHUD } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.hud = createPlayerHUD(this.adapter, this, {\n *   title: 'Fire & Ice - Cooperative Platformer',\n *\n *   roleText: (myPlayer) => {\n *     if (!myPlayer) return 'Spectator';\n *     return myPlayer.role === 'fire' ? 'Fire Player' : 'Ice Player';\n *   },\n *\n *   controlHints: (myPlayer) => {\n *     if (!myPlayer) return '';\n *     return 'Arrow Keys + SPACE to Jump';\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface HUDLayout {\n\t/** Position for title text */\n\ttitle?: { x: number; y: number };\n\t/** Position for role text */\n\trole?: { x: number; y: number };\n\t/** Position for controls text */\n\tcontrols?: { x: number; y: number };\n}\n\nexport interface HUDTextStyle {\n\tfontSize?: string;\n\tcolor?: string;\n\tfontStyle?: string;\n\tbackgroundColor?: string;\n\tpadding?: { x: number; y: number };\n}\n\nexport interface PlayerHUDConfig<TPlayer = any, TState = any> {\n\t/** Title text (static) */\n\ttitle?: string;\n\t/** Title text style */\n\ttitleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate role text from player data and optionally game state\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @param state - Full game state (optional, for turn-based games)\n\t * @returns Text to display\n\t *\n\t * @example\n\t * // Simple usage (action games)\n\t * roleText: (myPlayer) => {\n\t *   if (!myPlayer) return 'Spectator';\n\t *   return `Player ${myPlayer.id}`;\n\t * }\n\t *\n\t * @example\n\t * // With state (turn-based games)\n\t * roleText: (myPlayer, state) => {\n\t *   if (!myPlayer) return 'Spectator';\n\t *   if (state?.gameOver) return 'Game Over!';\n\t *   return state?.currentTurn === myPlayer.id ? 'Your Turn' : 'Waiting...';\n\t * }\n\t */\n\troleText?: (myPlayer: TPlayer | undefined, state?: TState) => string;\n\t/** Role text style */\n\troleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate control hints from player data and optionally game state\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @param state - Full game state (optional)\n\t * @returns Text to display\n\t */\n\tcontrolHints?: (myPlayer: TPlayer | undefined, state?: TState) => string;\n\t/** Control hints text style */\n\tcontrolsStyle?: HUDTextStyle;\n\n\t/** Custom layout positions */\n\tlayout?: HUDLayout;\n\n\t/** Key in state where players are stored (default: 'players') */\n\tplayersKey?: string;\n}\n\nexport interface PlayerHUD {\n\t/** Update HUD (automatically called when player changes) */\n\tupdate: () => void;\n\t/** Destroy HUD elements */\n\tdestroy: () => void;\n\t/** Get title text object */\n\tgetTitleText: () => Phaser.GameObjects.Text | null;\n\t/** Get role text object */\n\tgetRoleText: () => Phaser.GameObjects.Text | null;\n\t/** Get controls text object */\n\tgetControlsText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a player HUD with automatic role/control updates\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - HUD configuration\n * @returns PlayerHUD instance\n */\nexport function createPlayerHUD<TPlayer = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: PlayerHUDConfig<TPlayer>\n): PlayerHUD {\n\tconst playersKey = config.playersKey || 'players';\n\n\t// Default layout\n\tconst layout = {\n\t\ttitle: config.layout?.title || { x: 400, y: 20 },\n\t\trole: config.layout?.role || { x: 400, y: 50 },\n\t\tcontrols: config.layout?.controls || { x: 400, y: 75 }\n\t};\n\n\t// Default styles\n\tconst titleStyle = {\n\t\tfontSize: config.titleStyle?.fontSize || '24px',\n\t\tcolor: config.titleStyle?.color || '#000',\n\t\tfontStyle: config.titleStyle?.fontStyle || 'bold',\n\t\tbackgroundColor: config.titleStyle?.backgroundColor,\n\t\tpadding: config.titleStyle?.padding\n\t};\n\n\tconst roleStyle = {\n\t\tfontSize: config.roleStyle?.fontSize || '16px',\n\t\tcolor: config.roleStyle?.color || '#000',\n\t\tfontStyle: config.roleStyle?.fontStyle,\n\t\tbackgroundColor: config.roleStyle?.backgroundColor,\n\t\tpadding: config.roleStyle?.padding\n\t};\n\n\tconst controlsStyle = {\n\t\tfontSize: config.controlsStyle?.fontSize || '14px',\n\t\tcolor: config.controlsStyle?.color || '#333',\n\t\tfontStyle: config.controlsStyle?.fontStyle,\n\t\tbackgroundColor: config.controlsStyle?.backgroundColor,\n\t\tpadding: config.controlsStyle?.padding\n\t};\n\n\t// Create text objects\n\tlet titleText: Phaser.GameObjects.Text | null = null;\n\tlet roleText: Phaser.GameObjects.Text | null = null;\n\tlet controlsText: Phaser.GameObjects.Text | null = null;\n\n\t// Create title (static)\n\tif (config.title) {\n\t\ttitleText = scene.add.text(layout.title.x, layout.title.y, config.title, titleStyle);\n\t\ttitleText.setOrigin(0.5);\n\t}\n\n\t// Create role text (dynamic)\n\tif (config.roleText) {\n\t\troleText = scene.add.text(layout.role.x, layout.role.y, 'Loading...', roleStyle);\n\t\troleText.setOrigin(0.5);\n\t}\n\n\t// Create controls text (dynamic)\n\tif (config.controlHints) {\n\t\tcontrolsText = scene.add.text(layout.controls.x, layout.controls.y, '', controlsStyle);\n\t\tcontrolsText.setOrigin(0.5);\n\t}\n\n\t// Update function\n\tconst update = () => {\n\t\tconst state = adapter.getState();\n\t\tconst myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n\t\tif (roleText && config.roleText) {\n\t\t\troleText.setText(config.roleText(myPlayer, state));\n\t\t}\n\n\t\tif (controlsText && config.controlHints) {\n\t\t\tcontrolsText.setText(config.controlHints(myPlayer, state));\n\t\t}\n\t};\n\n\t// Subscribe to state changes to reactively update HUD\n\t// Uses onChange instead of watchMyPlayer to get full state access\n\tconst unsubscribers: Array<() => void> = [];\n\n\t// Track last values to avoid unnecessary updates\n\tlet lastRoleText: string | undefined;\n\tlet lastControlsText: string | undefined;\n\n\t// Watch roleText changes (reactive to both player and state changes)\n\tif (roleText && config.roleText) {\n\t\tconst unsubscribe = adapter.onChange((state: any) => {\n\t\t\tconst players = state?.[playersKey];\n\t\t\tconst myPlayer = players ? players[adapter.getMyPlayerId()] : undefined;\n\t\t\tconst text = config.roleText!(myPlayer, state);\n\n\t\t\t// Only update if text changed\n\t\t\tif (text !== lastRoleText) {\n\t\t\t\tlastRoleText = text;\n\t\t\t\troleText.setText(text);\n\t\t\t}\n\t\t});\n\t\tunsubscribers.push(unsubscribe);\n\n\t\t// Initial update\n\t\tconst initialState = adapter.getState();\n\t\tconst initialPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\t\tlastRoleText = config.roleText(initialPlayer, initialState);\n\t\troleText.setText(lastRoleText);\n\t}\n\n\t// Watch controlHints changes (reactive to both player and state changes)\n\tif (controlsText && config.controlHints) {\n\t\tconst unsubscribe = adapter.onChange((state: any) => {\n\t\t\tconst players = state?.[playersKey];\n\t\t\tconst myPlayer = players ? players[adapter.getMyPlayerId()] : undefined;\n\t\t\tconst text = config.controlHints!(myPlayer, state);\n\n\t\t\t// Only update if text changed\n\t\t\tif (text !== lastControlsText) {\n\t\t\t\tlastControlsText = text;\n\t\t\t\tcontrolsText.setText(text);\n\t\t\t}\n\t\t});\n\t\tunsubscribers.push(unsubscribe);\n\n\t\t// Initial update\n\t\tconst initialState = adapter.getState();\n\t\tconst initialPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\t\tlastControlsText = config.controlHints(initialPlayer, initialState);\n\t\tcontrolsText.setText(lastControlsText);\n\t}\n\n\t// Return HUD interface\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\t// Unsubscribe from all watchers\n\t\t\tunsubscribers.forEach((unsub) => unsub());\n\t\t\ttitleText?.destroy();\n\t\t\troleText?.destroy();\n\t\t\tcontrolsText?.destroy();\n\t\t},\n\t\tgetTitleText: () => titleText,\n\t\tgetRoleText: () => roleText,\n\t\tgetControlsText: () => controlsText\n\t};\n}\n", "/**\n * SpeedDisplay - Reactive speed/velocity display helper\n *\n * Automatically updates when PhysicsManager velocity changes.\n * Separates physics logic from presentation concerns.\n *\n * ## How it works:\n *\n * - **Host:** Subscribes to `onVelocityChange` events for instant updates (no network delay)\n * - **Clients:** Subscribes to state changes, reads `state.players[id].velocity` synced from host\n *\n * This hybrid approach ensures:\n * - Host gets instant feedback (local events, no network overhead)\n * - Clients get accurate sync (velocity automatically synced via state)\n * - No manual update() calls needed - fully reactive!\n *\n * @example\n * ```ts\n * import { createSpeedDisplay } from '@martini-kit/phaser';\n *\n * // In scene.create() - after creating PhysicsManager\n * this.speedDisplay = createSpeedDisplay(\n *   this.physicsManager,\n *   this.adapter,\n *   this,\n *   {\n *     position: { x: 400, y: 50 },\n *     format: (velocity) => `${Math.round(velocity)} mph`,\n *     style: { fontSize: '20px', color: '#4a9eff' }\n *   }\n * );\n *\n * // No update() needed - automatically reacts to velocity changes!\n *\n * // In scene shutdown/destroy:\n * this.speedDisplay.destroy();\n * ```\n */\n\nimport type { PhysicsManager } from './PhysicsManager.js';\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpeedDisplayConfig {\n  /**\n   * Position of the speed display text\n   * Default: { x: 400, y: 50 }\n   */\n  position?: { x: number; y: number };\n\n  /**\n   * Format function to convert velocity to display string\n   * Default: (velocity) => `Speed: ${Math.round(velocity)}`\n   */\n  format?: (velocity: number) => string;\n\n  /**\n   * Phaser text style\n   * Default: { fontSize: '20px', color: '#fff' }\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n}\n\nexport interface SpeedDisplay {\n  /**\n   * Manually update the display (rarely needed - auto-updates via events)\n   */\n  update: () => void;\n\n  /**\n   * Destroy the display and cleanup listeners\n   */\n  destroy: () => void;\n\n  /**\n   * Get the underlying Phaser text object\n   */\n  getText: () => Phaser.GameObjects.Text;\n}\n\n/**\n * Create a speed display that reacts to PhysicsManager velocity changes\n *\n * @param physicsManager - PhysicsManager instance to subscribe to\n * @param adapter - PhaserAdapter instance (for getting local player ID)\n * @param scene - Phaser scene to create text in\n * @param config - Display configuration\n * @returns SpeedDisplay instance with update/destroy methods\n */\nexport function createSpeedDisplay(\n  physicsManager: PhysicsManager,\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: SpeedDisplayConfig = {}\n): SpeedDisplay {\n  // Default config\n  const position = config.position ?? { x: 400, y: 50 };\n  const format = config.format ?? ((v: number) => `Speed: ${Math.round(v)}`);\n  const style = config.style ?? { fontSize: '20px', color: '#fff' };\n\n  // Create text object\n  const text = scene.add.text(position.x, position.y, format(0), style);\n\n  // Set origin\n  if (config.origin !== undefined) {\n    if (typeof config.origin === 'number') {\n      text.setOrigin(config.origin);\n    } else {\n      text.setOrigin(config.origin.x, config.origin.y);\n    }\n  } else {\n    text.setOrigin(0.5); // default: centered\n  }\n\n  // Set depth\n  if (config.depth !== undefined) {\n    text.setDepth(config.depth);\n  }\n\n  // Subscribe to velocity changes (host only - events don't cross network)\n  const unsubscribeVelocity = physicsManager.onVelocityChange((playerId, velocity) => {\n    if (playerId === adapter.getLocalPlayerId()) {\n      text.setText(format(velocity));\n    }\n  });\n\n  // Subscribe to state changes (clients get velocity from state)\n  const unsubscribeState = adapter.onChange((state: any) => {\n    const localPlayerId = adapter.getLocalPlayerId();\n    const player = state.players?.[localPlayerId];\n    if (player && player.velocity !== undefined) {\n      text.setText(format(player.velocity));\n    }\n  });\n\n  // Manual update function\n  const update = () => {\n    const velocity = physicsManager.getVelocity(adapter.getLocalPlayerId());\n    text.setText(format(velocity));\n  };\n\n  // Initial update\n  update();\n\n  return {\n    update,\n    destroy: () => {\n      unsubscribeVelocity();\n      unsubscribeState();\n      text.destroy();\n    },\n    getText: () => text\n  };\n}\n", "/**\n * SpriteAttachment - Generic system for attaching auto-updating components to sprites\n *\n * This is the foundation for all sprite attachments (arrows, health bars, name tags, etc.)\n * It provides a unified \"pit of success\" pattern with automatic updates and cleanup.\n *\n * ## Why Use SpriteAttachment?\n *\n * - **Auto-update by default** - No manual update() calls needed\n * - **Auto-cleanup** - Destroys when sprite/scene is destroyed\n * - **Type-safe** - Full TypeScript support\n * - **Reusable** - One pattern for all attachment types\n * - **Efficient** - Uses Phaser's event system\n *\n * ## Creating Custom Attachments\n *\n * @example Basic attachment\n * ```ts\n * import { createSpriteAttachment, SpriteAttachment } from '@martini-kit/phaser';\n *\n * function createCustomIndicator(\n *   scene: Phaser.Scene,\n *   sprite: any\n * ): SpriteAttachment {\n *   const circle = scene.add.circle(sprite.x, sprite.y, 10, 0xff0000);\n *\n *   return createSpriteAttachment(scene, sprite, {\n *     update: () => {\n *       // Follow the sprite\n *       circle.setPosition(sprite.x, sprite.y + 30);\n *     },\n *     destroy: () => {\n *       circle.destroy();\n *     }\n *   });\n * }\n * ```\n *\n * @example With manual update mode\n * ```ts\n * const attachment = createSpriteAttachment(scene, sprite, {\n *   update: () => { ... },\n *   destroy: () => { ... },\n *   autoUpdate: false  // Disable auto-update\n * });\n *\n * // Then in your scene's update loop:\n * attachment.update();\n * ```\n */\n\nimport type Phaser from 'phaser';\n\n/**\n * Core interface for sprite attachments\n *\n * Any component that follows the sprite (arrows, health bars, name tags, etc.)\n * should implement this interface.\n */\nexport interface SpriteAttachment {\n  /**\n   * Update the attachment's position, rotation, or other properties\n   * based on the parent sprite's current state.\n   *\n   * Called automatically every frame if autoUpdate is enabled.\n   */\n  update: () => void;\n\n  /**\n   * Clean up resources and destroy the attachment.\n   *\n   * Called automatically when sprite/scene is destroyed if autoUpdate is enabled.\n   */\n  destroy: () => void;\n\n  /**\n   * Get the underlying Phaser game object (if any)\n   *\n   * Optional - only needed if the attachment has a visual representation\n   */\n  getGameObject?: () => Phaser.GameObjects.GameObject | null;\n}\n\n/**\n * Configuration for sprite attachment auto-update behavior\n */\nexport interface SpriteAttachmentConfig {\n  /**\n   * Automatically update the attachment every frame\n   *\n   * When true (default), the attachment subscribes to the scene's update event\n   * and automatically calls update() each frame.\n   *\n   * When false, you must manually call attachment.update() in your scene loop.\n   *\n   * @default true\n   */\n  autoUpdate?: boolean;\n}\n\n/**\n * Create a sprite attachment with automatic updates and cleanup\n *\n * This is the foundation function used by all attachment helpers\n * (attachDirectionalIndicator, createHealthBar, createNameTag, etc.)\n *\n * **Automatic Lifecycle Management:**\n * - Calls `update()` every frame via scene events (if autoUpdate: true)\n * - Calls `destroy()` when sprite is destroyed\n * - Calls `destroy()` when scene shuts down\n * - Prevents double-destroy and memory leaks\n *\n * @param scene - Phaser scene\n * @param sprite - Sprite to attach to\n * @param attachment - Attachment implementation (update + destroy)\n * @param config - Auto-update configuration\n * @returns Enhanced attachment with lifecycle management\n *\n * @example Creating a simple follower circle\n * ```ts\n * const circle = scene.add.circle(sprite.x, sprite.y, 10, 0xff0000);\n *\n * const attachment = createSpriteAttachment(scene, sprite, {\n *   update: () => {\n *     circle.setPosition(sprite.x + 20, sprite.y);\n *   },\n *   destroy: () => {\n *     circle.destroy();\n *   }\n * });\n * // That's it! Circle auto-follows sprite and auto-cleans up\n * ```\n */\nexport function createSpriteAttachment(\n  scene: Phaser.Scene,\n  sprite: any,\n  attachment: SpriteAttachment,\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment {\n  const autoUpdate = config.autoUpdate ?? true;\n\n  // Track destruction state to prevent double-destroy\n  let isDestroyed = false;\n\n  // Wrap the original destroy to track state\n  const originalDestroy = attachment.destroy;\n  const wrappedDestroy = () => {\n    if (isDestroyed) return;\n    isDestroyed = true;\n\n    // Remove event listener if auto-update is enabled\n    if (updateHandler) {\n      scene.events.off('update', updateHandler);\n      updateHandler = null;\n    }\n\n    // Call original destroy\n    originalDestroy();\n  };\n\n  // Auto-update setup\n  let updateHandler: (() => void) | null = null;\n\n  if (autoUpdate) {\n    // Initial update\n    attachment.update();\n\n    // Create update handler\n    updateHandler = () => {\n      if (!isDestroyed) {\n        attachment.update();\n      }\n    };\n\n    // Subscribe to scene update event\n    scene.events.on('update', updateHandler);\n\n    // Cleanup when sprite is destroyed\n    if (sprite.once) {\n      sprite.once('destroy', () => {\n        wrappedDestroy();\n      });\n    }\n\n    // Cleanup when scene shuts down\n    scene.events.once('shutdown', () => {\n      if (updateHandler) {\n        scene.events.off('update', updateHandler);\n        updateHandler = null;\n      }\n    });\n  } else {\n    // Manual mode - just do initial update\n    attachment.update();\n  }\n\n  // Return wrapped attachment\n  return {\n    update: attachment.update,\n    destroy: wrappedDestroy,\n    getGameObject: attachment.getGameObject\n  };\n}\n\n/**\n * Helper to create multiple attachments at once\n *\n * Useful when you want to attach several components to the same sprite\n * (e.g., arrow + health bar + name tag).\n *\n * @example\n * ```ts\n * createSpriteAttachments(scene, sprite, [\n *   createDirectionalArrow(scene, sprite),\n *   createHealthBar(scene, sprite, { maxHealth: 100 }),\n *   createNameTag(scene, sprite, { text: 'Player 1' })\n * ]);\n * ```\n */\nexport function createSpriteAttachments(\n  scene: Phaser.Scene,\n  sprite: any,\n  attachments: SpriteAttachment[],\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment[] {\n  return attachments.map((attachment) =>\n    createSpriteAttachment(scene, sprite, attachment, config)\n  );\n}\n\n/**\n * Composite attachment that manages multiple child attachments\n *\n * Useful for complex attachments that have multiple visual components.\n *\n * @example\n * ```ts\n * const composite = createCompositeAttachment(scene, sprite, [\n *   { update: () => updateArrow(), destroy: () => arrow.destroy() },\n *   { update: () => updateGlow(), destroy: () => glow.destroy() }\n * ]);\n * // All children auto-update and auto-destroy together\n * ```\n */\nexport function createCompositeAttachment(\n  scene: Phaser.Scene,\n  sprite: any,\n  children: SpriteAttachment[],\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment {\n  // Create wrapped versions of all children with autoUpdate disabled\n  // (the composite will handle updates)\n  const wrappedChildren = children.map((child) =>\n    createSpriteAttachment(scene, sprite, child, { autoUpdate: false })\n  );\n\n  // Create composite that updates/destroys all children\n  return createSpriteAttachment(\n    scene,\n    sprite,\n    {\n      update: () => {\n        for (const child of wrappedChildren) {\n          child.update();\n        }\n      },\n      destroy: () => {\n        for (const child of wrappedChildren) {\n          child.destroy();\n        }\n      },\n      getGameObject: () => {\n        // Return first child's game object (if any)\n        return wrappedChildren[0]?.getGameObject?.() ?? null;\n      }\n    },\n    config\n  );\n}\n", "/**\n * DirectionalIndicator - Arrow/indicator that shows sprite direction\n *\n * Automatically handles Phaser's rotation convention (0 = right/+X axis)\n * so you don't have to think about rotation offsets.\n *\n * ## Phaser Rotation Convention\n *\n * Phaser uses a coordinate system where:\n * - 0 radians = pointing RIGHT (positive X axis)\n * - \u03C0/2 radians = pointing DOWN (positive Y axis)\n * - \u03C0 radians = pointing LEFT (negative X axis)\n * - -\u03C0/2 radians = pointing UP (negative Y axis)\n *\n * This helper automatically adds a +\u03C0/2 offset to triangle/arrow shapes\n * (which naturally point UP) so they align with the sprite's rotation.\n *\n * ## Auto-Update (Pit of Success!)\n *\n * By default, indicators automatically update every frame via scene events.\n * **No manual update() calls needed!** Just attach and forget.\n *\n * @example Automatic updates (recommended - default behavior)\n * ```ts\n * import { attachDirectionalIndicator } from '@martini-kit/phaser';\n *\n * // In SpriteManager onCreate or onAdd:\n * onCreate: (key, data) => {\n *   const car = this.add.rectangle(data.x, data.y, 30, 20, data.color);\n *\n *   // That's it! Arrow auto-updates every frame\n *   attachDirectionalIndicator(this, car, {\n *     shape: 'triangle',\n *     offset: 20,\n *     color: 0xffffff\n *     // autoUpdate: true is the default\n *   });\n *\n *   return car;\n * }\n * ```\n *\n * @example Manual updates (if you need fine control)\n * ```ts\n * onCreate: (key, data) => {\n *   const car = this.add.rectangle(data.x, data.y, 30, 20, data.color);\n *\n *   car.directionArrow = attachDirectionalIndicator(this, car, {\n *     shape: 'triangle',\n *     offset: 20,\n *     color: 0xffffff,\n *     autoUpdate: false  // Disable auto-update\n *   });\n *\n *   return car;\n * },\n *\n * // Then in your scene's update loop:\n * update() {\n *   for (const [, sprite] of this.spriteManager.getAll()) {\n *     sprite.directionArrow?.update();\n *   }\n * }\n * ```\n */\n\nimport type Phaser from 'phaser';\nimport { createSpriteAttachment, type SpriteAttachment } from './SpriteAttachment';\n\nexport interface DirectionalIndicatorConfig {\n  /**\n   * Shape of the indicator\n   * - 'triangle': Classic arrow shape (default)\n   * - 'arrow': Longer arrow with tail\n   * - 'chevron': V-shaped chevron\n   */\n  shape?: 'triangle' | 'arrow' | 'chevron';\n\n  /**\n   * Distance from sprite center\n   * Default: 20\n   */\n  offset?: number;\n\n  /**\n   * Indicator color\n   * Default: 0xffffff (white)\n   */\n  color?: number;\n\n  /**\n   * Indicator size/scale\n   * Default: 1.0\n   */\n  size?: number;\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Automatically update the indicator every frame\n   *\n   * When true (default), the indicator subscribes to the scene's update event\n   * and automatically follows the sprite's position/rotation each frame.\n   * No manual update() calls needed!\n   *\n   * When false, you must manually call indicator.update() in your scene loop.\n   *\n   * @default true\n   */\n  autoUpdate?: boolean;\n}\n\nexport interface DirectionalIndicator extends SpriteAttachment {\n  /**\n   * Get the underlying Phaser game object\n   *\n   * @override Always defined for DirectionalIndicator (not optional)\n   */\n  getGameObject: () => Phaser.GameObjects.GameObject;\n}\n\n/**\n * Attach a directional indicator to a sprite\n *\n * Automatically handles Phaser's rotation convention where:\n * - 0 radians = pointing right (+X axis)\n * - Math.PI/2 = pointing down (+Y axis)\n * - Math.PI = pointing left (-X axis)\n * - -Math.PI/2 = pointing up (-Y axis)\n *\n * By default (autoUpdate: true), the indicator automatically updates every frame.\n * No manual update() calls needed - it \"just works\"!\n *\n * @param scene - Phaser scene\n * @param sprite - Sprite to attach indicator to\n * @param config - Indicator configuration\n * @returns DirectionalIndicator instance\n */\nexport function attachDirectionalIndicator(\n  scene: Phaser.Scene,\n  sprite: any,\n  config: DirectionalIndicatorConfig = {}\n): DirectionalIndicator {\n  const shape = config.shape ?? 'triangle';\n  const offset = config.offset ?? 20;\n  const color = config.color ?? 0xffffff;\n  const size = config.size ?? 1.0;\n  const autoUpdate = config.autoUpdate ?? true;\n\n  let indicator: Phaser.GameObjects.GameObject & {\n    setPosition?: (x: number, y: number) => any;\n    setRotation?: (rotation: number) => any;\n  };\n\n  // Create the appropriate shape\n  switch (shape) {\n    case 'triangle': {\n      // Triangle pointing UP (negative Y) in default orientation\n      // We'll add \u03C0/2 rotation offset in update() to match Phaser's convention\n      const triangle = scene.add.triangle(\n        sprite.x,\n        sprite.y,\n        0, -5,        // Top point (tip)\n        -4, 5,        // Bottom left\n        4, 5,         // Bottom right\n        color\n      );\n      triangle.setOrigin(0.5);\n      if (config.depth !== undefined) {\n        triangle.setDepth(config.depth);\n      }\n      indicator = triangle;\n      break;\n    }\n\n    case 'arrow': {\n      // Longer arrow with distinct head and tail\n      const container = scene.add.container(sprite.x, sprite.y);\n\n      // Arrow shaft (horizontal line)\n      const shaft = scene.add.rectangle(-3 * size, 0, 10 * size, 2 * size, color);\n      shaft.setOrigin(0.5);\n\n      // Arrow head (triangle)\n      const head = scene.add.triangle(\n        5 * size, 0,\n        0, 0,              // Point\n        -3 * size, -3 * size, // Top\n        -3 * size, 3 * size,  // Bottom\n        color\n      );\n      head.setOrigin(0.5);\n\n      container.add([shaft, head]);\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n      indicator = container;\n      break;\n    }\n\n    case 'chevron': {\n      // V-shaped chevron\n      const graphics = scene.add.graphics();\n      graphics.lineStyle(2 * size, color);\n      // Draw > shape (pointing right)\n      graphics.beginPath();\n      graphics.moveTo(-4 * size, -4 * size);\n      graphics.lineTo(4 * size, 0);\n      graphics.lineTo(-4 * size, 4 * size);\n      graphics.strokePath();\n      graphics.setPosition(sprite.x, sprite.y);\n      if (config.depth !== undefined) {\n        graphics.setDepth(config.depth);\n      }\n      indicator = graphics;\n      break;\n    }\n  }\n\n  // Update function - positions indicator in front of sprite\n  const update = () => {\n    // Calculate position in front of sprite (in the direction it's facing)\n    const indicatorX = sprite.x + Math.cos(sprite.rotation) * offset;\n    const indicatorY = sprite.y + Math.sin(sprite.rotation) * offset;\n\n    indicator.setPosition?.(indicatorX, indicatorY);\n\n    // Add \u03C0/2 rotation offset because:\n    // - Triangle points UP (negative Y) at rotation 0\n    // - Phaser's 0 rotation points RIGHT (positive X)\n    // - So we need +90 degrees (\u03C0/2 radians) to align them\n    indicator.setRotation?.(sprite.rotation + Math.PI / 2);\n  };\n\n  // Use generic SpriteAttachment system for lifecycle management\n  return createSpriteAttachment(\n    scene,\n    sprite,\n    {\n      update,\n      destroy: () => {\n        indicator.destroy();\n      },\n      getGameObject: () => indicator\n    },\n    { autoUpdate }\n  ) as DirectionalIndicator;\n}\n", "/**\n * @martini-kit/phaser - Phaser 3 adapter for multiplayer games\n *\n * Provides high-level helpers for syncing sprites and handling multiplayer in Phaser.\n *\n * @packageDocumentation\n */\n\nexport { PhaserAdapter } from './PhaserAdapter.js';\nexport type { SpriteTrackingOptions, PhaserAdapterConfig } from './PhaserAdapter.js';\n\n// Helpers\nexport { SpriteManager } from './helpers/SpriteManager.js';\nexport type { SpriteManagerConfig, SpriteData } from './helpers/SpriteManager.js';\nexport { InputManager } from './helpers/InputManager.js';\nexport type { ActionBinding, KeyBinding, KeyBindings, CursorBindings } from './helpers/InputManager.js';\nexport { PhysicsManager } from './helpers/PhysicsManager.js';\nexport type { PhysicsManagerConfig, PlatformerBehaviorConfig, TopDownBehaviorConfig, RacingBehaviorConfig, CustomBehaviorConfig } from './helpers/PhysicsManager.js';\nexport { CollisionManager } from './helpers/CollisionManager.js';\nexport type { CollisionManagerConfig, CollisionRule } from './helpers/CollisionManager.js';\nexport { PlayerUIManager } from './helpers/PlayerUIManager.js';\nexport type { PlayerUIManagerConfig, TextUIConfig, BarUIConfig } from './helpers/PlayerUIManager.js';\nexport { StateDrivenSpawner } from './helpers/StateDrivenSpawner.js';\nexport type { StateDrivenSpawnerConfig } from './helpers/StateDrivenSpawner.js';\nexport { HealthBarManager } from './helpers/HealthBarManager.js';\nexport type { HealthBarConfig } from './helpers/HealthBarManager.js';\nexport { GridClickHelper } from './helpers/GridClickHelper.js';\nexport type { GridClickConfig } from './helpers/GridClickHelper.js';\n\n// Input Profiles\nexport { registerProfile, getProfile, listProfiles, BUILT_IN_PROFILES } from './helpers/InputProfiles.js';\nexport type { InputProfile, ProfileOptions } from './helpers/InputProfiles.js';\n\n// HUD Helper\nexport { createPlayerHUD } from './helpers/HUDHelper.js';\nexport type { PlayerHUD, PlayerHUDConfig, HUDLayout, HUDTextStyle } from './helpers/HUDHelper.js';\n\n// Speed Display Helper\nexport { createSpeedDisplay } from './helpers/SpeedDisplay.js';\nexport type { SpeedDisplay, SpeedDisplayConfig } from './helpers/SpeedDisplay.js';\n\n// Sprite Attachment System (Generic)\nexport { createSpriteAttachment, createSpriteAttachments, createCompositeAttachment } from './helpers/SpriteAttachment.js';\nexport type { SpriteAttachment, SpriteAttachmentConfig } from './helpers/SpriteAttachment.js';\n\n// Directional Indicator Helper\nexport { attachDirectionalIndicator } from './helpers/DirectionalIndicator.js';\nexport type { DirectionalIndicator, DirectionalIndicatorConfig } from './helpers/DirectionalIndicator.js';\n\n// Camera Follower Helper\nexport { createCameraFollower } from './helpers/CameraFollower.js';\nexport type { CameraFollower, CameraFollowerConfig, CameraFollowerTarget } from './helpers/CameraFollower.js';\n\n// Dual Runtime Factory\nexport { createDualRuntimePreview } from './helpers/DualRuntimeFactory.js';\nexport type { DualRuntimePreview, DualRuntimePreviewConfig } from './helpers/DualRuntimeFactory.js';\n\n// Runtime initialization (transport abstraction)\nexport { initializeGame } from './runtime.js';\nexport type { MartiniKitConfig, GameConfig } from './runtime.js';\n\n// Re-export core types for convenience\nexport type { GameDefinition, Transport, GameRuntime } from '@martini-kit/core';\n", "/**\n * DualRuntimeFactory - Create host/client preview setups in one line\n *\n * Eliminates the 40+ lines of boilerplate for spinning up dual runtimes\n * that every demo and IDE route currently reimplements.\n *\n * This is the ROOT CAUSE of IDE drift - when demos update their wiring,\n * IDE routes don't, because they've all copy-pasted the setup code.\n *\n * Usage:\n * ```ts\n * const preview = createDualRuntimePreview({\n *   game: arenaBlasterGame,\n *   hostContainer,\n *   clientContainer,\n *   onHostReady: () => console.log('Host ready'),\n *   onClientReady: () => console.log('Client ready')\n * });\n *\n * // That's it! Returns:\n * // - hostRuntime\n * // - clientRuntime\n * // - hostTransport\n * // - clientTransport\n * // - cleanup function\n * ```\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\n\nexport interface DualRuntimePreviewConfig {\n  /**\n   * The game definition to run\n   */\n  game: GameDefinition;\n\n  /**\n   * Optional room ID (auto-generated if not provided)\n   */\n  roomId?: string;\n\n  /**\n   * Optional callbacks for status updates\n   */\n  onHostReady?: () => void;\n  onClientReady?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface DualRuntimePreview {\n  /**\n   * Host runtime instance\n   */\n  hostRuntime: GameRuntime;\n\n  /**\n   * Client runtime instance\n   */\n  clientRuntime: GameRuntime;\n\n  /**\n   * Host transport instance\n   */\n  hostTransport: LocalTransport;\n\n  /**\n   * Client transport instance\n   */\n  clientTransport: LocalTransport;\n\n  /**\n   * Host player ID\n   */\n  hostPlayerId: string;\n\n  /**\n   * Client player ID\n   */\n  clientPlayerId: string;\n\n  /**\n   * Generated room ID\n   */\n  roomId: string;\n\n  /**\n   * Cleanup function - call on unmount\n   */\n  cleanup: () => void;\n}\n\n/**\n * Create a dual runtime preview (host + client)\n *\n * This eliminates the ~40 lines of boilerplate that every demo/IDE route\n * currently reimplements. By using this factory, IDE routes are guaranteed\n * to stay in sync with demo implementations.\n *\n * @example\n * ```ts\n * const preview = createDualRuntimePreview({\n *   game: arenaBlasterGame,\n *   onHostReady: () => setHostStatus('ready'),\n *   onClientReady: () => setClientStatus('ready'),\n *   onError: (err) => setError(err.message)\n * });\n *\n * // Use preview.hostRuntime, preview.clientRuntime, etc.\n *\n * // Cleanup on unmount:\n * onCleanup(() => preview.cleanup());\n * ```\n */\nexport function createDualRuntimePreview(\n  config: DualRuntimePreviewConfig\n): DualRuntimePreview {\n  try {\n    // Generate room ID if not provided\n    const roomId = config.roomId || `dual-preview-${Math.random().toString(36).substring(2, 8)}`;\n\n    // Create Host instance with LocalTransport\n    const hostTransport = new LocalTransport({\n      roomId,\n      isHost: true,\n    });\n\n    // Create Client instance with LocalTransport\n    const clientTransport = new LocalTransport({\n      roomId,\n      isHost: false,\n    });\n\n    // Get both player IDs to initialize both runtimes\n    // This is CRITICAL for host-authoritative architecture:\n    // Both runtimes need to know about ALL players from the start\n    const hostPlayerId = hostTransport.getPlayerId();\n    const clientPlayerId = clientTransport.getPlayerId();\n\n    const hostRuntime = new GameRuntime(config.game, hostTransport, {\n      isHost: true,\n      playerIds: [hostPlayerId, clientPlayerId],\n    });\n\n    config.onHostReady?.();\n\n    const clientRuntime = new GameRuntime(config.game, clientTransport, {\n      isHost: false,\n      playerIds: [hostPlayerId, clientPlayerId],\n    });\n\n    config.onClientReady?.();\n\n    // Cleanup function\n    const cleanup = () => {\n      // Add any necessary cleanup here\n      // (LocalTransport doesn't currently expose cleanup, but we include this for future-proofing)\n    };\n\n    return {\n      hostRuntime,\n      clientRuntime,\n      hostTransport,\n      clientTransport,\n      hostPlayerId,\n      clientPlayerId,\n      roomId,\n      cleanup,\n    };\n  } catch (err) {\n    const error = err instanceof Error ? err : new Error('Failed to create dual runtime preview');\n    config.onError?.(error);\n    throw error;\n  }\n}\n", "/**\n * @martini-kit/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\n// import { TrysteroTransport } from '@martini-kit/transport-trystero'; // Disabled for IDE\nimport { IframeBridgeTransport } from '@martini-kit/transport-iframe-bridge';\nimport type { Transport } from '@martini-kit/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniKitConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n  };\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\ntype CleanupHandle = () => void;\n\nconst GLOBAL_GAME_KEY = '__martini-kit_CURRENT_GAME__';\n\nfunction getExistingCleanup(): CleanupHandle | null {\n  if (typeof globalThis === 'undefined') return null;\n  const existing = (globalThis as any)[GLOBAL_GAME_KEY];\n  return typeof existing?.cleanup === 'function' ? existing.cleanup : null;\n}\n\nfunction setGlobalCleanup(cleanup: CleanupHandle): void {\n  if (typeof globalThis === 'undefined') return;\n  (globalThis as any)[GLOBAL_GAME_KEY] = { cleanup };\n}\n\nfunction clearGlobalCleanup(): void {\n  if (typeof globalThis === 'undefined') return;\n  delete (globalThis as any)[GLOBAL_GAME_KEY];\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini-kit/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): { runtime: GameRuntime<TState>; phaser: Phaser.Game } {\n  const hot = typeof import.meta !== 'undefined' ? (import.meta as any).hot : undefined;\n\n  // During HMR, ensure any prior game instance is cleaned up before creating a new one\n  const previousCleanup = getExistingCleanup();\n  if (previousCleanup) {\n    previousCleanup();\n  }\n\n  // Fallback: if a transport is still registered globally (e.g., HMR edge), disconnect it\n  const leakedTransport = (globalThis as any)['__martini-kit_TRANSPORT__'];\n  if (leakedTransport) {\n    console.debug('[Martini] Found leaked transport, cleaning up...', leakedTransport);\n    if (typeof leakedTransport.disconnect === 'function') {\n      leakedTransport.disconnect();\n    } else if (typeof leakedTransport.destroy === 'function') {\n      leakedTransport.destroy();\n    }\n    // Force clear the global to ensure it's gone\n    delete (globalThis as any)['__martini-kit_TRANSPORT__'];\n    console.debug('[Martini] Transport cleanup complete, global cleared');\n  }\n\n  // Read platform-injected config\n  const platformConfig = (window as any)['__martini-kit_CONFIG__'] as MartiniKitConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __martini-kit_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: [transport.getPlayerId()]\n    }\n  );\n\n  // Resolve Phaser from import or global (Sandpack can fail to hydrate default import)\n  const PhaserLib = Phaser ?? (typeof window !== 'undefined' ? (window as any).Phaser : undefined);\n  if (!PhaserLib) {\n    throw new Error('Phaser failed to load. Ensure the Phaser script is available in the sandbox.');\n  }\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: PhaserLib.Scale.FIT,\n    autoCenter: PhaserLib.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  // Default input configuration ensures pointer/mouse/touch events work\n  // especially when running inside iframes (IDE environment)\n  const defaultInput = {\n    activePointers: 3 // Enable mouse + 2 touch pointers by default\n  };\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: PhaserLib.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    input: defaultInput,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  const phaserGame = new PhaserLib.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any)['__martini-kit_IDE__']) {\n    (window as any)['__martini-kit_IDE__'].registerRuntime(runtime);\n  }\n\n  const disconnectTransport = () => {\n    if ('disconnect' in transport && typeof (transport as any).disconnect === 'function') {\n      (transport as any).disconnect();\n    } else if ('destroy' in transport && typeof (transport as any).destroy === 'function') {\n      (transport as any).destroy();\n    }\n  };\n\n  const handleIdeDisconnect = (event: MessageEvent) => {\n    if (event.data?.type === 'martini-kit:transport:disconnect') {\n      disconnectTransport();\n    }\n  };\n\n  const handleBeforeUnload = () => {\n    disconnectTransport();\n  };\n\n  // Auto-cleanup: Disconnect transport when navigating away\n  // Two mechanisms for defense-in-depth:\n  // 1. Message from parent (IDE-initiated cleanup)\n  // 2. beforeunload event (direct browser navigation)\n  if (typeof window !== 'undefined') {\n    // Listen for IDE cleanup message\n    window.addEventListener('message', handleIdeDisconnect);\n\n    // Fallback: Disconnect on browser navigation/close\n    window.addEventListener('beforeunload', handleBeforeUnload);\n  }\n\n  let cleanedUp = false;\n  const cleanup = () => {\n    if (cleanedUp) return;\n    cleanedUp = true;\n\n    clearGlobalCleanup();\n\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('message', handleIdeDisconnect);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    }\n\n    runtime.destroy();\n    disconnectTransport();\n    phaserGame.destroy(true);\n  };\n\n  setGlobalCleanup(cleanup);\n\n  if (hot?.dispose) {\n    hot.dispose(() => {\n      cleanup();\n    });\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniKitConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    // case 'trystero':\n    //   return new TrysteroTransport({\n    //     appId: config.appId || 'martini-kit',\n    //     roomId: config.roomId,\n    //     isHost: config.isHost\n    //   });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local' and 'iframe-bridge' are supported in IDE mode.`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["state", "collection", "createCameraFollower", "GameRuntime", "LocalTransport"]
}
