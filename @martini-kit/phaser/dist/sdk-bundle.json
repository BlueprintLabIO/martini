{
  "__metadata": {
    "version": "0.1.1",
    "gitSha": "65524516373922f1e235603c1a1d6578695319f6",
    "gitBranch": "main",
    "buildTime": "2025-11-26T12:51:43.127Z"
  },
  "/node_modules/@martini-kit/phaser/PhaserAdapter.ts": "/**\n * PhaserAdapter - Bridge between Phaser and @martini-kit/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\nimport { PlayerUIManager, type PlayerUIManagerConfig } from './helpers/PlayerUIManager.js';\nimport { CollisionManager, type CollisionManagerConfig } from './helpers/CollisionManager.js';\nimport { PhysicsManager, type PhysicsManagerConfig } from './helpers/PhysicsManager.js';\nimport { StateDrivenSpawner, type StateDrivenSpawnerConfig } from './helpers/StateDrivenSpawner.js';\nimport { HealthBarManager, type HealthBarConfig } from './helpers/HealthBarManager.js';\nimport { GridClickHelper, type GridClickConfig } from './helpers/GridClickHelper.js';\nimport { GridCollisionManager, GridMovementManager, type GridCollisionConfig, type GridMovementConfig } from './helpers/GridCollisionManager.js';\nimport { GridLockedMovementManager, type GridLockedMovementConfig } from './helpers/GridLockedMovementManager.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 16ms / 60 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Optional motion profile to tune sync behavior */\n  motionProfile?: 'platformer' | 'projectile' | 'prop';\n\n  /** Namespace to write sprite data to (default: uses adapter's spriteNamespace) */\n  namespace?: string;\n\n  /** Enable adaptive sync rate (default: false) - syncs faster when moving, slower when idle */\n  adaptiveSync?: boolean;\n\n  /** Movement threshold for adaptive sync (default: 1 pixel/frame) */\n  adaptiveSyncThreshold?: number;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Snapshot buffer size in sync-intervals (optional)\n   *\n   * Defaults to auto-calculated `ceil(32ms / syncInterval)` so visuals always render\n   * ~32ms in the past, regardless of the host's sync rate. Override to trade\n   * smoothness vs latency (higher = smoother, more delay).\n   */\n  snapshotBufferSize?: number;\n\n  /**\n   * Automatically call tick action in scene.update() (default: true)\n   * When enabled, eliminates need for manual runtime.submitAction('tick', {delta})\n   * Set to false only if you need manual tick control.\n   */\n  autoTick?: boolean;\n\n  /**\n   * Name of the tick action to auto-call (default: 'tick')\n   * Only used when autoTick is enabled\n   */\n  tickAction?: string;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   snapshotBufferSize: 3           // optional, defaults to auto-sized for ~32ms delay\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\n/** Snapshot for buffered interpolation */\ninterface SpriteSnapshot {\n  x: number;\n  y: number;\n  rotation?: number;\n  timestamp: number;\n}\n\n/** Enhanced remote sprite data with interpolation state */\ninterface RemoteSpriteData {\n  sprite: any;\n  namespace: string;\n  snapshots: SpriteSnapshot[];\n  estimatedSyncInterval?: number;\n  delayIntervals?: number;\n}\n\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<\n    string,\n    {\n      sprite: any;\n      options: SpriteTrackingOptions;\n      lastPosition?: { x: number; y: number };\n      lastGrounded?: boolean;\n    }\n  > = new Map();\n  private remoteSprites: Map<string, RemoteSpriteData> = new Map();\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly snapshotBufferSizeOverride?: number;\n  private readonly targetInterpolationDelayMs: number = 32;\n  private readonly defaultSyncIntervalMs: number = 13;\n  private spriteManagers: Set<{ namespace: string }> = new Set(); // Track all registered SpriteManagers\n  private physicsManagedNamespaces: Set<string> = new Set(); // Track namespaces driven by PhysicsManager\n  private readonly autoTick: boolean;\n  private readonly tickAction: string;\n  private lastTickTime: number = Date.now();\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.snapshotBufferSizeOverride = config.snapshotBufferSize ?? 4;\n    this.autoTick = config.autoTick !== false; // default true\n    this.tickAction = config.tickAction || 'tick';\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Get the local player's ID\n   * More discoverable alias for {@link myId}\n   */\n  getLocalPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Backwards-compatible helper - alias for {@link myId}\n   * @deprecated Use {@link getLocalPlayerId} instead for better discoverability\n   */\n  getMyPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Get the current player's state object from the runtime\n   *\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  getMyPlayer<TPlayer = any>(playersKey: string = 'players'): TPlayer | undefined {\n    const state = this.runtime.getState() as any;\n    const players = state?.[playersKey];\n    if (!players) return undefined;\n    return players[this.getMyPlayerId()];\n  }\n\n  /**\n   * Subscribe to changes in the current player's state\n   *\n   * @param callback Invoked whenever the local player's record changes\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  onMyPlayerChange<TPlayer = any>(\n    callback: (player: TPlayer | undefined) => void,\n    playersKey: string = 'players'\n  ): () => void {\n    let lastValue = this.getMyPlayer<TPlayer>(playersKey);\n    callback(lastValue);\n\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const nextValue = players ? players[this.getMyPlayerId()] : undefined;\n      if (nextValue === lastValue) {\n        return;\n      }\n      lastValue = nextValue;\n      callback(nextValue);\n    });\n  }\n\n  /**\n   * Watch a derived value from the current player's state with automatic change detection\n   *\n   * This is the reactive counterpart to `onMyPlayerChange`. It re-runs a selector function\n   * on every state change and only fires the callback when the selected value changes\n   * (using Object.is equality by default).\n   *\n   * Perfect for reactive UIs that need to respond to property mutations like size, health, score, etc.\n   *\n   * @param selector Function that extracts a value from the player state\n   * @param callback Invoked when the selected value changes\n   * @param options Optional configuration\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Watch player size changes\n   * adapter.watchMyPlayer(\n   *   (player) => player?.size,\n   *   (size) => {\n   *     hudText.setText(`Size: ${size}`);\n   *   }\n   * );\n   *\n   * // Watch multiple properties\n   * adapter.watchMyPlayer(\n   *   (player) => ({ size: player?.size, health: player?.health }),\n   *   (stats) => {\n   *     hudText.setText(`Size: ${stats.size}, HP: ${stats.health}`);\n   *   }\n   * );\n   *\n   * // Custom equality check\n   * adapter.watchMyPlayer(\n   *   (player) => player?.position,\n   *   (pos) => console.log('Position changed:', pos),\n   *   { equals: (a, b) => a?.x === b?.x && a?.y === b?.y }\n   * );\n   * ```\n   */\n  watchMyPlayer<TPlayer = any, TSelected = any>(\n    selector: (player: TPlayer | undefined) => TSelected,\n    callback: (selected: TSelected, prev: TSelected | undefined) => void,\n    options?: {\n      /** Key in state where players are stored (default: 'players') */\n      playersKey?: string;\n      /** Custom equality check (default: Object.is) */\n      equals?: (a: TSelected, b: TSelected) => boolean;\n    }\n  ): () => void {\n    const playersKey = options?.playersKey || 'players';\n    const equals = options?.equals || Object.is;\n\n    // Get initial value and fire callback\n    let lastSelected = selector(this.getMyPlayer<TPlayer>(playersKey));\n    callback(lastSelected, undefined);\n\n    // Subscribe to all state changes\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const player = players ? players[this.getMyPlayerId()] : undefined;\n      const nextSelected = selector(player);\n\n      // Only fire callback if selected value changed\n      if (!equals(nextSelected, lastSelected)) {\n        const prev = lastSelected;\n        lastSelected = nextSelected;\n        callback(nextSelected, prev);\n      }\n    });\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Expose the underlying Phaser scene\n   */\n  getScene(): any {\n    return this.scene;\n  }\n\n  /**\n   * Convert pointer screen coordinates to world coordinates\n   *\n   * IMPORTANT: Always use this helper (or pointer.worldX/worldY directly)\n   * when handling pointer input for game logic. Using pointer.x/y will break\n   * when the camera is scrolled/following a player.\n   *\n   * @param pointer - Phaser pointer object from input events\n   * @returns World coordinates { x: number, y: number }\n   *\n   * @example\n   * ```ts\n   * this.input.on('pointerdown', (pointer) => {\n   *   const worldPos = adapter.pointerToWorld(pointer);\n   *   runtime.submitAction('move', { x: worldPos.x, y: worldPos.y });\n   * });\n   * ```\n   */\n  pointerToWorld(pointer: { worldX: number; worldY: number }): { x: number; y: number } {\n    return {\n      x: pointer.worldX,\n      y: pointer.worldY\n    };\n  }\n\n  /**\n   * FIX #2: Wait for required metadata properties before executing callback\n   *\n   * This is a shared utility that prevents race conditions when creating UI/sprites\n   * that depend on static properties like role, team, side, etc.\n   *\n   * Extracted pattern from PlayerUIManager and HUDHelper for reuse across the SDK.\n   *\n   * @param stateKey - Key in state where the entity data lives (e.g., 'players')\n   * @param entityId - ID of the specific entity (e.g., player ID)\n   * @param requiredProperties - Array of property names that must exist before callback fires\n   * @param callback - Called when all required properties are present\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Wait for player metadata before creating UI\n   * adapter.waitForMetadata('players', playerId, ['role', 'team'], (data) => {\n   *   const color = data.role === 'fire' ? 0xff0000 : 0x0000ff;\n   *   const sprite = this.add.circle(data.x, data.y, 20, color);\n   * });\n   *\n   * // Wait for sprite static properties\n   * adapter.waitForMetadata('__sprites__.players', spriteKey, ['role'], (data) => {\n   *   const label = this.add.text(data.x, data.y, data.role.toUpperCase());\n   * });\n   * ```\n   */\n  waitForMetadata(\n    stateKey: string,\n    entityId: string,\n    requiredProperties: string[],\n    callback: (data: any) => void\n  ): () => void {\n    // Helper to check if all required properties exist\n    const hasAllProperties = (data: any): boolean => {\n      if (!data) return false;\n      return requiredProperties.every(prop => prop in data && data[prop] !== undefined);\n    };\n\n    // Check current state immediately\n    const state = this.runtime.getState() as any;\n    const collection = this.getNestedProperty(state, stateKey);\n    const currentData = collection?.[entityId];\n\n    if (hasAllProperties(currentData)) {\n      // All properties already present - fire immediately\n      callback(currentData);\n      return () => {}; // No-op unsubscribe\n    }\n\n    // Properties not ready yet - subscribe to state changes\n    return this.runtime.onChange((state: any) => {\n      const collection = this.getNestedProperty(state, stateKey);\n      const data = collection?.[entityId];\n\n      if (hasAllProperties(data)) {\n        callback(data);\n      }\n    });\n  }\n\n  /**\n   * Helper to get nested property from state (e.g., '__sprites__.players')\n   * @internal\n   */\n  private getNestedProperty(obj: any, path: string): any {\n    const parts = path.split('.');\n    let current = obj;\n    for (const part of parts) {\n      if (current == null) return undefined;\n      current = current[part];\n    }\n    return current;\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, {\n      sprite,\n      options,\n      lastPosition: { x: sprite.x, y: sprite.y },\n      lastGrounded: undefined\n    });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 16;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // FIX #3 & #4: Do immediate first sync to guarantee ordering\n    // Previously, the first sync happened 50ms later via interval, which created\n    // a race condition where static data (from setSpriteStaticData) could arrive\n    // at clients before or after position data.\n    //\n    // Now we sync immediately, which guarantees the order:\n    // 1. setSpriteStaticData() writes static properties (e.g., role: 'fire')\n    // 2. trackSprite() immediately writes position (e.g., x, y)\n    // Both broadcasts happen synchronously in the correct order!\n    if (this.isHost()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Stop tracking a sprite\n   *\n   * @param key - Sprite key\n   * @param namespace - Optional namespace (defaults to spriteNamespace from config)\n   */\n  untrackSprite(key: string, namespace?: string): void {\n    const tracked = this.trackedSprites.get(key);\n    this.trackedSprites.delete(key);\n\n    // Use namespace from tracked options, parameter, or default\n    const ns = namespace || tracked?.options.namespace || this.spriteNamespace;\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[ns];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Call this in your Phaser scene's update() loop\n   *\n   * When autoTick is enabled, this automatically calls the tick action.\n   * Always handles remote sprite interpolation (on clients).\n   *\n   * @param time - Phaser time (total elapsed time in ms)\n   * @param delta - Phaser delta (time since last frame in ms)\n   *\n   * @example\n   * ```ts\n   * // In your Phaser scene:\n   * update(time: number, delta: number) {\n   *   adapter.update(time, delta);\n   * }\n   * ```\n   */\n  update(time: number, delta: number): void {\n    // Auto-tick: Automatically submit tick action (host only)\n    if (this.autoTick && this.isHost()) {\n      const now = Date.now();\n      const tickDelta = now - this.lastTickTime;\n      this.lastTickTime = now;\n      this.runtime.submitAction(this.tickAction, { delta: tickDelta });\n    }\n\n    // Always update interpolation on clients\n    if (!this.isHost()) {\n      this.updateInterpolation(delta);\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const { sprite, options, lastPosition } = tracked;\n      const motionProfile = options.motionProfile;\n\n      // Detect ground contact for platformers to force an immediate sync\n      let forceSync = false;\n      if (motionProfile === 'platformer' && sprite?.body) {\n        const body = sprite.body as any;\n        const grounded = !!(body.blocked?.down || body.touching?.down);\n        if (grounded && tracked.lastGrounded === false) {\n          forceSync = true; // landing transition\n        }\n        tracked.lastGrounded = grounded;\n      }\n\n      // Adaptive sync: skip if sprite hasn't moved much\n      if (!forceSync && options.adaptiveSync && lastPosition) {\n        const threshold = options.adaptiveSyncThreshold ?? 1;\n        const dx = Math.abs(sprite.x - lastPosition.x);\n        const dy = Math.abs(sprite.y - lastPosition.y);\n\n        if (dx < threshold && dy < threshold) {\n          continue; // Skip sync for idle sprite\n        }\n      }\n\n      this.syncSpriteToState(key, sprite, options);\n\n      // Update last position for adaptive sync\n      if (options.adaptiveSync) {\n        tracked.lastPosition = { x: sprite.x, y: sprite.y };\n      }\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Use namespace from options or default\n    const namespace = options.namespace || this.spriteNamespace;\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[namespace]) {\n        state[namespace] = {};\n      }\n      const sprites = state[namespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Set static metadata for a tracked sprite (host only)\n   *\n   * @param key - Sprite key\n   * @param data - Static data to set\n   * @param namespace - Optional namespace (defaults to spriteNamespace from config)\n   */\n  setSpriteStaticData(key: string, data: Record<string, any>, namespace?: string): void {\n    if (!this.isHost()) return;\n\n    const ns = namespace || this.spriteNamespace;\n    this.runtime.mutateState((state: any) => {\n      if (!state[ns]) {\n        state[ns] = {};\n      }\n      const sprites = state[ns];\n      sprites[key] = { ...data, ...sprites[key] };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   *\n   * MULTI-NAMESPACE SUPPORT: This method now handles sprites from all registered\n   * namespaces, including both the default namespace and custom namespaces from\n   * createSpriteRegistry(). This fixes the bug where sprites in custom namespaces\n   * (like __sprites__.players) weren't getting interpolation targets on clients.\n   */\n  private updateSpritesFromState(state: any): void {\n    if (this.isHost()) return;\n\n    // Collect all namespaces to check\n    const namespacesToCheck = new Set<string>();\n\n    // Add default namespace\n    namespacesToCheck.add(this.spriteNamespace);\n\n    // Add all registered SpriteManager namespaces\n    for (const manager of this.spriteManagers) {\n      namespacesToCheck.add(manager.namespace);\n    }\n\n    // Update sprites in each namespace\n    for (const namespace of namespacesToCheck) {\n      const sprites = state[namespace];\n      if (!sprites) continue; // Skip if this namespace doesn't exist in state\n\n      // Update tracked sprites (sprites that exist on this client)\n      for (const [key, tracked] of this.trackedSprites.entries()) {\n        const spriteData = sprites[key];\n        if (spriteData) {\n          this.applySpriteData(tracked.sprite, spriteData);\n        }\n      }\n\n      // Update remote sprites (sprites from other players)\n      // Store snapshot for interpolation\n      const now = Date.now();\n      for (const [key, spriteData] of Object.entries(sprites)) {\n        // Skip if this is our own sprite\n        if (this.trackedSprites.has(key)) continue;\n\n        const remoteSpriteData = this.remoteSprites.get(key);\n        if (!remoteSpriteData || remoteSpriteData.namespace !== namespace) continue;\n\n        const data = spriteData as any;\n        const snapshots = remoteSpriteData.snapshots;\n\n        snapshots.push({\n          x: data.x,\n          y: data.y,\n          rotation: data.rotation,\n          timestamp: now\n        });\n\n        // Update estimated sync interval for adaptive buffering\n        if (snapshots.length >= 2) {\n          const latest = snapshots[snapshots.length - 1].timestamp;\n          const previous = snapshots[snapshots.length - 2].timestamp;\n          const interval = latest - previous;\n          if (interval > 0) {\n            remoteSpriteData.estimatedSyncInterval = this.smoothSyncInterval(\n              remoteSpriteData.estimatedSyncInterval,\n              interval\n            );\n          }\n        }\n\n        // Keep only the snapshots needed to cover the target delay window\n        const maxSnapshots = this.getMaxSnapshots(remoteSpriteData);\n        while (snapshots.length > maxSnapshots) {\n          snapshots.shift();\n        }\n\n        // First update - snap to position immediately\n        const sprite = remoteSpriteData.sprite;\n        if (sprite.x === undefined || Number.isNaN(sprite.x)) {\n          sprite.x = data.x;\n          sprite.y = data.y;\n          sprite.rotation = data.rotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Blend new sync interval measurements with previous estimate for stability\n   */\n  private smoothSyncInterval(previous: number | undefined, next: number): number {\n    if (!previous) return next;\n    const alpha = 0.2; // simple EMA to avoid jitter in delay calculation\n    return previous * (1 - alpha) + next * alpha;\n  }\n\n  /**\n   * Number of snapshots we should keep to cover the target render delay window\n   */\n  private getMaxSnapshots(remoteSpriteData: RemoteSpriteData): number {\n    const delayIntervals = this.getDelayIntervals(remoteSpriteData);\n    // Need one more snapshot than delay intervals to bracket the render time\n    return Math.max(2, delayIntervals + 1);\n  }\n\n  /**\n   * Compute delay intervals (in sync steps) for this sprite\n   */\n  private getDelayIntervals(remoteSpriteData: RemoteSpriteData): number {\n    if (this.snapshotBufferSizeOverride) {\n      remoteSpriteData.delayIntervals = Math.max(1, this.snapshotBufferSizeOverride);\n      return remoteSpriteData.delayIntervals;\n    }\n\n    const syncInterval = remoteSpriteData.estimatedSyncInterval ?? this.defaultSyncIntervalMs;\n    const autoSize = Math.max(1, Math.ceil(this.targetInterpolationDelayMs / syncInterval));\n    remoteSpriteData.delayIntervals = autoSize;\n    return autoSize;\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   * @param namespace - Optional namespace (defaults to spriteNamespace config)\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any, namespace?: string): void {\n    this.remoteSprites.set(key, {\n      sprite,\n      namespace: namespace || this.spriteNamespace,\n      snapshots: []\n    });\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Clients always render between the last 2 received snapshots for buttery smooth motion.\n   * This eliminates frame timing jitter while adding ~32ms consistent latency.\n   */\n  updateInterpolation(_delta?: number): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    const now = Date.now();\n\n    for (const [key, remoteSpriteData] of this.remoteSprites.entries()) {\n      const sprite = remoteSpriteData.sprite;\n      // Snapshot buffer interpolation: Render between last 2 snapshots\n      this.updateSnapshotBufferInterpolation(sprite, remoteSpriteData, now);\n    }\n  }\n\n  /**\n   * Snapshot buffer interpolation (smoothest, renders in the past)\n   */\n  private updateSnapshotBufferInterpolation(\n    sprite: any,\n    remoteSpriteData: RemoteSpriteData,\n    now: number\n  ): void {\n    const snapshots = remoteSpriteData.snapshots;\n    if (!snapshots || snapshots.length < 2) return;\n\n    const syncInterval = remoteSpriteData.estimatedSyncInterval ?? this.defaultSyncIntervalMs;\n    const delayIntervals = this.getDelayIntervals(remoteSpriteData);\n    const renderDelay = delayIntervals * syncInterval;\n    const renderTime = now - renderDelay;\n\n    // Find two snapshots to interpolate between\n    let snapshot0: SpriteSnapshot = snapshots[0];\n    let snapshot1: SpriteSnapshot = snapshots[snapshots.length - 1];\n\n    for (let i = 0; i < snapshots.length - 1; i++) {\n      const current = snapshots[i];\n      const next = snapshots[i + 1];\n      if (current.timestamp <= renderTime && next.timestamp >= renderTime) {\n        snapshot0 = current;\n        snapshot1 = next;\n        break;\n      }\n    }\n\n    // Clamp to earliest/latest if renderTime is outside buffered window\n    if (renderTime <= snapshots[0].timestamp) {\n      snapshot0 = snapshots[0];\n      snapshot1 = snapshots[1] ?? snapshots[0];\n    } else if (renderTime >= snapshots[snapshots.length - 1].timestamp) {\n      snapshot0 = snapshots[snapshots.length - 2];\n      snapshot1 = snapshots[snapshots.length - 1];\n    }\n\n    // Interpolate between snapshots\n    const t0 = snapshot0.timestamp;\n    const t1 = snapshot1.timestamp;\n    const denom = t1 - t0;\n    const t = denom === 0 ? 1 : (renderTime - t0) / denom;\n    const clamped = Math.max(0, Math.min(1, t));\n\n    sprite.x = snapshot0.x + (snapshot1.x - snapshot0.x) * clamped;\n    sprite.y = snapshot0.y + (snapshot1.y - snapshot0.y) * clamped;\n\n    if (snapshot0.rotation !== undefined && snapshot1.rotation !== undefined) {\n      sprite.rotation = snapshot0.rotation + (snapshot1.rotation - snapshot0.rotation) * clamped;\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const remoteSpriteData = this.remoteSprites.get(key);\n    if (remoteSpriteData?.sprite && remoteSpriteData.sprite.destroy) {\n      remoteSpriteData.sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   namespace: 'players',  // optional, defaults to '_sprites'\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    const manager = new SpriteManager(this, config);\n    // Register the namespace for multi-namespace interpolation support\n    this.registerSpriteManager(manager);\n    return manager;\n  }\n\n  /**\n   * Register a SpriteManager with this adapter for multi-namespace support\n   * Internal method - automatically called by createSpriteManager\n   */\n  registerSpriteManager(manager: { namespace: string }): void {\n    this.spriteManagers.add(manager);\n  }\n\n  /**\n   * Check if a namespace is already managed by PhysicsManager (for conflict warnings/defaults)\n   */\n  hasPhysicsManagedNamespace(namespace: string): boolean {\n    return this.physicsManagedNamespaces.has(namespace);\n  }\n\n  /**\n   * Create a typed registry of sprite managers\n   *\n   * This provides type-safe collections of sprites with automatic namespacing.\n   * Each sprite type gets its own isolated namespace in the state tree.\n   *\n   * @example\n   * ```ts\n   * const sprites = adapter.createSpriteRegistry({\n   *   players: {\n   *     onCreate: (key, data: { x: number, y: number, role: string }) => {\n   *       const color = data.role === 'fire' ? 0xff3300 : 0x0033ff;\n   *       return this.add.circle(data.x, data.y, 20, color);\n   *     },\n   *     staticProperties: ['role'],\n   *     label: { getText: (d) => d.role.toUpperCase() }\n   *   },\n   *   enemies: {\n   *     onCreate: (key, data: { x: number, y: number, type: string }) => {\n   *       return this.add.sprite(data.x, data.y, data.type);\n   *     }\n   *   }\n   * });\n   *\n   * // Type-safe sprite creation\n   * sprites.players.add('p1', { x: 100, y: 100, role: 'fire' });\n   * sprites.enemies.add('e1', { x: 200, y: 200, type: 'goblin' });\n   *\n   * // Each collection has its own namespace:\n   * // state.__sprites__.players = { p1: { x: 100, y: 100, role: 'fire' } }\n   * // state.__sprites__.enemies = { e1: { x: 200, y: 200, type: 'goblin' } }\n   * ```\n   */\n  createSpriteRegistry<TRegistry extends Record<string, SpriteManagerConfig<any>>>(\n    config: TRegistry\n  ): {\n    [K in keyof TRegistry]: SpriteManager<\n      TRegistry[K] extends SpriteManagerConfig<infer TData> ? TData : never\n    >;\n  } {\n    const registry: any = {};\n\n    for (const [name, managerConfig] of Object.entries(config)) {\n      const manager = new SpriteManager(this, {\n        ...managerConfig,\n        namespace: `__sprites__.${name}`\n      });\n      // Register the namespace for multi-namespace interpolation support\n      this.registerSpriteManager(manager);\n      registry[name] = manager;\n    }\n\n    return registry;\n  }\n\n  /**\n   * Create a PlayerUIManager for automatically managed player HUD elements\n   */\n  createPlayerUIManager(config: PlayerUIManagerConfig): PlayerUIManager {\n    return new PlayerUIManager(this, this.scene, config);\n  }\n\n  /**\n   * Create a CollisionManager for declarative collision rules\n   */\n  createCollisionManager(config?: CollisionManagerConfig): CollisionManager {\n    return new CollisionManager(this, this.scene, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n\n  /**\n   * Create a PhysicsManager for automatic physics behaviors\n   */\n  createPhysicsManager(config: PhysicsManagerConfig): PhysicsManager {\n    if ((config as any).spriteManager?.namespace && (config as any).syncPositionToState !== false) {\n      this.physicsManagedNamespaces.add((config as any).spriteManager.namespace);\n    }\n    return new PhysicsManager(this.runtime, config);\n  }\n\n  /**\n   * Create a StateDrivenSpawner for automatic sprite spawning from state collections\n   *\n   * Eliminates the manual \"check for new players/bullets\" loop.\n   * Watches a state collection and automatically creates/removes sprites.\n   *\n   * @example\n   * ```ts\n   * // Players (uses object keys)\n   * const playerSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'players',\n   *   spriteManager: this.spriteManager,\n   *   keyPrefix: 'player-'\n   * });\n   *\n   * // Bullets (uses array with id field)\n   * const bulletSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'bullets',\n   *   spriteManager: this.bulletManager,\n   *   keyPrefix: 'bullet-',\n   *   keyField: 'id'\n   * });\n   *\n   * // In update():\n   * playerSpawner.update(); // HOST only\n   * ```\n   */\n  createStateDrivenSpawner(config: StateDrivenSpawnerConfig): StateDrivenSpawner {\n    return new StateDrivenSpawner(this, config);\n  }\n\n  /**\n   * Create a GridClickHelper for robust grid/board click handling\n   *\n   * Solves the common problem where interactive rectangles don't scale properly\n   * with the canvas. Uses pointer.worldX/worldY for accurate coordinate mapping\n   * that works in any scale mode (FIT, RESIZE, etc).\n   *\n   * Perfect for: Connect Four, Chess, Tic-Tac-Toe, Minesweeper, Battleship, etc.\n   *\n   * @example\n   * ```ts\n   * const gridHelper = adapter.createClickableGrid({\n   *   columns: 7,\n   *   rows: 6,\n   *   cellWidth: 80,\n   *   cellHeight: 80,\n   *   offsetX: 100,\n   *   offsetY: 100,\n   *   onCellClick: (col, row) => {\n   *     runtime.submitAction('dropToken', { col });\n   *   },\n   *   highlightColor: 0xffffff,\n   *   highlightAlpha: 0.15,\n   *   origin: 'bottom-left' // For Connect Four\n   * });\n   * ```\n   */\n  createClickableGrid(config: GridClickConfig): GridClickHelper {\n    return new GridClickHelper(this, this.scene, config);\n  }\n\n  /**\n   * Create a GridCollisionManager for smooth movement with grid-aligned collision\n   *\n   * ⚠️ NOTE: This provides SMOOTH movement, not grid-locked movement.\n   * For cell-to-cell committed movement (classic Bomberman), use createGridLockedMovementManager().\n   *\n   * @example\n   * ```ts\n   * const gridCollision = adapter.createGridCollisionManager({\n   *   tileSize: 52,\n   *   gridWidth: 13,\n   *   gridHeight: 13,\n   *   collisionCheck: createMultiCollisionCheck(\n   *     { name: 'blocks', fn: (x, y) => hasBlock(state.blocks, x, y) },\n   *     { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n   *   ),\n   *   debug: false // Enable to see grid overlay\n   * });\n   *\n   * // In tick action:\n   * gridCollision.moveEntity(player, input, delta);\n   * ```\n   */\n  createGridCollisionManager(config: GridCollisionConfig): GridCollisionManager {\n    return new GridCollisionManager(this, config);\n  }\n\n  /**\n   * Create a GridLockedMovementManager for true grid-locked movement\n   *\n   * Provides cell-to-cell committed movement where entities:\n   * - Align to grid cell centers\n   * - Commit to moving one full cell at a time\n   * - Can only change direction when aligned\n   * - Smoothly animate between cells\n   *\n   * Perfect for: Classic Bomberman, Pacman, Sokoban, turn-based grid games.\n   *\n   * @example\n   * ```ts\n   * const gridLocked = adapter.createGridLockedMovementManager({\n   *   tileSize: 52,\n   *   gridWidth: 13,\n   *   gridHeight: 13,\n   *   collisionCheck: createMultiCollisionCheck(\n   *     { name: 'blocks', fn: (x, y) => hasBlock(state.blocks, x, y) },\n   *     { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n   *   ),\n   *   baseSpeed: 3.0 // cells per second\n   * });\n   *\n   * // In tick action:\n   * gridLocked.moveEntity(player, input, delta);\n   * ```\n   */\n  createGridLockedMovementManager(config: GridLockedMovementConfig): GridLockedMovementManager {\n    return new GridLockedMovementManager(this, config);\n  }\n\n  /**\n   * @deprecated Use createGridCollisionManager instead. GridMovementManager has been renamed to GridCollisionManager for clarity.\n   */\n  createGridMovementManager(config: GridMovementConfig): GridCollisionManager {\n    return new GridCollisionManager(this, config);\n  }\n\n  /**\n   * Create a HealthBarManager for automatic health bar management\n   *\n   * Auto-creates, positions, scales, and colors health bars for all sprites.\n   *\n   * @example\n   * ```ts\n   * const healthBars = adapter.createHealthBarManager({\n   *   spriteManager: this.spriteManager,\n   *   healthKey: 'health',\n   *   maxHealth: 100,\n   *   offset: { x: 0, y: -30 },\n   *   width: 50,\n   *   height: 5\n   * });\n   *\n   * // In update():\n   * healthBars.update();\n   * ```\n   */\n  createHealthBarManager(config: HealthBarConfig): HealthBarManager {\n    return new HealthBarManager(this, config);\n  }\n\n  /**\n   * Create a CameraFollower for automatic camera tracking\n   *\n   * Eliminates manual camera positioning and fixes initialization timing bugs.\n   * Automatically waits for player state, then follows smoothly.\n   *\n   * @example\n   * ```ts\n   * // Simplest usage - auto-follows local player\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer'\n   * });\n   *\n   * // With smooth lerp following\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer',\n   *   mode: 'lerp',\n   *   lerpFactor: 0.1\n   * });\n   *\n   * // With world bounds\n   * this.cameraFollower = adapter.createCameraFollower({\n   *   target: 'myPlayer',\n   *   bounds: { width: 1600, height: 1200 }\n   * });\n   *\n   * // No manual camera code needed in update()!\n   * // Camera automatically follows and handles all edge cases.\n   * ```\n   */\n  createCameraFollower(config: import('./helpers/CameraFollower.js').CameraFollowerConfig = {}): import('./helpers/CameraFollower.js').CameraFollower {\n    const { createCameraFollower } = require('./helpers/CameraFollower.js');\n    return createCameraFollower(this, this.scene, config);\n  }\n\n  /**\n   * Submit action ONLY when input changes (10x devtools improvement!)\n   *\n   * Automatically tracks previous input and only submits when changed.\n   * Prevents flooding devtools with 60 identical actions per second.\n   *\n   * @param actionName - Name of the action to submit\n   * @param input - Current input state\n   * @param targetId - Optional target player ID\n   *\n   * @example\n   * ```ts\n   * // In scene.update()\n   * const input = {\n   *   left: keys.left.isDown,\n   *   right: keys.right.isDown,\n   *   up: keys.up.isDown\n   * };\n   * adapter.submitActionOnChange('move', input); // Only sends when input changes!\n   * ```\n   */\n  submitActionOnChange(actionName: string, input: any, targetId?: string): void {\n    // Use a private map to track previous inputs per action\n    if (!(this as any)._previousInputs) {\n      (this as any)._previousInputs = new Map<string, string>();\n    }\n\n    const key = targetId ? `${actionName}:${targetId}` : actionName;\n    const inputJson = JSON.stringify(input);\n    const previousJson = (this as any)._previousInputs.get(key);\n\n    // Only submit if input changed\n    if (inputJson !== previousJson) {\n      (this as any)._previousInputs.set(key, inputJson);\n      this.runtime.submitAction(actionName, input, targetId);\n    }\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/CameraFollower.ts": "/**\n * CameraFollower - Automatic camera following for local player\n *\n * Eliminates manual camera positioning code and fixes initialization timing bugs.\n * Automatically waits for player state to be ready, then follows smoothly.\n *\n * ## How it works:\n *\n * - **Initialization:** Uses `waitForMetadata` to wait for player position, then sets initial camera position\n * - **Updates:** Automatically updates camera position every frame based on follow mode\n * - **Modes:**\n *   - `instant`: Camera snaps directly to target (no smoothing)\n *   - `lerp`: Camera smoothly interpolates to target (configurable smoothness)\n *   - `deadzone`: Camera only moves when target leaves deadzone rectangle\n *\n * ## Why this helper exists:\n *\n * Without this helper, games manually set camera position in `update()`, which causes:\n * 1. **Timing bug:** Camera not positioned in `create()`, causing off-screen sprites on navigation\n * 2. **Boilerplate:** Same camera code repeated in every game\n * 3. **Edge cases:** Forgetting to check if player exists, handle player removal, etc.\n *\n * This helper solves all of these automatically.\n *\n * @example\n * ```ts\n * import { createCameraFollower } from '@martini-kit/phaser';\n *\n * // In scene.create() - simplest usage\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer' // Auto-follows local player\n * });\n *\n * // With smooth lerp following\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   mode: 'lerp',\n *   lerpFactor: 0.1 // Lower = smoother, higher = snappier\n * });\n *\n * // With deadzone (camera only moves when player leaves center area)\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   mode: 'deadzone',\n *   deadzone: { width: 200, height: 150 }\n * });\n *\n * // Follow specific player by ID\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: { stateKey: 'players', playerId: 'player-123' }\n * });\n *\n * // Set world bounds\n * this.cameraFollower = this.adapter.createCameraFollower({\n *   target: 'myPlayer',\n *   bounds: { width: 1600, height: 1200 }\n * });\n *\n * // In scene.update() - camera automatically updates, no manual code needed!\n * // But you can manually update if needed:\n * // this.cameraFollower.update();\n *\n * // In scene shutdown/destroy:\n * this.cameraFollower.destroy();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface CameraFollowerTarget {\n  /**\n   * State key where the player/entity lives (default: 'players')\n   */\n  stateKey?: string;\n\n  /**\n   * Player ID to follow (if not specified, follows local player)\n   */\n  playerId?: string;\n}\n\nexport interface CameraFollowerConfig {\n  /**\n   * Target to follow\n   * - 'myPlayer': Follow local player (default)\n   * - { stateKey: 'players', playerId: 'id' }: Follow specific player\n   */\n  target?: 'myPlayer' | CameraFollowerTarget;\n\n  /**\n   * Follow mode\n   * - 'instant': Camera snaps directly to target (default)\n   * - 'lerp': Camera smoothly interpolates to target\n   * - 'deadzone': Camera only moves when target leaves deadzone\n   */\n  mode?: 'instant' | 'lerp' | 'deadzone';\n\n  /**\n   * Lerp factor for smooth following (0-1)\n   * Lower = smoother but laggier\n   * Higher = snappier but jerkier\n   * Default: 0.1\n   * Only used when mode = 'lerp'\n   */\n  lerpFactor?: number;\n\n  /**\n   * Camera offset from target center\n   * Default: { x: 0, y: 0 }\n   */\n  offset?: { x: number; y: number };\n\n  /**\n   * World bounds for camera\n   * If specified, sets camera bounds to prevent showing outside world\n   */\n  bounds?: { width: number; height: number };\n\n  /**\n   * Deadzone dimensions (only used when mode = 'deadzone')\n   * Camera only moves when target leaves this rectangle\n   * Default: { width: 200, height: 150 }\n   */\n  deadzone?: { width: number; height: number };\n\n  /**\n   * Whether to center camera on target\n   * If true, camera centers on target position\n   * If false, target position is used as-is\n   * Default: true\n   */\n  centerOnTarget?: boolean;\n}\n\nexport interface CameraFollower {\n  /**\n   * Manually update camera position (automatically called each frame)\n   */\n  update: () => void;\n\n  /**\n   * Clean up and stop following\n   */\n  destroy: () => void;\n\n  /**\n   * Change the target being followed\n   */\n  setTarget: (playerId: string) => void;\n\n  /**\n   * Get current target player ID\n   */\n  getTarget: () => string | null;\n}\n\n/**\n * Create a camera follower that automatically tracks a player\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Camera follower configuration\n * @returns CameraFollower instance\n */\nexport function createCameraFollower(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: CameraFollowerConfig = {}\n): CameraFollower {\n  const {\n    target = 'myPlayer',\n    mode = 'instant',\n    lerpFactor = 0.1,\n    offset = { x: 0, y: 0 },\n    bounds,\n    deadzone = { width: 200, height: 150 },\n    centerOnTarget = true,\n  } = config;\n\n  // Resolve target player ID\n  let targetPlayerId: string;\n  let stateKey: string;\n\n  if (target === 'myPlayer') {\n    targetPlayerId = adapter.getMyPlayerId();\n    stateKey = 'players';\n  } else {\n    targetPlayerId = target.playerId || adapter.getMyPlayerId();\n    stateKey = target.stateKey || 'players';\n  }\n\n  const camera = scene.cameras.main;\n  let unsubscribe: (() => void) | null = null;\n  let initialized = false;\n  let destroyed = false;\n\n  // Set world bounds if specified\n  if (bounds) {\n    camera.setBounds(0, 0, bounds.width, bounds.height);\n  }\n\n  // Initialize camera position when player is ready\n  const initializeCamera = () => {\n    const state = adapter['runtime'].getState() as any;\n    const players = state?.[stateKey];\n    const player = players?.[targetPlayerId];\n\n    if (player && typeof player.x === 'number' && typeof player.y === 'number') {\n      // Set initial camera position immediately to prevent off-screen rendering\n      setCameraPosition(player.x, player.y, true);\n      initialized = true;\n    }\n  };\n\n  // Wait for player to exist, then initialize camera\n  unsubscribe = adapter.waitForMetadata(\n    stateKey,\n    targetPlayerId,\n    ['x', 'y'],\n    (playerData) => {\n      if (!initialized && !destroyed) {\n        setCameraPosition(playerData.x, playerData.y, true);\n        initialized = true;\n      }\n    }\n  );\n\n  // Also try to initialize immediately in case player already exists\n  initializeCamera();\n\n  /**\n   * Set camera position based on target coordinates\n   */\n  function setCameraPosition(targetX: number, targetY: number, instant: boolean = false) {\n    if (destroyed) return;\n\n    const viewportWidth = camera.width;\n    const viewportHeight = camera.height;\n\n    // Calculate desired camera position\n    let desiredScrollX: number;\n    let desiredScrollY: number;\n\n    if (centerOnTarget) {\n      // Center camera on target\n      desiredScrollX = targetX - viewportWidth / 2 + offset.x;\n      desiredScrollY = targetY - viewportHeight / 2 + offset.y;\n    } else {\n      // Use target position directly\n      desiredScrollX = targetX + offset.x;\n      desiredScrollY = targetY + offset.y;\n    }\n\n    // Apply follow mode\n    if (instant || mode === 'instant') {\n      camera.scrollX = desiredScrollX;\n      camera.scrollY = desiredScrollY;\n    } else if (mode === 'lerp') {\n      camera.scrollX += (desiredScrollX - camera.scrollX) * lerpFactor;\n      camera.scrollY += (desiredScrollY - camera.scrollY) * lerpFactor;\n    } else if (mode === 'deadzone') {\n      // Calculate target position in screen space\n      const targetScreenX = targetX - camera.scrollX;\n      const targetScreenY = targetY - camera.scrollY;\n\n      const deadzoneLeft = (viewportWidth - deadzone.width) / 2;\n      const deadzoneRight = deadzoneLeft + deadzone.width;\n      const deadzoneTop = (viewportHeight - deadzone.height) / 2;\n      const deadzoneBottom = deadzoneTop + deadzone.height;\n\n      // Only move camera if target is outside deadzone\n      if (targetScreenX < deadzoneLeft) {\n        camera.scrollX += targetScreenX - deadzoneLeft;\n      } else if (targetScreenX > deadzoneRight) {\n        camera.scrollX += targetScreenX - deadzoneRight;\n      }\n\n      if (targetScreenY < deadzoneTop) {\n        camera.scrollY += targetScreenY - deadzoneTop;\n      } else if (targetScreenY > deadzoneBottom) {\n        camera.scrollY += targetScreenY - deadzoneBottom;\n      }\n    }\n  }\n\n  /**\n   * Update camera position based on current player position\n   */\n  function update() {\n    if (destroyed || !initialized) return;\n\n    const state = adapter['runtime'].getState() as any;\n    const players = state?.[stateKey];\n    const player = players?.[targetPlayerId];\n\n    if (player && typeof player.x === 'number' && typeof player.y === 'number') {\n      setCameraPosition(player.x, player.y);\n    }\n  }\n\n  /**\n   * Auto-update camera every frame\n   */\n  const updateEvent = scene.events.on('update', update);\n\n  /**\n   * Clean up resources\n   */\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n\n    scene.events.off('update', update);\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = null;\n    }\n  }\n\n  /**\n   * Change the target being followed\n   */\n  function setTarget(newPlayerId: string) {\n    targetPlayerId = newPlayerId;\n    initialized = false;\n\n    // Clean up old subscription\n    if (unsubscribe) {\n      unsubscribe();\n    }\n\n    // Wait for new player and reinitialize\n    unsubscribe = adapter.waitForMetadata(\n      stateKey,\n      targetPlayerId,\n      ['x', 'y'],\n      (playerData) => {\n        if (!initialized && !destroyed) {\n          setCameraPosition(playerData.x, playerData.y, true);\n          initialized = true;\n        }\n      }\n    );\n  }\n\n  /**\n   * Get current target player ID\n   */\n  function getTarget(): string | null {\n    return targetPlayerId;\n  }\n\n  return {\n    update,\n    destroy,\n    setTarget,\n    getTarget,\n  };\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/CollectibleManager.ts": "/**\n * CollectibleManager - Automatic collectible collision detection & visual feedback\n *\n * Eliminates common bugs in collectible/powerup systems:\n * - Forgetting isHost() checks → desync bugs\n * - Manual coordinate transformations\n * - No built-in visual feedback\n * - Each game reimplements the same collision logic\n *\n * Features:\n * - Automatic host-only collision detection (prevents desyncs!)\n * - Supports grid-based and continuous coordinate spaces\n * - Built-in visual feedback (particles, sounds, popups)\n * - Type-safe configuration\n *\n * @example\n * ```ts\n * import { createCollectibleManager } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.collectibles = createCollectibleManager(this.adapter, this, {\n *   powerup: {\n *     stateKey: 'powerups',\n *     collectAction: 'collectPowerup',\n *     \n *     getPosition: (item) => ({\n *       x: item.x * TILE_SIZE + TILE_SIZE / 2,\n *       y: item.y * TILE_SIZE + TILE_SIZE / 2\n *     }),\n *     \n *     radius: 20,\n *     collisionType: 'grid', // or 'continuous'\n *     \n *     onCollect: (item) => ({\n *       popup: `+${item.type.toUpperCase()}!`,\n *       sound: 'pickup'\n *     })\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini-kit/core';\n\nexport type CollisionType = 'grid' | 'continuous';\n\nexport interface CollectibleConfig<TItem = any, TPlayer = any> {\n\t/**\n\t * Key in state where collectibles are stored\n\t * e.g., 'powerups', 'coins', 'items'\n\t */\n\tstateKey: string;\n\n\t/**\n\t * Action name to submit when collectible is collected\n\t * e.g., 'collectPowerup', 'collectCoin'\n\t */\n\tcollectAction: string;\n\n\t/**\n\t * Get world position of collectible\n\t * For grid-based, convert grid coords to world coords\n\t */\n\tgetPosition: (item: TItem) => { x: number; y: number };\n\n\t/**\n\t * Collision radius in world units\n\t */\n\tradius: number;\n\n\t/**\n\t * Collision type\n\t * - 'grid': Snap positions to grid, exact cell match\n\t * - 'continuous': Use radius-based collision in continuous space\n\t */\n\tcollisionType?: CollisionType;\n\n\t/**\n\t * Optional: Get player position (defaults to player.x, player.y)\n\t */\n\tgetPlayerPosition?: (player: TPlayer) => { x: number; y: number };\n\n\t/**\n\t * Optional: Visual feedback when collected\n\t */\n\tonCollect?: (item: TItem, scene: Phaser.Scene) => {\n\t\t/** Popup text to show (e.g., \"+BOMB!\") */\n\t\tpopup?: string;\n\t\t/** Sound key to play */\n\t\tsound?: string;\n\t\t/** Particle effect key */\n\t\tparticle?: string;\n\t} | void;\n\n\t/**\n\t * Optional: ID field name (default: 'id')\n\t */\n\tidField?: string;\n}\n\nexport interface CollectibleManagerConfig {\n\t/**\n\t * Collectible types to manage\n\t * Key is a friendly name, value is the config\n\t */\n\t[collectibleType: string]: CollectibleConfig;\n}\n\nexport interface CollectibleManager {\n\t/** Update collision detection (automatically called in adapter.update) */\n\tupdate: () => void;\n\t/** Manually trigger collection (for testing) */\n\tcollect: (collectibleType: string, itemId: any) => void;\n\t/** Destroy manager */\n\tdestroy: () => void;\n}\n\n/**\n * Create a collectible manager with automatic host-only collision detection\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Collectible configurations\n * @returns CollectibleManager instance\n */\nexport function createCollectibleManager(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: CollectibleManagerConfig\n): CollectibleManager {\n\tconst runtime = adapter.getRuntime();\n\tlet unsubscribe: (() => void) | undefined;\n\n\t/**\n\t * Check collision between player and collectible\n\t */\n\tconst checkCollision = (\n\t\tplayerPos: { x: number; y: number },\n\t\titemPos: { x: number; y: number },\n\t\tradius: number,\n\t\tcollisionType: CollisionType\n\t): boolean => {\n\t\tif (collisionType === 'grid') {\n\t\t\t// Grid-based: exact cell match (with rounding)\n\t\t\tconst playerGridX = Math.round(playerPos.x / radius);\n\t\t\tconst playerGridY = Math.round(playerPos.y / radius);\n\t\t\tconst itemGridX = Math.round(itemPos.x / radius);\n\t\t\tconst itemGridY = Math.round(itemPos.y / radius);\n\n\t\t\treturn playerGridX === itemGridX && playerGridY === itemGridY;\n\t\t} else {\n\t\t\t// Continuous: radius-based collision\n\t\t\tconst dx = playerPos.x - itemPos.x;\n\t\t\tconst dy = playerPos.y - itemPos.y;\n\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\treturn distance < radius;\n\t\t}\n\t};\n\n\t/**\n\t * Show visual feedback\n\t */\n\tconst showFeedback = (\n\t\titemPos: { x: number; y: number },\n\t\tfeedback: { popup?: string; sound?: string; particle?: string }\n\t) => {\n\t\t// Popup text\n\t\tif (feedback.popup) {\n\t\t\tconst text = scene.add.text(itemPos.x, itemPos.y - 20, feedback.popup, {\n\t\t\t\tfontSize: '16px',\n\t\t\t\tcolor: '#fbbf24',\n\t\t\t\tfontStyle: 'bold',\n\t\t\t\tstroke: '#000',\n\t\t\t\tstrokeThickness: 3\n\t\t\t});\n\t\t\ttext.setOrigin(0.5);\n\n\t\t\t// Animate up and fade out\n\t\t\tscene.tweens.add({\n\t\t\t\ttargets: text,\n\t\t\t\ty: itemPos.y - 50,\n\t\t\t\talpha: 0,\n\t\t\t\tduration: 800,\n\t\t\t\tease: 'Cubic.easeOut',\n\t\t\t\tonComplete: () => text.destroy()\n\t\t\t});\n\t\t}\n\n\t\t// Sound\n\t\tif (feedback.sound && scene.sound) {\n\t\t\ttry {\n\t\t\t\tscene.sound.play(feedback.sound);\n\t\t\t} catch (e) {\n\t\t\t\t// Sound not loaded, ignore\n\t\t\t}\n\t\t}\n\n\t\t// Particles (simple implementation)\n\t\tif (feedback.particle) {\n\t\t\t// Create simple particle effect using graphics\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst angle = (i / 8) * Math.PI * 2;\n\t\t\t\tconst speed = 50 + Math.random() * 50;\n\t\t\t\tconst vx = Math.cos(angle) * speed;\n\t\t\t\tconst vy = Math.sin(angle) * speed;\n\n\t\t\t\tconst particle = scene.add.circle(itemPos.x, itemPos.y, 3, 0xfbbf24);\n\t\t\t\tscene.tweens.add({\n\t\t\t\t\ttargets: particle,\n\t\t\t\t\tx: itemPos.x + vx,\n\t\t\t\t\ty: itemPos.y + vy,\n\t\t\t\t\talpha: 0,\n\t\t\t\t\tscale: 0,\n\t\t\t\t\tduration: 400,\n\t\t\t\t\tease: 'Cubic.easeOut',\n\t\t\t\t\tonComplete: () => particle.destroy()\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Main update function - checks collisions for current player\n\t * IMPORTANT: Only runs on HOST to prevent desyncs!\n\t */\n\tconst update = () => {\n\t\t// ✅ AUTOMATIC HOST-ONLY CHECK - prevents desync bugs!\n\t\tif (!adapter.isHost()) return;\n\n\t\tconst state = runtime.getState();\n\t\tconst myPlayerId = runtime.getMyPlayerId();\n\t\tconst myPlayer = state.players?.[myPlayerId];\n\n\t\tif (!myPlayer) return;\n\n\t\t// Check each collectible type\n\t\tfor (const [collectibleType, collectibleConfig] of Object.entries(config)) {\n\t\t\tconst items = state[collectibleConfig.stateKey];\n\t\t\tif (!Array.isArray(items)) continue;\n\n\t\t\tconst idField = collectibleConfig.idField || 'id';\n\t\t\tconst playerPos = collectibleConfig.getPlayerPosition\n\t\t\t\t? collectibleConfig.getPlayerPosition(myPlayer)\n\t\t\t\t: { x: myPlayer.x, y: myPlayer.y };\n\n\t\t\t// Check collision with each item\n\t\t\tfor (const item of items) {\n\t\t\t\tconst itemPos = collectibleConfig.getPosition(item);\n\t\t\t\tconst collisionType = collectibleConfig.collisionType || 'continuous';\n\n\t\t\t\tif (checkCollision(playerPos, itemPos, collectibleConfig.radius, collisionType)) {\n\t\t\t\t\t// Collision detected! Submit action\n\t\t\t\t\tconst itemId = item[idField];\n\n\t\t\t\t\t// Show visual feedback (client-side)\n\t\t\t\t\tconst feedback = collectibleConfig.onCollect?.(item, scene);\n\t\t\t\t\tif (feedback) {\n\t\t\t\t\t\tshowFeedback(itemPos, feedback);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Submit action (server authoritative)\n\t\t\t\t\truntime.submitAction(collectibleConfig.collectAction, { [idField]: itemId });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Manual collection trigger (for testing/buttons)\n\t */\n\tconst collect = (collectibleType: string, itemId: any) => {\n\t\tconst collectibleConfig = config[collectibleType];\n\t\tif (!collectibleConfig) {\n\t\t\tconsole.warn(`Unknown collectible type: ${collectibleType}`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst idField = collectibleConfig.idField || 'id';\n\t\truntime.submitAction(collectibleConfig.collectAction, { [idField]: itemId });\n\t};\n\n\t/**\n\t * Auto-update on state changes (optional optimization)\n\t * We could also let the scene call update() manually\n\t */\n\t// unsubscribe = adapter.onChange(() => {\n\t//   update();\n\t// });\n\n\treturn {\n\t\tupdate,\n\t\tcollect,\n\t\tdestroy: () => {\n\t\t\tunsubscribe?.();\n\t\t}\n\t};\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/CollisionManager.ts": "/**\n * CollisionManager - Declarative collision rule system\n *\n * Eliminates \"forgot to add collider for late-joining player\" bugs by:\n * - Declaring collision rules ONCE\n * - Auto-applying rules to all sprites (early and late-joining)\n * - Supporting sprites, SpriteManagers, and Phaser groups\n *\n * Usage:\n * ```ts\n * const collisionManager = adapter.createCollisionManager();\n *\n * // Register a ball sprite\n * collisionManager.registerSprite('ball', this.ball);\n *\n * // Declare collision rules ONCE\n * collisionManager.addCollision('ball', this.spriteManager);\n * // ☝️ Automatically adds colliders for all current AND future paddles!\n *\n * // With custom handler\n * collisionManager.addCollision(this.bulletGroup, this.enemyGroup, {\n *   onCollide: (bullet, enemy) => {\n *     enemy.takeDamage(bullet.damage);\n *     bullet.destroy();\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface CollisionRule {\n  a: string | SpriteManager | any; // Phaser.Physics.Arcade.Group or sprite\n  b: string | SpriteManager | any;\n  handler?: (objA: any, objB: any) => void;\n}\n\nexport interface CollisionManagerConfig {\n  /**\n   * Optional: Global collision handler\n   * Called for all collisions if no specific handler provided\n   */\n  onCollide?: (obj1: any, obj2: any) => void;\n}\n\nexport class CollisionManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: CollisionManagerConfig;\n  private rules: CollisionRule[] = [];\n  private colliders: any[] = []; // Phaser.Physics.Arcade.Collider instances\n  private namedSprites: Map<string, any> = new Map(); // key -> sprite\n  private spriteToColliders: WeakMap<any, Set<any>> = new WeakMap(); // sprite -> Set of colliders\n\n  constructor(adapter: PhaserAdapter, scene: any, config?: CollisionManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config || {};\n  }\n\n  /**\n   * Register a sprite by name (for string-based collision rules)\n   *\n   * @example\n   * ```ts\n   * collisionManager.registerSprite('ball', this.ball);\n   * collisionManager.addCollision('ball', paddleManager);\n   * ```\n   */\n  registerSprite(key: string, sprite: any): void {\n    this.namedSprites.set(key, sprite);\n    // Re-apply all rules to create colliders for this newly registered sprite\n    for (const rule of this.rules) {\n      this.applyRule(rule);\n    }\n  }\n\n  /**\n   * Unregister a sprite by name\n   */\n  unregisterSprite(key: string): void {\n    const sprite = this.namedSprites.get(key);\n    if (sprite) {\n      this.removeCollidersForSprite(sprite);\n    }\n    this.namedSprites.delete(key);\n  }\n\n  /**\n   * Add collision between sprites/groups/managers\n   *\n   * Supports:\n   * - String keys (via registerSprite)\n   * - SpriteManager instances (auto-syncs with new sprites)\n   * - Phaser sprites or groups\n   */\n  addCollision(\n    a: string | SpriteManager | any,\n    b: string | SpriteManager | any,\n    options?: {\n      onCollide?: (obj1: any, obj2: any) => void;\n    }\n  ): void {\n    const rule: CollisionRule = {\n      a,\n      b,\n      handler: options?.onCollide\n    };\n\n    this.rules.push(rule);\n\n    // Apply rule immediately\n    // Note: If either side is a SpriteManager, resolveToObjects() will return\n    // the manager's Phaser Group, which automatically handles all sprites\n    // (both current and future) without needing lifecycle hooks\n    this.applyRule(rule);\n  }\n\n  /**\n   * Remove collision rule\n   */\n  removeCollision(a: string | SpriteManager | any, b: string | SpriteManager | any): void {\n    const ruleIndex = this.rules.findIndex(r =>\n      (r.a === a && r.b === b) || (r.a === b && r.b === a)\n    );\n\n    if (ruleIndex !== -1) {\n      this.rules.splice(ruleIndex, 1);\n      // Note: We don't remove existing colliders, just stop creating new ones\n    }\n  }\n\n  /**\n   * Cleanup all colliders\n   */\n  destroy(): void {\n    for (const collider of this.colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n    }\n    this.colliders.length = 0;\n    this.rules.length = 0;\n    this.namedSprites.clear();\n  }\n\n  /**\n   * Apply a single collision rule (create colliders)\n   */\n  private applyRule(rule: CollisionRule): void {\n    const objectsA = this.resolveToObjects(rule.a);\n    const objectsB = this.resolveToObjects(rule.b);\n\n    if (objectsA.length === 0 || objectsB.length === 0) {\n      // One or both sides have no objects yet\n      return;\n    }\n\n    const handler = rule.handler || this.config.onCollide;\n\n    // Create colliders for each combination\n    for (const objA of objectsA) {\n      for (const objB of objectsB) {\n        // Skip if collider already exists\n        if (this.hasCollider(objA, objB)) {\n          continue;\n        }\n\n        // Create the collider\n        const collider = this.scene.physics.add.collider(objA, objB, handler);\n        this.colliders.push(collider);\n\n        // Track colliders per sprite\n        this.trackCollider(objA, collider);\n        this.trackCollider(objB, collider);\n      }\n    }\n  }\n\n  /**\n   * Resolve a rule target to an array of Phaser objects\n   */\n  private resolveToObjects(target: string | SpriteManager | any): any[] {\n    if (typeof target === 'string') {\n      // It's a named sprite\n      const sprite = this.namedSprites.get(target);\n      return sprite ? [sprite] : [];\n    }\n\n    if (this.isSpriteManager(target)) {\n      // It's a SpriteManager - return its Phaser Group\n      // The group automatically handles all sprites (early and late-joining)\n      return [(target as SpriteManager).group];\n    }\n\n    // It's a raw Phaser object (sprite or group)\n    return [target];\n  }\n\n  /**\n   * Check if target is a SpriteManager\n   */\n  private isSpriteManager(target: any): boolean {\n    return target && typeof target === 'object' && 'getAll' in target && 'add' in target;\n  }\n\n  /**\n   * Check if a collider already exists between two objects\n   */\n  private hasCollider(objA: any, objB: any): boolean {\n    const collidersA = this.spriteToColliders.get(objA);\n    const collidersB = this.spriteToColliders.get(objB);\n\n    if (!collidersA || !collidersB) {\n      return false;\n    }\n\n    // Check if any collider is shared\n    for (const collider of collidersA) {\n      if (collidersB.has(collider)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Track that a collider belongs to a sprite\n   */\n  private trackCollider(sprite: any, collider: any): void {\n    let colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) {\n      colliders = new Set();\n      this.spriteToColliders.set(sprite, colliders);\n    }\n    colliders.add(collider);\n  }\n\n  /**\n   * Remove all colliders associated with a sprite\n   */\n  private removeCollidersForSprite(sprite: any): void {\n    const colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) return;\n\n    for (const collider of colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n      const index = this.colliders.indexOf(collider);\n      if (index !== -1) {\n        this.colliders.splice(index, 1);\n      }\n    }\n\n    this.spriteToColliders.delete(sprite);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/DirectionalIndicator.ts": "/**\n * DirectionalIndicator - Arrow/indicator that shows sprite direction\n *\n * Automatically handles Phaser's rotation convention (0 = right/+X axis)\n * so you don't have to think about rotation offsets.\n *\n * ## Phaser Rotation Convention\n *\n * Phaser uses a coordinate system where:\n * - 0 radians = pointing RIGHT (positive X axis)\n * - π/2 radians = pointing DOWN (positive Y axis)\n * - π radians = pointing LEFT (negative X axis)\n * - -π/2 radians = pointing UP (negative Y axis)\n *\n * This helper automatically adds a +π/2 offset to triangle/arrow shapes\n * (which naturally point UP) so they align with the sprite's rotation.\n *\n * ## Auto-Update (Pit of Success!)\n *\n * By default, indicators automatically update every frame via scene events.\n * **No manual update() calls needed!** Just attach and forget.\n *\n * @example Automatic updates (recommended - default behavior)\n * ```ts\n * import { attachDirectionalIndicator } from '@martini-kit/phaser';\n *\n * // In SpriteManager onCreate or onAdd:\n * onCreate: (key, data) => {\n *   const car = this.add.rectangle(data.x, data.y, 30, 20, data.color);\n *\n *   // That's it! Arrow auto-updates every frame\n *   attachDirectionalIndicator(this, car, {\n *     shape: 'triangle',\n *     offset: 20,\n *     color: 0xffffff\n *     // autoUpdate: true is the default\n *   });\n *\n *   return car;\n * }\n * ```\n *\n * @example Manual updates (if you need fine control)\n * ```ts\n * onCreate: (key, data) => {\n *   const car = this.add.rectangle(data.x, data.y, 30, 20, data.color);\n *\n *   car.directionArrow = attachDirectionalIndicator(this, car, {\n *     shape: 'triangle',\n *     offset: 20,\n *     color: 0xffffff,\n *     autoUpdate: false  // Disable auto-update\n *   });\n *\n *   return car;\n * },\n *\n * // Then in your scene's update loop:\n * update() {\n *   for (const [, sprite] of this.spriteManager.getAll()) {\n *     sprite.directionArrow?.update();\n *   }\n * }\n * ```\n */\n\nimport type Phaser from 'phaser';\nimport { createSpriteAttachment, type SpriteAttachment } from './SpriteAttachment';\n\nexport interface DirectionalIndicatorConfig {\n  /**\n   * Shape of the indicator\n   * - 'triangle': Classic arrow shape (default)\n   * - 'arrow': Longer arrow with tail\n   * - 'chevron': V-shaped chevron\n   */\n  shape?: 'triangle' | 'arrow' | 'chevron';\n\n  /**\n   * Distance from sprite center\n   * Default: 20\n   */\n  offset?: number;\n\n  /**\n   * Indicator color\n   * Default: 0xffffff (white)\n   */\n  color?: number;\n\n  /**\n   * Indicator size/scale\n   * Default: 1.0\n   */\n  size?: number;\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Automatically update the indicator every frame\n   *\n   * When true (default), the indicator subscribes to the scene's update event\n   * and automatically follows the sprite's position/rotation each frame.\n   * No manual update() calls needed!\n   *\n   * When false, you must manually call indicator.update() in your scene loop.\n   *\n   * @default true\n   */\n  autoUpdate?: boolean;\n}\n\nexport interface DirectionalIndicator extends SpriteAttachment {\n  /**\n   * Get the underlying Phaser game object\n   *\n   * @override Always defined for DirectionalIndicator (not optional)\n   */\n  getGameObject: () => Phaser.GameObjects.GameObject;\n}\n\n/**\n * Attach a directional indicator to a sprite\n *\n * Automatically handles Phaser's rotation convention where:\n * - 0 radians = pointing right (+X axis)\n * - Math.PI/2 = pointing down (+Y axis)\n * - Math.PI = pointing left (-X axis)\n * - -Math.PI/2 = pointing up (-Y axis)\n *\n * By default (autoUpdate: true), the indicator automatically updates every frame.\n * No manual update() calls needed - it \"just works\"!\n *\n * @param scene - Phaser scene\n * @param sprite - Sprite to attach indicator to\n * @param config - Indicator configuration\n * @returns DirectionalIndicator instance\n */\nexport function attachDirectionalIndicator(\n  scene: Phaser.Scene,\n  sprite: any,\n  config: DirectionalIndicatorConfig = {}\n): DirectionalIndicator {\n  const shape = config.shape ?? 'triangle';\n  const offset = config.offset ?? 20;\n  const color = config.color ?? 0xffffff;\n  const size = config.size ?? 1.0;\n  const autoUpdate = config.autoUpdate ?? true;\n\n  let indicator: Phaser.GameObjects.GameObject & {\n    setPosition?: (x: number, y: number) => any;\n    setRotation?: (rotation: number) => any;\n  };\n\n  // Create the appropriate shape\n  switch (shape) {\n    case 'triangle': {\n      // Triangle pointing UP (negative Y) in default orientation\n      // We'll add π/2 rotation offset in update() to match Phaser's convention\n      const triangle = scene.add.triangle(\n        sprite.x,\n        sprite.y,\n        0, -5,        // Top point (tip)\n        -4, 5,        // Bottom left\n        4, 5,         // Bottom right\n        color\n      );\n      triangle.setOrigin(0.5);\n      if (config.depth !== undefined) {\n        triangle.setDepth(config.depth);\n      }\n      indicator = triangle;\n      break;\n    }\n\n    case 'arrow': {\n      // Longer arrow with distinct head and tail\n      const container = scene.add.container(sprite.x, sprite.y);\n\n      // Arrow shaft (horizontal line)\n      const shaft = scene.add.rectangle(-3 * size, 0, 10 * size, 2 * size, color);\n      shaft.setOrigin(0.5);\n\n      // Arrow head (triangle)\n      const head = scene.add.triangle(\n        5 * size, 0,\n        0, 0,              // Point\n        -3 * size, -3 * size, // Top\n        -3 * size, 3 * size,  // Bottom\n        color\n      );\n      head.setOrigin(0.5);\n\n      container.add([shaft, head]);\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n      indicator = container;\n      break;\n    }\n\n    case 'chevron': {\n      // V-shaped chevron\n      const graphics = scene.add.graphics();\n      graphics.lineStyle(2 * size, color);\n      // Draw > shape (pointing right)\n      graphics.beginPath();\n      graphics.moveTo(-4 * size, -4 * size);\n      graphics.lineTo(4 * size, 0);\n      graphics.lineTo(-4 * size, 4 * size);\n      graphics.strokePath();\n      graphics.setPosition(sprite.x, sprite.y);\n      if (config.depth !== undefined) {\n        graphics.setDepth(config.depth);\n      }\n      indicator = graphics;\n      break;\n    }\n  }\n\n  // Update function - positions indicator in front of sprite\n  const update = () => {\n    // Calculate position in front of sprite (in the direction it's facing)\n    const indicatorX = sprite.x + Math.cos(sprite.rotation) * offset;\n    const indicatorY = sprite.y + Math.sin(sprite.rotation) * offset;\n\n    indicator.setPosition?.(indicatorX, indicatorY);\n\n    // Add π/2 rotation offset because:\n    // - Triangle points UP (negative Y) at rotation 0\n    // - Phaser's 0 rotation points RIGHT (positive X)\n    // - So we need +90 degrees (π/2 radians) to align them\n    indicator.setRotation?.(sprite.rotation + Math.PI / 2);\n  };\n\n  // Use generic SpriteAttachment system for lifecycle management\n  return createSpriteAttachment(\n    scene,\n    sprite,\n    {\n      update,\n      destroy: () => {\n        indicator.destroy();\n      },\n      getGameObject: () => indicator\n    },\n    { autoUpdate }\n  ) as DirectionalIndicator;\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/DualRuntimeFactory.ts": "/**\n * DualRuntimeFactory - Create host/client preview setups in one line\n *\n * Eliminates the 40+ lines of boilerplate for spinning up dual runtimes\n * that every demo and IDE route currently reimplements.\n *\n * This is the ROOT CAUSE of IDE drift - when demos update their wiring,\n * IDE routes don't, because they've all copy-pasted the setup code.\n *\n * Usage:\n * ```ts\n * const preview = createDualRuntimePreview({\n *   game: arenaBlasterGame,\n *   hostContainer,\n *   clientContainer,\n *   onHostReady: () => console.log('Host ready'),\n *   onClientReady: () => console.log('Client ready')\n * });\n *\n * // That's it! Returns:\n * // - hostRuntime\n * // - clientRuntime\n * // - hostTransport\n * // - clientTransport\n * // - cleanup function\n * ```\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\n\nexport interface DualRuntimePreviewConfig {\n  /**\n   * The game definition to run\n   */\n  game: GameDefinition;\n\n  /**\n   * Optional room ID (auto-generated if not provided)\n   */\n  roomId?: string;\n\n  /**\n   * Optional callbacks for status updates\n   */\n  onHostReady?: () => void;\n  onClientReady?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface DualRuntimePreview {\n  /**\n   * Host runtime instance\n   */\n  hostRuntime: GameRuntime;\n\n  /**\n   * Client runtime instance\n   */\n  clientRuntime: GameRuntime;\n\n  /**\n   * Host transport instance\n   */\n  hostTransport: LocalTransport;\n\n  /**\n   * Client transport instance\n   */\n  clientTransport: LocalTransport;\n\n  /**\n   * Host player ID\n   */\n  hostPlayerId: string;\n\n  /**\n   * Client player ID\n   */\n  clientPlayerId: string;\n\n  /**\n   * Generated room ID\n   */\n  roomId: string;\n\n  /**\n   * Cleanup function - call on unmount\n   */\n  cleanup: () => void;\n}\n\n/**\n * Create a dual runtime preview (host + client)\n *\n * This eliminates the ~40 lines of boilerplate that every demo/IDE route\n * currently reimplements. By using this factory, IDE routes are guaranteed\n * to stay in sync with demo implementations.\n *\n * @example\n * ```ts\n * const preview = createDualRuntimePreview({\n *   game: arenaBlasterGame,\n *   onHostReady: () => setHostStatus('ready'),\n *   onClientReady: () => setClientStatus('ready'),\n *   onError: (err) => setError(err.message)\n * });\n *\n * // Use preview.hostRuntime, preview.clientRuntime, etc.\n *\n * // Cleanup on unmount:\n * onCleanup(() => preview.cleanup());\n * ```\n */\nexport function createDualRuntimePreview(\n  config: DualRuntimePreviewConfig\n): DualRuntimePreview {\n  try {\n    // Generate room ID if not provided\n    const roomId = config.roomId || `dual-preview-${Math.random().toString(36).substring(2, 8)}`;\n\n    // Create Host instance with LocalTransport\n    const hostTransport = new LocalTransport({\n      roomId,\n      isHost: true,\n    });\n\n    // Create Client instance with LocalTransport\n    const clientTransport = new LocalTransport({\n      roomId,\n      isHost: false,\n    });\n\n    // Get both player IDs to initialize both runtimes\n    // This is CRITICAL for host-authoritative architecture:\n    // Both runtimes need to know about ALL players from the start\n    const hostPlayerId = hostTransport.getPlayerId();\n    const clientPlayerId = clientTransport.getPlayerId();\n\n    const hostRuntime = new GameRuntime(config.game, hostTransport, {\n      isHost: true,\n      playerIds: [hostPlayerId, clientPlayerId],\n    });\n\n    config.onHostReady?.();\n\n    const clientRuntime = new GameRuntime(config.game, clientTransport, {\n      isHost: false,\n      playerIds: [hostPlayerId, clientPlayerId],\n    });\n\n    config.onClientReady?.();\n\n    // Cleanup function\n    const cleanup = () => {\n      // Add any necessary cleanup here\n      // (LocalTransport doesn't currently expose cleanup, but we include this for future-proofing)\n    };\n\n    return {\n      hostRuntime,\n      clientRuntime,\n      hostTransport,\n      clientTransport,\n      hostPlayerId,\n      clientPlayerId,\n      roomId,\n      cleanup,\n    };\n  } catch (err) {\n    const error = err instanceof Error ? err : new Error('Failed to create dual runtime preview');\n    config.onError?.(error);\n    throw error;\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/GridClickHelper.ts": "/**\n * GridClickHelper - Robust grid/board click handling\n *\n * Solves the common problem of grid-based games where interactive rectangles\n * don't scale properly with the canvas. Uses pointer.worldX/worldY for\n * accurate coordinate-to-grid mapping that works in any scale mode.\n *\n * Perfect for: Connect Four, Chess, Tic-Tac-Toe, Minesweeper, Battleship,\n * Checkers, Go, Reversi, Sudoku, Bejeweled, etc.\n *\n * Usage:\n * ```ts\n * const gridHelper = adapter.createClickableGrid({\n *   columns: 7,\n *   rows: 6,\n *   cellWidth: 80,\n *   cellHeight: 80,\n *   offsetX: 100,\n *   offsetY: 100,\n *   onCellClick: (col, row) => {\n *     runtime.submitAction('dropToken', { col });\n *   },\n *   highlightColor: 0xffffff,\n *   highlightAlpha: 0.15\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface GridClickConfig {\n  /** Number of columns in the grid */\n  columns: number;\n\n  /** Number of rows in the grid */\n  rows: number;\n\n  /** Width of each cell in pixels */\n  cellWidth: number;\n\n  /** Height of each cell in pixels */\n  cellHeight: number;\n\n  /** X offset of the grid's top-left corner (in world coordinates) */\n  offsetX: number;\n\n  /** Y offset of the grid's top-left corner (in world coordinates) */\n  offsetY: number;\n\n  /** Callback when a cell is clicked - receives (col, row) */\n  onCellClick: (col: number, row: number) => void;\n\n  /**\n   * Optional: Validate if a cell can be clicked\n   * Return true to allow click, false to block\n   */\n  canClick?: (col: number, row: number) => boolean;\n\n  /**\n   * Optional: Validate if a cell can be highlighted on hover\n   * Return true to show highlight, false to hide\n   */\n  canHighlight?: (col: number, row: number) => boolean;\n\n  /** Optional: Highlight color (default: 0xffffff) */\n  highlightColor?: number;\n\n  /** Optional: Highlight alpha (default: 0.15) */\n  highlightAlpha?: number;\n\n  /** Optional: Show cursor pointer on hover (default: true) */\n  useHandCursor?: boolean;\n\n  /**\n   * Optional: Grid layout mode\n   * - 'top-left': (0,0) is top-left corner (default for most grids)\n   * - 'bottom-left': (0,0) is bottom-left corner (for Connect Four, platformers)\n   */\n  origin?: 'top-left' | 'bottom-left';\n\n  /**\n   * Optional: Cell click mode\n   * - 'down': Fire on pointerdown (default, feels responsive)\n   * - 'up': Fire on pointerup (better for drag operations)\n   */\n  clickMode?: 'down' | 'up';\n\n  /**\n   * Optional: Enable debug visualization\n   * Shows grid lines and cell coordinates\n   */\n  debug?: boolean;\n}\n\nexport class GridClickHelper {\n  private config: Required<GridClickConfig>;\n  private scene: Phaser.Scene;\n  private highlights: Phaser.GameObjects.Rectangle[] = [];\n  private debugGraphics?: Phaser.GameObjects.Graphics;\n  private debugTexts: Phaser.GameObjects.Text[] = [];\n\n  constructor(adapter: PhaserAdapter, scene: Phaser.Scene, config: GridClickConfig) {\n    this.scene = scene;\n\n    // Fill in defaults\n    this.config = {\n      ...config,\n      canClick: config.canClick ?? (() => true),\n      canHighlight: config.canHighlight ?? (() => true),\n      highlightColor: config.highlightColor ?? 0xffffff,\n      highlightAlpha: config.highlightAlpha ?? 0.15,\n      useHandCursor: config.useHandCursor ?? true,\n      origin: config.origin ?? 'top-left',\n      clickMode: config.clickMode ?? 'down',\n      debug: config.debug ?? false\n    };\n\n    this.setupHighlights();\n    this.setupInputHandlers();\n\n    if (this.config.debug) {\n      this.setupDebugVisualization();\n    }\n  }\n\n  /**\n   * Create highlight rectangles for visual feedback\n   */\n  private setupHighlights(): void {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, highlightColor, origin } = this.config;\n\n    for (let col = 0; col < columns; col++) {\n      for (let row = 0; row < rows; row++) {\n        const x = offsetX + col * cellWidth + cellWidth / 2;\n\n        // Handle different origin modes\n        const y = origin === 'bottom-left'\n          ? offsetY + (rows - 1 - row) * cellHeight + cellHeight / 2\n          : offsetY + row * cellHeight + cellHeight / 2;\n\n        const highlight = this.scene.add.rectangle(\n          x,\n          y,\n          cellWidth,\n          cellHeight,\n          highlightColor,\n          0 // Start invisible\n        );\n\n        // Store index for easy lookup\n        (highlight as any).gridCol = col;\n        (highlight as any).gridRow = row;\n\n        this.highlights.push(highlight);\n      }\n    }\n  }\n\n  /**\n   * Setup pointer event handlers using worldX/worldY for accurate mapping\n   */\n  private setupInputHandlers(): void {\n    const { useHandCursor, clickMode } = this.config;\n\n    // Handle pointer move for hover highlights\n    this.scene.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {\n      const cell = this.pointerToCell(pointer);\n\n      // Hide all highlights\n      this.highlights.forEach(h => h.setAlpha(0));\n\n      // Show highlight for hovered cell if valid\n      if (cell && this.config.canHighlight(cell.col, cell.row)) {\n        const highlight = this.getHighlight(cell.col, cell.row);\n        if (highlight) {\n          highlight.setAlpha(this.config.highlightAlpha);\n        }\n      }\n\n      // Update cursor\n      if (useHandCursor) {\n        const canClick = cell && this.config.canClick(cell.col, cell.row);\n        this.scene.input.setDefaultCursor(canClick ? 'pointer' : 'default');\n      }\n    });\n\n    // Handle clicks\n    const eventName = clickMode === 'down' ? 'pointerdown' : 'pointerup';\n    this.scene.input.on(eventName, (pointer: Phaser.Input.Pointer) => {\n      const cell = this.pointerToCell(pointer);\n\n      if (cell && this.config.canClick(cell.col, cell.row)) {\n        this.config.onCellClick(cell.col, cell.row);\n\n        // Flash the highlight for feedback\n        const highlight = this.getHighlight(cell.col, cell.row);\n        if (highlight) {\n          this.scene.tweens.add({\n            targets: highlight,\n            alpha: this.config.highlightAlpha * 2,\n            duration: 100,\n            yoyo: true\n          });\n        }\n      }\n    });\n\n    // Reset cursor when pointer leaves\n    this.scene.input.on('pointerout', () => {\n      this.highlights.forEach(h => h.setAlpha(0));\n      if (useHandCursor) {\n        this.scene.input.setDefaultCursor('default');\n      }\n    });\n  }\n\n  /**\n   * Convert pointer coordinates to grid cell\n   * Uses worldX/worldY for accurate mapping in any scale mode\n   */\n  private pointerToCell(pointer: Phaser.Input.Pointer): { col: number; row: number } | null {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, origin } = this.config;\n\n    // Use worldX/worldY to account for camera transforms and scaling\n    const col = Math.floor((pointer.worldX - offsetX) / cellWidth);\n    const rowFromTop = Math.floor((pointer.worldY - offsetY) / cellHeight);\n\n    // Convert to grid coordinates based on origin\n    const row = origin === 'bottom-left' ? rows - 1 - rowFromTop : rowFromTop;\n\n    // Validate bounds\n    if (col < 0 || col >= columns || row < 0 || row >= rows) {\n      return null;\n    }\n\n    return { col, row };\n  }\n\n  /**\n   * Get highlight rectangle for a specific cell\n   */\n  private getHighlight(col: number, row: number): Phaser.GameObjects.Rectangle | undefined {\n    return this.highlights.find(h => (h as any).gridCol === col && (h as any).gridRow === row);\n  }\n\n  /**\n   * Setup debug visualization (grid lines and coordinates)\n   */\n  private setupDebugVisualization(): void {\n    const { columns, rows, cellWidth, cellHeight, offsetX, offsetY, origin } = this.config;\n\n    // Draw grid lines\n    this.debugGraphics = this.scene.add.graphics();\n    this.debugGraphics.lineStyle(1, 0xff00ff, 0.5);\n\n    // Vertical lines\n    for (let col = 0; col <= columns; col++) {\n      const x = offsetX + col * cellWidth;\n      this.debugGraphics.lineBetween(x, offsetY, x, offsetY + rows * cellHeight);\n    }\n\n    // Horizontal lines\n    for (let row = 0; row <= rows; row++) {\n      const y = offsetY + row * cellHeight;\n      this.debugGraphics.lineBetween(offsetX, y, offsetX + columns * cellWidth, y);\n    }\n\n    // Draw cell coordinates\n    for (let col = 0; col < columns; col++) {\n      for (let row = 0; row < rows; row++) {\n        const x = offsetX + col * cellWidth + 5;\n\n        // Handle different origin modes\n        const y = origin === 'bottom-left'\n          ? offsetY + (rows - 1 - row) * cellHeight + 5\n          : offsetY + row * cellHeight + 5;\n\n        const text = this.scene.add.text(x, y, `${col},${row}`, {\n          fontSize: '10px',\n          color: '#ff00ff',\n          backgroundColor: '#000000'\n        });\n        this.debugTexts.push(text);\n      }\n    }\n  }\n\n  /**\n   * Manually trigger a highlight (useful for showing valid moves, etc.)\n   */\n  showHighlight(col: number, row: number, alpha?: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setAlpha(alpha ?? this.config.highlightAlpha);\n    }\n  }\n\n  /**\n   * Hide a specific cell's highlight\n   */\n  hideHighlight(col: number, row: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setAlpha(0);\n    }\n  }\n\n  /**\n   * Hide all highlights\n   */\n  hideAllHighlights(): void {\n    this.highlights.forEach(h => h.setAlpha(0));\n  }\n\n  /**\n   * Update highlight color for a specific cell\n   */\n  setHighlightColor(col: number, row: number, color: number): void {\n    const highlight = this.getHighlight(col, row);\n    if (highlight) {\n      highlight.setFillStyle(color);\n    }\n  }\n\n  /**\n   * Destroy the helper and clean up resources\n   */\n  destroy(): void {\n    this.highlights.forEach(h => h.destroy());\n    this.debugGraphics?.destroy();\n    this.debugTexts.forEach(t => t.destroy());\n    this.highlights = [];\n    this.debugTexts = [];\n\n    // Remove input listeners\n    this.scene.input.off('pointermove');\n    this.scene.input.off('pointerdown');\n    this.scene.input.off('pointerup');\n    this.scene.input.off('pointerout');\n  }\n}\n\n/**\n * Factory function for creating a GridClickHelper\n * Called from PhaserAdapter.createClickableGrid()\n */\nexport function createClickableGrid(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: GridClickConfig\n): GridClickHelper {\n  return new GridClickHelper(adapter, scene, config);\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/GridCollisionManager.ts": "/**\n * GridCollisionManager - Grid-based collision detection for smooth movement\n *\n * ⚠️ NOTE: This does NOT lock entities to grid cells like classic Bomberman.\n * It provides smooth pixel movement with grid-aligned collision checks.\n *\n * For true grid-locked movement (cell-to-cell committed movement), use\n * GridLockedMovementManager instead.\n *\n * Features:\n * - Smooth pixel-by-pixel movement\n * - Grid-aligned collision detection\n * - Supports diagonal movement with normalization\n * - Optional debug visualization\n *\n * ⚠️ COMMON MISTAKES:\n * ❌ Only checking blocks → Also check bombs, enemies, hazards\n * ❌ Creating in tick action → Create in scene.create() instead\n * ❌ Expecting grid-locking → Use GridLockedMovementManager for that\n *\n * ✅ CORRECT USAGE:\n * ```ts\n * // scene.create()\n * this.gridCollision = this.adapter.createGridCollisionManager({\n *   tileSize: 52,\n *   gridWidth: 13,\n *   gridHeight: 13,\n *   collisionCheck: createMultiCollisionCheck(\n *     { name: 'blocks', fn: (x, y) => hasBlock(state.blocks, x, y) },\n *     { name: 'bombs', fn: (x, y) => hasBomb(state.bombs, x, y) }\n *   ),\n *   debug: false // Enable to see grid overlay\n * });\n *\n * // game.ts tick action\n * tick: createTickAction((state, delta) => {\n *   forEachPlayerInput(state, (player, input) => {\n *     this.gridCollision.moveEntity(player, input, delta);\n *   });\n * })\n * ```\n *\n * @see GridLockedMovementManager for Bomberman-style grid locking\n * @see createMultiCollisionCheck for combining multiple collision types\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface GridCollisionConfig {\n  /**\n   * Size of each grid cell in pixels\n   */\n  tileSize: number;\n\n  /**\n   * Width of the grid in cells\n   */\n  gridWidth: number;\n\n  /**\n   * Height of the grid in cells\n   */\n  gridHeight: number;\n\n  /**\n   * Collision check function\n   * Returns true if there's a blocking obstacle at (gridX, gridY)\n   * \n   * ⚠️ Remember to check ALL obstacle types: blocks, bombs, enemies, etc.\n   * Consider using createMultiCollisionCheck() helper.\n   */\n  collisionCheck: (gridX: number, gridY: number) => boolean;\n\n  /**\n   * Base movement speed in pixels per second (default: 150)\n   */\n  baseSpeed?: number;\n\n  /**\n   * Normalize diagonal movement (default: true)\n   * When true, diagonal movement is same speed as cardinal\n   */\n  normalizeDiagonal?: boolean;\n\n  /**\n   * Enable debug visualization (default: false)\n   * Shows grid lines, collision cells, entity positions\n   */\n  debug?: boolean;\n\n  /**\n   * Debug color (default: 0xff0000 red)\n   */\n  debugColor?: number;\n}\n\nexport interface GridEntity {\n  x: number;\n  y: number;\n  speed?: number; // Speed multiplier (default: 1.0)\n  [key: string]: any;\n}\n\nexport interface MovementInput {\n  up?: boolean;\n  down?: boolean;\n  left?: boolean;\n  right?: boolean;\n  [key: string]: any;\n}\n\nexport interface GridPosition {\n  gridX: number;\n  gridY: number;\n  isAligned: boolean;\n}\n\nexport class GridCollisionManager {\n  private config: Required<GridCollisionConfig>;\n  private debugGraphics?: any; // Phaser.GameObjects.Graphics\n  private adapter: PhaserAdapter;\n\n  constructor(adapter: PhaserAdapter, config: GridCollisionConfig) {\n    this.adapter = adapter;\n    this.config = {\n      baseSpeed: 150,\n      normalizeDiagonal: true,\n      debug: false,\n      debugColor: 0xff0000,\n      ...config\n    };\n\n    // Setup debug visualization\n    if (this.config.debug) {\n      this.debugGraphics = adapter.getScene().add.graphics();\n      this.renderDebugGrid();\n    }\n  }\n\n  /**\n   * Move an entity based on input\n   * Handles collision detection and smooth movement\n   *\n   * @param entity - Entity with x, y, and optional speed multiplier\n   * @param input - Input with up/down/left/right flags\n   * @param delta - Time delta in milliseconds\n   */\n  moveEntity(entity: GridEntity, input: MovementInput, delta: number): void {\n    const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);\n    const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);\n\n    if (dx === 0 && dy === 0) return;\n\n    // Calculate speed\n    const speedMultiplier = entity.speed ?? 1.0;\n    let speed = this.config.baseSpeed * speedMultiplier * (delta / 1000);\n\n    // Normalize diagonal movement\n    if (this.config.normalizeDiagonal && dx !== 0 && dy !== 0) {\n      const length = Math.sqrt(dx * dx + dy * dy);\n      speed /= length;\n    }\n\n    // Calculate next position\n    const nextX = entity.x + dx * speed;\n    const nextY = entity.y + dy * speed;\n\n    // Check collision at next position\n    const gridPos = this.worldToGrid(nextX, nextY);\n    const hasCollision = this.config.collisionCheck(gridPos.gridX, gridPos.gridY);\n\n    // Check bounds\n    const worldSize = {\n      width: this.config.gridWidth * this.config.tileSize,\n      height: this.config.gridHeight * this.config.tileSize\n    };\n    const outOfBounds =\n      nextX < 0 ||\n      nextX >= worldSize.width ||\n      nextY < 0 ||\n      nextY >= worldSize.height;\n\n    // Update position if valid\n    if (!hasCollision && !outOfBounds) {\n      entity.x = nextX;\n      entity.y = nextY;\n    }\n\n    // Update debug visualization\n    if (this.config.debug && this.debugGraphics) {\n      this.updateDebugVisualization(entity, hasCollision ? gridPos : null);\n    }\n  }\n\n  /**\n   * Convert world position to grid coordinates\n   *\n   * @param x - World X position in pixels\n   * @param y - World Y position in pixels\n   * @returns Grid coordinates and alignment status\n   */\n  worldToGrid(x: number, y: number): GridPosition {\n    const gridX = Math.floor(x / this.config.tileSize);\n    const gridY = Math.floor(y / this.config.tileSize);\n\n    // Check if position is aligned to grid (within threshold)\n    const threshold = this.config.tileSize * 0.1;\n    const offsetX = Math.abs(x - (gridX * this.config.tileSize + this.config.tileSize / 2));\n    const offsetY = Math.abs(y - (gridY * this.config.tileSize + this.config.tileSize / 2));\n    const isAligned = offsetX < threshold && offsetY < threshold;\n\n    return { gridX, gridY, isAligned };\n  }\n\n  /**\n   * Convert grid coordinates to world position (center of cell)\n   *\n   * @param gridX - Grid X coordinate\n   * @param gridY - Grid Y coordinate\n   * @returns World position in pixels (center of cell)\n   */\n  gridToWorld(gridX: number, gridY: number): { x: number; y: number } {\n    return {\n      x: gridX * this.config.tileSize + this.config.tileSize / 2,\n      y: gridY * this.config.tileSize + this.config.tileSize / 2\n    };\n  }\n\n  /**\n   * Snap an entity to the nearest grid cell center\n   *\n   * @param entity - Entity to snap\n   */\n  snapToGrid(entity: GridEntity): void {\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    const worldPos = this.gridToWorld(gridPos.gridX, gridPos.gridY);\n    entity.x = worldPos.x;\n    entity.y = worldPos.y;\n  }\n\n  /**\n   * Check if a grid cell is walkable (not blocked)\n   *\n   * @param gridX - Grid X coordinate\n   * @param gridY - Grid Y coordinate\n   * @returns True if cell is walkable\n   */\n  isWalkable(gridX: number, gridY: number): boolean {\n    // Check bounds\n    if (gridX < 0 || gridX >= this.config.gridWidth) return false;\n    if (gridY < 0 || gridY >= this.config.gridHeight) return false;\n\n    // Check collision\n    return !this.config.collisionCheck(gridX, gridY);\n  }\n\n  /**\n   * Get the current grid cell of an entity\n   *\n   * @param entity - Entity with x, y position\n   * @returns Grid position with alignment status\n   */\n  getEntityGridPosition(entity: GridEntity): GridPosition {\n    return this.worldToGrid(entity.x, entity.y);\n  }\n\n  /**\n   * Render debug grid overlay\n   */\n  private renderDebugGrid(): void {\n    if (!this.debugGraphics) return;\n\n    this.debugGraphics.clear();\n    this.debugGraphics.lineStyle(1, this.config.debugColor, 0.2);\n\n    // Draw grid lines\n    const worldWidth = this.config.gridWidth * this.config.tileSize;\n    const worldHeight = this.config.gridHeight * this.config.tileSize;\n\n    for (let i = 0; i <= this.config.gridWidth; i++) {\n      const x = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(x, 0, x, worldHeight);\n    }\n\n    for (let i = 0; i <= this.config.gridHeight; i++) {\n      const y = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(0, y, worldWidth, y);\n    }\n  }\n\n  /**\n   * Update debug visualization\n   */\n  private updateDebugVisualization(entity: GridEntity, blockedCell: GridPosition | null): void {\n    if (!this.debugGraphics) return;\n\n    this.renderDebugGrid();\n\n    // Show entity position\n    this.debugGraphics.fillStyle(0x00ff00, 0.8);\n    this.debugGraphics.fillCircle(entity.x, entity.y, 4);\n\n    // Highlight current cell\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    const worldPos = this.gridToWorld(gridPos.gridX, gridPos.gridY);\n    this.debugGraphics.lineStyle(2, 0x00ff00, 0.6);\n    this.debugGraphics.strokeRect(\n      worldPos.x - this.config.tileSize / 2,\n      worldPos.y - this.config.tileSize / 2,\n      this.config.tileSize,\n      this.config.tileSize\n    );\n\n    // Highlight blocked cell if collision detected\n    if (blockedCell) {\n      const blockedWorld = this.gridToWorld(blockedCell.gridX, blockedCell.gridY);\n      this.debugGraphics.fillStyle(this.config.debugColor, 0.4);\n      this.debugGraphics.fillRect(\n        blockedWorld.x - this.config.tileSize / 2,\n        blockedWorld.y - this.config.tileSize / 2,\n        this.config.tileSize,\n        this.config.tileSize\n      );\n    }\n  }\n\n  /**\n   * Cleanup debug graphics\n   */\n  destroy(): void {\n    if (this.debugGraphics) {\n      this.debugGraphics.destroy();\n      this.debugGraphics = undefined;\n    }\n  }\n}\n\n// Maintain backward compatibility\n/** @deprecated Use GridCollisionConfig instead */\nexport type GridMovementConfig = GridCollisionConfig;\n/** @deprecated Use GridCollisionManager instead */\nexport const GridMovementManager = GridCollisionManager;\n\n/**\n * Factory function for creating a GridCollisionManager\n * Called from PhaserAdapter.createGridCollisionManager()\n */\nexport function createGridCollisionManager(\n  adapter: PhaserAdapter,\n  config: GridCollisionConfig\n): GridCollisionManager {\n  return new GridCollisionManager(adapter, config);\n}\n\n// Backward compatibility\n/** @deprecated Use createGridCollisionManager instead */\nexport const createGridMovementManager = createGridCollisionManager;\n",
  "/node_modules/@martini-kit/phaser/helpers/GridLockedMovementManager.ts": "/**\n * GridLockedMovementManager - True grid-locked movement for Bomberman-style games\n *\n * This helper provides CELL-TO-CELL committed movement where:\n * - Entities align to grid cell centers\n * - Movement commits to one full cell at a time\n * - Direction can only change when aligned to a cell\n * - Smooth animation interpolates between cells\n *\n * ⚠️ NOTE: This is different from GridCollisionManager:\n * - GridLockedMovementManager: Cell-locked movement (Bomberman classic, Pacman, Sokoban)\n * - GridCollisionManager: Smooth movement with grid collision (Zelda, modern Bomberman)\n *\n * ✅ CORRECT USAGE:\n * ```ts\n * // In scene.create()\n * this.gridLocked = this.adapter.createGridLockedMovementManager({\n *   tileSize: 52,\n *   gridWidth: 13,\n *   gridHeight: 13,\n *   collisionCheck: createMultiCollisionCheck(\n *     { name: 'blocks', fn: (x, y) => hasBlock(x, y) },\n *     { name: 'bombs', fn: (x, y) => hasBomb(x, y) }\n *   )\n * });\n *\n * // In tick action:\n * tick: createTickAction((state, delta) => {\n *   for (const [playerId, player] of Object.entries(state.players)) {\n *     const input = state.inputs[playerId];\n *     if (!input) continue;\n *     this.gridLocked.moveEntity(player, input, delta);\n *   }\n * })\n * ```\n *\n * @see GridCollisionManager for smooth movement with grid-aligned collision\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface GridLockedMovementConfig {\n  /**\n   * Size of each grid cell in pixels\n   */\n  tileSize: number;\n\n  /**\n   * Width of the grid in cells\n   */\n  gridWidth: number;\n\n  /**\n   * Height of the grid in cells\n   */\n  gridHeight: number;\n\n  /**\n   * Collision check function\n   * Returns true if there's a blocking obstacle at (gridX, gridY)\n   */\n  collisionCheck: (gridX: number, gridY: number) => boolean;\n\n  /**\n   * Base movement speed in cells per second (default: 3.0)\n   * Higher = faster movement between cells\n   */\n  baseSpeed?: number;\n\n  /**\n   * Enable debug visualization (default: false)\n   * Shows grid lines, current cell, target cell, progress\n   */\n  debug?: boolean;\n\n  /**\n   * Debug visualization color (default: 0xff0000)\n   */\n  debugColor?: number;\n}\n\nexport interface GridLockedEntity {\n  /** Current grid X position (cell coordinate) */\n  currentCell?: { x: number; y: number };\n  \n  /** Target grid position when moving */\n  targetCell?: { x: number; y: number } | null;\n  \n  /** Movement progress 0-1 between current and target */\n  moveProgress?: number;\n  \n  /** Actual world position (pixels) for rendering */\n  x: number;\n  y: number;\n  \n  /** Speed multiplier (default: 1.0) */\n  speed?: number;\n  \n  [key: string]: any;\n}\n\nexport interface MovementInput {\n  up?: boolean;\n  down?: boolean;\n  left?: boolean;\n  right?: boolean;\n  [key: string]: any;\n}\n\nexport class GridLockedMovementManager {\n  private config: Required<GridLockedMovementConfig>;\n  private debugGraphics?: any; // Phaser.GameObjects.Graphics\n  private adapter: PhaserAdapter;\n\n  constructor(adapter: PhaserAdapter, config: GridLockedMovementConfig) {\n    this.adapter = adapter;\n    this.config = {\n      baseSpeed: 3.0,\n      debug: false,\n      debugColor: 0xff0000,\n      ...config\n    };\n\n    // Setup debug visualization\n    if (this.config.debug) {\n      this.debugGraphics = adapter.getScene().add.graphics();\n      this.renderDebugGrid();\n    }\n  }\n\n  /**\n   * Move an entity with grid-locked behavior\n   * \n   * The entity will:\n   * 1. Continue moving to targetCell if already in motion\n   * 2. Accept new direction input only when aligned to a cell\n   * 3. Smoothly interpolate position between cells\n   *\n   * @param entity - Entity with grid position state\n   * @param input - Input with up/down/left/right flags\n   * @param delta - Time delta in milliseconds\n   */\n  moveEntity(entity: GridLockedEntity, input: MovementInput, delta: number): void {\n    // Initialize entity grid state if needed\n    if (!entity.currentCell) {\n      const gridPos = this.worldToGrid(entity.x, entity.y);\n      entity.currentCell = { x: gridPos.gridX, y: gridPos.gridY };\n      entity.targetCell = null;\n      entity.moveProgress = 0;\n    }\n\n    const speedMultiplier = entity.speed ?? 1.0;\n    const cellsPerSecond = this.config.baseSpeed * speedMultiplier;\n    const progressDelta = (cellsPerSecond * delta) / 1000;\n\n    // If currently moving, continue to target\n    if (entity.targetCell && entity.moveProgress !== undefined) {\n      entity.moveProgress += progressDelta;\n\n      if (entity.moveProgress >= 1.0) {\n        // Reached target cell - snap to center\n        entity.currentCell = { ...entity.targetCell };\n        entity.targetCell = null;\n        entity.moveProgress = 0;\n\n        // Update world position to exact cell center\n        const worldPos = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n        entity.x = worldPos.x;\n        entity.y = worldPos.y;\n      } else {\n        // Interpolate position\n        const currentWorld = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n        const targetWorld = this.gridToWorld(entity.targetCell.x, entity.targetCell.y);\n        \n        entity.x = this.lerp(currentWorld.x, targetWorld.x, entity.moveProgress);\n        entity.y = this.lerp(currentWorld.y, targetWorld.y, entity.moveProgress);\n      }\n    } else {\n      // Aligned to cell - can start new move\n      const direction = this.getDirection(input);\n      \n      if (direction.dx !== 0 || direction.dy !== 0) {\n        const nextCell = {\n          x: entity.currentCell.x + direction.dx,\n          y: entity.currentCell.y + direction.dy\n        };\n\n        // Check if next cell is walkable\n        if (this.isWalkable(nextCell.x, nextCell.y)) {\n          entity.targetCell = nextCell;\n          entity.moveProgress = 0;\n        }\n      }\n    }\n\n    // Update debug visualization\n    if (this.config.debug && this.debugGraphics) {\n      this.updateDebugVisualization(entity);\n    }\n  }\n\n  /**\n   * Snap entity to nearest grid cell center\n   */\n  snapToGrid(entity: GridLockedEntity): void {\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    const worldPos = this.gridToWorld(gridPos.gridX, gridPos.gridY);\n    \n    entity.x = worldPos.x;\n    entity.y = worldPos.y;\n    entity.currentCell = { x: gridPos.gridX, y: gridPos.gridY };\n    entity.targetCell = null;\n    entity.moveProgress = 0;\n  }\n\n  /**\n   * Check if entity is aligned to a grid cell\n   */\n  isAligned(entity: GridLockedEntity): boolean {\n    return !entity.targetCell && entity.moveProgress === 0;\n  }\n\n  /**\n   * Get entity's current grid position\n   */\n  getGridPosition(entity: GridLockedEntity): { x: number; y: number } {\n    if (entity.currentCell) {\n      return { ...entity.currentCell };\n    }\n    const gridPos = this.worldToGrid(entity.x, entity.y);\n    return { x: gridPos.gridX, y: gridPos.gridY };\n  }\n\n  /**\n   * Convert world coordinates to grid coordinates\n   */\n  worldToGrid(x: number, y: number): { gridX: number; gridY: number; isAligned: boolean } {\n    const gridX = Math.floor(x / this.config.tileSize);\n    const gridY = Math.floor(y / this.config.tileSize);\n\n    // Check if position is aligned to cell center\n    const centerX = gridX * this.config.tileSize + this.config.tileSize / 2;\n    const centerY = gridY * this.config.tileSize + this.config.tileSize / 2;\n    const threshold = this.config.tileSize * 0.1;\n    const isAligned = Math.abs(x - centerX) < threshold && Math.abs(y - centerY) < threshold;\n\n    return { gridX, gridY, isAligned };\n  }\n\n  /**\n   * Convert grid coordinates to world position (center of cell)\n   */\n  gridToWorld(gridX: number, gridY: number): { x: number; y: number } {\n    return {\n      x: gridX * this.config.tileSize + this.config.tileSize / 2,\n      y: gridY * this.config.tileSize + this.config.tileSize / 2\n    };\n  }\n\n  /**\n   * Check if a grid cell is walkable\n   */\n  private isWalkable(gridX: number, gridY: number): boolean {\n    // Check bounds\n    if (gridX < 0 || gridX >= this.config.gridWidth) return false;\n    if (gridY < 0 || gridY >= this.config.gridHeight) return false;\n\n    // Check collision\n    return !this.config.collisionCheck(gridX, gridY);\n  }\n\n  /**\n   * Extract direction from input\n   */\n  private getDirection(input: MovementInput): { dx: number; dy: number } {\n    const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);\n    const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);\n\n    // Grid-locked movement doesn't allow diagonal - pick strongest direction\n    if (dx !== 0 && dy !== 0) {\n      // Prioritize the most recent input (could be enhanced with input buffering)\n      // For now, prioritize horizontal\n      return { dx, dy: 0 };\n    }\n\n    return { dx, dy };\n  }\n\n  /**\n   * Linear interpolation\n   */\n  private lerp(start: number, end: number, t: number): number {\n    return start + (end - start) * t;\n  }\n\n  /**\n   * Render debug grid overlay\n   */\n  private renderDebugGrid(): void {\n    if (!this.debugGraphics) return;\n\n    this.debugGraphics.clear();\n    this.debugGraphics.lineStyle(1, this.config.debugColor, 0.3);\n\n    // Draw grid lines\n    const worldWidth = this.config.gridWidth * this.config.tileSize;\n    const worldHeight = this.config.gridHeight * this.config.tileSize;\n\n    for (let i = 0; i <= this.config.gridWidth; i++) {\n      const x = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(x, 0, x, worldHeight);\n    }\n\n    for (let i = 0; i <= this.config.gridHeight; i++) {\n      const y = i * this.config.tileSize;\n      this.debugGraphics.lineBetween(0, y, worldWidth, y);\n    }\n  }\n\n  /**\n   * Update debug visualization for an entity\n   */\n  private updateDebugVisualization(entity: GridLockedEntity): void {\n    if (!this.debugGraphics) return;\n\n    this.renderDebugGrid();\n\n    // Highlight current cell\n    if (entity.currentCell) {\n      const worldPos = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n      this.debugGraphics.fillStyle(this.config.debugColor, 0.2);\n      this.debugGraphics.fillRect(\n        worldPos.x - this.config.tileSize / 2,\n        worldPos.y - this.config.tileSize / 2,\n        this.config.tileSize,\n        this.config.tileSize\n      );\n    }\n\n    // Highlight target cell\n    if (entity.targetCell) {\n      const worldPos = this.gridToWorld(entity.targetCell.x, entity.targetCell.y);\n      this.debugGraphics.fillStyle(this.config.debugColor, 0.4);\n      this.debugGraphics.fillRect(\n        worldPos.x - this.config.tileSize / 2,\n        worldPos.y - this.config.tileSize / 2,\n        this.config.tileSize,\n        this.config.tileSize\n      );\n\n      // Draw arrow from current to target\n      if (entity.currentCell) {\n        const currentWorld = this.gridToWorld(entity.currentCell.x, entity.currentCell.y);\n        const targetWorld = this.gridToWorld(entity.targetCell.x, entity.targetCell.y);\n        this.debugGraphics.lineStyle(2, this.config.debugColor, 0.8);\n        this.debugGraphics.lineBetween(\n          currentWorld.x,\n          currentWorld.y,\n          targetWorld.x,\n          targetWorld.y\n        );\n      }\n    }\n\n    // Show entity position\n    this.debugGraphics.fillStyle(0xffffff, 1.0);\n    this.debugGraphics.fillCircle(entity.x, entity.y, 3);\n  }\n\n  /**\n   * Cleanup debug graphics\n   */\n  destroy(): void {\n    if (this.debugGraphics) {\n      this.debugGraphics.destroy();\n      this.debugGraphics = undefined;\n    }\n  }\n}\n\n/**\n * Factory function for creating a GridLockedMovementManager\n * Called from PhaserAdapter.createGridLockedMovementManager()\n */\nexport function createGridLockedMovementManager(\n  adapter: PhaserAdapter,\n  config: GridLockedMovementConfig\n): GridLockedMovementManager {\n  return new GridLockedMovementManager(adapter, config);\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/HUDHelper.ts": "/**\n * HUD Helper - Unified player HUD/UI for multiplayer games\n *\n * Eliminates the manual HUD boilerplate by automatically creating and managing\n * title, role, and control hint text based on the current player state.\n *\n * @example\n * ```ts\n * import { createPlayerHUD } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.hud = createPlayerHUD(this.adapter, this, {\n *   title: 'Fire & Ice - Cooperative Platformer',\n *\n *   roleText: (myPlayer) => {\n *     if (!myPlayer) return 'Spectator';\n *     return myPlayer.role === 'fire' ? 'Fire Player' : 'Ice Player';\n *   },\n *\n *   controlHints: (myPlayer) => {\n *     if (!myPlayer) return '';\n *     return 'Arrow Keys + SPACE to Jump';\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface HUDLayout {\n\t/** Position for title text */\n\ttitle?: { x: number; y: number };\n\t/** Position for role text */\n\trole?: { x: number; y: number };\n\t/** Position for controls text */\n\tcontrols?: { x: number; y: number };\n}\n\nexport interface HUDTextStyle {\n\tfontSize?: string;\n\tcolor?: string;\n\tfontStyle?: string;\n\tbackgroundColor?: string;\n\tpadding?: { x: number; y: number };\n}\n\nexport interface PlayerHUDConfig<TPlayer = any, TState = any> {\n\t/** Title text (static) */\n\ttitle?: string;\n\t/** Title text style */\n\ttitleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate role text from player data and optionally game state\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @param state - Full game state (optional, for turn-based games)\n\t * @returns Text to display\n\t *\n\t * @example\n\t * // Simple usage (action games)\n\t * roleText: (myPlayer) => {\n\t *   if (!myPlayer) return 'Spectator';\n\t *   return `Player ${myPlayer.id}`;\n\t * }\n\t *\n\t * @example\n\t * // With state (turn-based games)\n\t * roleText: (myPlayer, state) => {\n\t *   if (!myPlayer) return 'Spectator';\n\t *   if (state?.gameOver) return 'Game Over!';\n\t *   return state?.currentTurn === myPlayer.id ? 'Your Turn' : 'Waiting...';\n\t * }\n\t */\n\troleText?: (myPlayer: TPlayer | undefined, state?: TState) => string;\n\t/** Role text style */\n\troleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate control hints from player data and optionally game state\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @param state - Full game state (optional)\n\t * @returns Text to display\n\t */\n\tcontrolHints?: (myPlayer: TPlayer | undefined, state?: TState) => string;\n\t/** Control hints text style */\n\tcontrolsStyle?: HUDTextStyle;\n\n\t/** Custom layout positions */\n\tlayout?: HUDLayout;\n\n\t/** Key in state where players are stored (default: 'players') */\n\tplayersKey?: string;\n}\n\nexport interface PlayerHUD {\n\t/** Update HUD (automatically called when player changes) */\n\tupdate: () => void;\n\t/** Destroy HUD elements */\n\tdestroy: () => void;\n\t/** Get title text object */\n\tgetTitleText: () => Phaser.GameObjects.Text | null;\n\t/** Get role text object */\n\tgetRoleText: () => Phaser.GameObjects.Text | null;\n\t/** Get controls text object */\n\tgetControlsText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a player HUD with automatic role/control updates\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - HUD configuration\n * @returns PlayerHUD instance\n */\nexport function createPlayerHUD<TPlayer = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: PlayerHUDConfig<TPlayer>\n): PlayerHUD {\n\tconst playersKey = config.playersKey || 'players';\n\n\t// Default layout\n\tconst layout = {\n\t\ttitle: config.layout?.title || { x: 400, y: 20 },\n\t\trole: config.layout?.role || { x: 400, y: 50 },\n\t\tcontrols: config.layout?.controls || { x: 400, y: 75 }\n\t};\n\n\t// Default styles\n\tconst titleStyle = {\n\t\tfontSize: config.titleStyle?.fontSize || '24px',\n\t\tcolor: config.titleStyle?.color || '#000',\n\t\tfontStyle: config.titleStyle?.fontStyle || 'bold',\n\t\tbackgroundColor: config.titleStyle?.backgroundColor,\n\t\tpadding: config.titleStyle?.padding\n\t};\n\n\tconst roleStyle = {\n\t\tfontSize: config.roleStyle?.fontSize || '16px',\n\t\tcolor: config.roleStyle?.color || '#000',\n\t\tfontStyle: config.roleStyle?.fontStyle,\n\t\tbackgroundColor: config.roleStyle?.backgroundColor,\n\t\tpadding: config.roleStyle?.padding\n\t};\n\n\tconst controlsStyle = {\n\t\tfontSize: config.controlsStyle?.fontSize || '14px',\n\t\tcolor: config.controlsStyle?.color || '#333',\n\t\tfontStyle: config.controlsStyle?.fontStyle,\n\t\tbackgroundColor: config.controlsStyle?.backgroundColor,\n\t\tpadding: config.controlsStyle?.padding\n\t};\n\n\t// Create text objects\n\tlet titleText: Phaser.GameObjects.Text | null = null;\n\tlet roleText: Phaser.GameObjects.Text | null = null;\n\tlet controlsText: Phaser.GameObjects.Text | null = null;\n\n\t// Create title (static)\n\tif (config.title) {\n\t\ttitleText = scene.add.text(layout.title.x, layout.title.y, config.title, titleStyle);\n\t\ttitleText.setOrigin(0.5);\n\t}\n\n\t// Create role text (dynamic)\n\tif (config.roleText) {\n\t\troleText = scene.add.text(layout.role.x, layout.role.y, 'Loading...', roleStyle);\n\t\troleText.setOrigin(0.5);\n\t}\n\n\t// Create controls text (dynamic)\n\tif (config.controlHints) {\n\t\tcontrolsText = scene.add.text(layout.controls.x, layout.controls.y, '', controlsStyle);\n\t\tcontrolsText.setOrigin(0.5);\n\t}\n\n\t// Update function\n\tconst update = () => {\n\t\tconst state = adapter.getState();\n\t\tconst myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n\t\tif (roleText && config.roleText) {\n\t\t\troleText.setText(config.roleText(myPlayer, state));\n\t\t}\n\n\t\tif (controlsText && config.controlHints) {\n\t\t\tcontrolsText.setText(config.controlHints(myPlayer, state));\n\t\t}\n\t};\n\n\t// Subscribe to state changes to reactively update HUD\n\t// Uses onChange instead of watchMyPlayer to get full state access\n\tconst unsubscribers: Array<() => void> = [];\n\n\t// Track last values to avoid unnecessary updates\n\tlet lastRoleText: string | undefined;\n\tlet lastControlsText: string | undefined;\n\n\t// Watch roleText changes (reactive to both player and state changes)\n\tif (roleText && config.roleText) {\n\t\tconst unsubscribe = adapter.onChange((state: any) => {\n\t\t\tconst players = state?.[playersKey];\n\t\t\tconst myPlayer = players ? players[adapter.getMyPlayerId()] : undefined;\n\t\t\tconst text = config.roleText!(myPlayer, state);\n\n\t\t\t// Only update if text changed\n\t\t\tif (text !== lastRoleText) {\n\t\t\t\tlastRoleText = text;\n\t\t\t\troleText.setText(text);\n\t\t\t}\n\t\t});\n\t\tunsubscribers.push(unsubscribe);\n\n\t\t// Initial update\n\t\tconst initialState = adapter.getState();\n\t\tconst initialPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\t\tlastRoleText = config.roleText(initialPlayer, initialState);\n\t\troleText.setText(lastRoleText);\n\t}\n\n\t// Watch controlHints changes (reactive to both player and state changes)\n\tif (controlsText && config.controlHints) {\n\t\tconst unsubscribe = adapter.onChange((state: any) => {\n\t\t\tconst players = state?.[playersKey];\n\t\t\tconst myPlayer = players ? players[adapter.getMyPlayerId()] : undefined;\n\t\t\tconst text = config.controlHints!(myPlayer, state);\n\n\t\t\t// Only update if text changed\n\t\t\tif (text !== lastControlsText) {\n\t\t\t\tlastControlsText = text;\n\t\t\t\tcontrolsText.setText(text);\n\t\t\t}\n\t\t});\n\t\tunsubscribers.push(unsubscribe);\n\n\t\t// Initial update\n\t\tconst initialState = adapter.getState();\n\t\tconst initialPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\t\tlastControlsText = config.controlHints(initialPlayer, initialState);\n\t\tcontrolsText.setText(lastControlsText);\n\t}\n\n\t// Return HUD interface\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\t// Unsubscribe from all watchers\n\t\t\tunsubscribers.forEach((unsub) => unsub());\n\t\t\ttitleText?.destroy();\n\t\t\troleText?.destroy();\n\t\t\tcontrolsText?.destroy();\n\t\t},\n\t\tgetTitleText: () => titleText,\n\t\tgetRoleText: () => roleText,\n\t\tgetControlsText: () => controlsText\n\t};\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/HealthBarManager.ts": "/**\n * HealthBarManager - Auto-synced health bars for sprites\n *\n * Eliminates manual health bar creation, positioning, scaling, and color updates.\n * One-liner attachment like directional indicators, auto-updates from state.\n *\n * Usage:\n * ```ts\n * const healthBars = adapter.createHealthBarManager({\n *   spriteManager: this.spriteManager,\n *   healthKey: 'health',\n *   maxHealth: 100,\n *   offset: { x: 0, y: -30 },\n *   width: 50,\n *   height: 5\n * });\n *\n * // That's it! Health bars auto-create, auto-position, auto-scale, auto-color!\n * // Just call in update():\n * healthBars.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\nimport type Phaser from 'phaser';\n\nexport interface HealthBarConfig {\n  /**\n   * SpriteManager to attach health bars to\n   */\n  spriteManager: SpriteManager;\n\n  /**\n   * Path to health value in state (e.g., 'health', 'hp', 'lives')\n   */\n  healthKey: string;\n\n  /**\n   * Maximum health value for scaling\n   */\n  maxHealth: number;\n\n  /**\n   * Offset from sprite center\n   */\n  offset?: { x?: number; y?: number };\n\n  /**\n   * Health bar dimensions\n   */\n  width?: number;\n  height?: number;\n\n  /**\n   * Color thresholds for health bar\n   * Default: green > 50%, yellow > 25%, red <= 25%\n   */\n  colorThresholds?: {\n    high?: { value: number; color: number };\n    medium?: { value: number; color: number };\n    low?: { value: number; color: number };\n  };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Show background bar (darker shade)\n   */\n  showBackground?: boolean;\n\n  /**\n   * Background bar color\n   */\n  backgroundColor?: number;\n}\n\nexport class HealthBarManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: HealthBarConfig;\n  private healthBars = new Map<string, {\n    bar: Phaser.GameObjects.Rectangle;\n    background?: Phaser.GameObjects.Rectangle;\n  }>();\n\n  constructor(adapter: PhaserAdapter, config: HealthBarConfig) {\n    this.adapter = adapter;\n    this.scene = adapter.getScene();\n    this.config = {\n      offset: { x: 0, y: -30 },\n      width: 50,\n      height: 5,\n      colorThresholds: {\n        high: { value: 50, color: 0x48bb78 },   // Green\n        medium: { value: 25, color: 0xeab308 }, // Yellow\n        low: { value: 0, color: 0xef4444 }      // Red\n      },\n      depth: 100,\n      showBackground: true,\n      backgroundColor: 0x333333,\n      ...config\n    };\n\n    // Listen for sprite additions via SpriteManager\n    // We'll create health bars in update() when we detect new sprites\n  }\n\n  /**\n   * Update all health bars\n   * Call this in your scene's update() loop\n   */\n  update(): void {\n    const state = this.adapter.getState();\n    const sprites = this.config.spriteManager.getAll();\n\n    // Create health bars for new sprites\n    for (const [key, sprite] of sprites) {\n      if (!this.healthBars.has(key)) {\n        this.createHealthBar(key, sprite);\n      }\n    }\n\n    // Update existing health bars\n    for (const [key, healthBarObj] of this.healthBars.entries()) {\n      const sprite = sprites.get(key);\n      if (!sprite) {\n        // Sprite removed, cleanup\n        this.removeHealthBar(key);\n        continue;\n      }\n\n      // Extract player/entity ID from sprite key\n      const entityId = this.extractEntityId(key);\n      const entityState = this.getEntityState(state, entityId);\n\n      if (!entityState) {\n        continue;\n      }\n\n      // Get health value\n      const health = entityState[this.config.healthKey];\n      if (health === undefined) {\n        continue;\n      }\n\n      // Update position\n      const offsetX = this.config.offset?.x ?? 0;\n      const offsetY = this.config.offset?.y ?? -30;\n      healthBarObj.bar.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n\n      if (healthBarObj.background) {\n        healthBarObj.background.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n      }\n\n      // Update scale\n      const healthPercent = health / this.config.maxHealth;\n      healthBarObj.bar.setScale(Math.max(0, healthPercent), 1);\n\n      // Update color based on health\n      const color = this.getColorForHealth(healthPercent * 100);\n      healthBarObj.bar.setFillStyle(color);\n    }\n  }\n\n  /**\n   * Manually create a health bar for a sprite\n   */\n  private createHealthBar(key: string, sprite: any): void {\n    const width = this.config.width ?? 50;\n    const height = this.config.height ?? 5;\n    const offsetX = this.config.offset?.x ?? 0;\n    const offsetY = this.config.offset?.y ?? -30;\n\n    // Create background bar (if enabled)\n    let background: Phaser.GameObjects.Rectangle | undefined;\n    if (this.config.showBackground) {\n      background = this.scene.add.rectangle(\n        sprite.x + offsetX,\n        sprite.y + offsetY,\n        width,\n        height,\n        this.config.backgroundColor\n      );\n      background?.setDepth(this.config.depth ?? 100);\n    }\n\n    // Create foreground bar\n    const bar = this.scene.add.rectangle(\n      sprite.x + offsetX,\n      sprite.y + offsetY,\n      width,\n      height,\n      this.config.colorThresholds?.high?.color ?? 0x48bb78\n    );\n    bar.setDepth((this.config.depth ?? 100) + 1);\n    bar.setOrigin(0, 0.5); // Left-aligned for scale effect\n\n    // Adjust background origin to match\n    background?.setOrigin(0, 0.5);\n\n    this.healthBars.set(key, { bar, background });\n  }\n\n  /**\n   * Remove a health bar\n   */\n  private removeHealthBar(key: string): void {\n    const healthBarObj = this.healthBars.get(key);\n    if (healthBarObj) {\n      healthBarObj.bar.destroy();\n      healthBarObj.background?.destroy();\n      this.healthBars.delete(key);\n    }\n  }\n\n  /**\n   * Extract entity ID from sprite key\n   * Assumes format like \"player-abc123\" or \"enemy-xyz789\"\n   */\n  private extractEntityId(key: string): string {\n    const parts = key.split('-');\n    return parts.length > 1 ? parts.slice(1).join('-') : key;\n  }\n\n  /**\n   * Get entity state from game state\n   * Tries common state keys: players, enemies, entities\n   */\n  private getEntityState(state: any, entityId: string): any {\n    if (state.players?.[entityId]) {\n      return state.players[entityId];\n    }\n    if (state.enemies?.[entityId]) {\n      return state.enemies[entityId];\n    }\n    if (state.entities?.[entityId]) {\n      return state.entities[entityId];\n    }\n    return null;\n  }\n\n  /**\n   * Get color based on health percentage\n   */\n  private getColorForHealth(healthPercent: number): number {\n    const thresholds = this.config.colorThresholds!;\n\n    if (healthPercent > (thresholds.high?.value ?? 50)) {\n      return thresholds.high?.color ?? 0x48bb78;\n    } else if (healthPercent > (thresholds.medium?.value ?? 25)) {\n      return thresholds.medium?.color ?? 0xeab308;\n    } else {\n      return thresholds.low?.color ?? 0xef4444;\n    }\n  }\n\n  /**\n   * Cleanup all health bars\n   */\n  destroy(): void {\n    for (const key of this.healthBars.keys()) {\n      this.removeHealthBar(key);\n    }\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/InputManager.ts": "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini-kit/core';\nimport { getProfile, applyProfileOptions, mergeProfiles as mergeProfileBindings, type ProfileOptions } from './InputProfiles.js';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport interface AggregatedBinding {\n  keyMap: Record<string, string>;\n  state: Record<string, any>;\n  mode: 'continuous' | 'oneshot';\n  targetId?: string;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n  private aggregatedBindings = new Map<string, AggregatedBinding>(); // NEW: Track aggregated state\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n    }\n  }\n\n  /**\n   * Bind multiple keys that aggregate into a single input state\n   * Perfect for platformers, twin-stick shooters, fighting games\n   *\n   * Key codes: Use standard DOM key names (ArrowLeft, ArrowRight, ArrowUp, ArrowDown, Space).\n   * Letter keys (A-Z) are automatically uppercased. Arrow keys and Space are automatically\n   * converted to Phaser's internal format (LEFT, RIGHT, UP, DOWN, SPACE).\n   *\n   * @example\n   * ```ts\n   * // Platformer controls - use ArrowLeft/ArrowRight/Space\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'ArrowLeft',\n   *   right: 'ArrowRight',\n   *   up: 'Space'\n   * });\n   * // Automatically tracks: { left: true/false, right: true/false, up: true/false }\n   *\n   * // Top-down movement - letter keys work as-is\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'A',\n   *   right: 'D',\n   *   up: 'W',\n   *   down: 'S'\n   * });\n   * ```\n   */\n  bindKeysAggregated(\n    action: string,\n    keyMap: Record<string, string>,\n    options?: {\n      initialState?: Record<string, any>;\n      mode?: 'continuous' | 'oneshot';\n      targetId?: string;\n    }\n  ): void {\n    // Build initial state (default to false for each field)\n    const state = options?.initialState ||\n      Object.fromEntries(\n        Object.keys(keyMap).map(field => [field, false])\n      );\n\n    this.aggregatedBindings.set(action, {\n      keyMap,\n      state,\n      mode: options?.mode || 'continuous',\n      targetId: options?.targetId\n    });\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n\n    // Handle aggregated bindings (multi-key state tracking)\n    for (const [action, binding] of this.aggregatedBindings.entries()) {\n      let stateChanged = false;\n\n      // Check each key in the map and update state\n      for (const [field, keyCode] of Object.entries(binding.keyMap)) {\n        // IMPORTANT: Convert user-friendly key names to Phaser's internal key codes\n        // Phaser uses uppercase constants (e.g., 'LEFT' not 'ArrowLeft')\n        // This mapping allows users to use standard DOM key names while Phaser expects its own format\n        // See: https://photonstorm.github.io/phaser3-docs/Phaser.Input.Keyboard.KeyCodes.html\n        let phaserKeyCode = keyCode;\n        const keyCodeMap: Record<string, string> = {\n          'ArrowLeft': 'LEFT',\n          'ArrowRight': 'RIGHT',\n          'ArrowUp': 'UP',\n          'ArrowDown': 'DOWN',\n          'Space': 'SPACE'\n        };\n\n        if (keyCodeMap[keyCode]) {\n          phaserKeyCode = keyCodeMap[keyCode];\n        }\n\n        const keyObj = this.scene.input.keyboard?.addKey(phaserKeyCode, false);\n        if (!keyObj) {\n          console.warn(`[InputManager] Failed to create key object for: ${keyCode} (mapped to ${phaserKeyCode})`);\n          continue;\n        }\n\n        const pressed = keyObj.isDown;\n\n        // Update state if changed\n        if (binding.state[field] !== pressed) {\n          binding.state[field] = pressed;\n          stateChanged = true;\n        }\n      }\n\n      // Submit aggregated state ONLY when changed (10x devtools improvement!)\n      // This prevents 60 actions/second when idle\n      if (stateChanged) {\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Use a pre-defined input profile\n   *\n   * @param profileName - Name of the profile ('platformer', 'topDown', 'shooter', etc.)\n   * @param options - Optional customization\n   *\n   * @example\n   * ```ts\n   * // Simple usage\n   * inputManager.useProfile('platformer');\n   *\n   * // With player 2 (uses WASD instead of arrows)\n   * inputManager.useProfile('platformer', { player: 2 });\n   *\n   * // With custom action name\n   * inputManager.useProfile('platformer', { action: 'move' });\n   *\n   * // With key overrides\n   * inputManager.useProfile('platformer', {\n   *   overrides: {\n   *     'Space': { action: 'jump', mode: 'oneshot' }\n   *   }\n   * });\n   * ```\n   */\n  useProfile(profileName: string, options?: ProfileOptions): void {\n    const profile = getProfile(profileName);\n\n    if (!profile) {\n      console.warn(`[InputManager] Profile \"${profileName}\" not found. Available profiles:`, [\n        'platformer', 'platformerWASD', 'topDown', 'topDownWASD', 'shooter', 'twinStick'\n      ]);\n      return;\n    }\n\n    const config = applyProfileOptions(profile, options);\n\n    if (config.type === 'aggregated') {\n      // Use aggregated binding for multi-key state tracking\n      this.bindKeysAggregated(config.action, config.keys, {\n        mode: config.mode\n      });\n    } else {\n      // Use per-key binding for separate actions\n      this.bindKeys(config.bindings);\n    }\n  }\n\n  /**\n   * Merge multiple profiles into one\n   *\n   * @param profileNames - Array of profile names\n   *\n   * @example\n   * ```ts\n   * // Combine platformer movement with shooter actions\n   * inputManager.mergeProfiles(['platformer', 'shooter']);\n   * ```\n   */\n  mergeProfiles(profileNames: string[]): void {\n    const merged = mergeProfileBindings(profileNames);\n    this.bindKeys(merged);\n  }\n\n  /**\n   * Bind edge-triggered actions (fire once on press, not every frame)\n   * Perfect for shoot, jump, interact, etc.\n   *\n   * @example\n   * ```ts\n   * // Shoot on space press\n   * inputManager.bindEdgeTrigger('Space', 'shoot');\n   *\n   * // Jump on up arrow press\n   * inputManager.bindEdgeTrigger('ArrowUp', 'jump');\n   *\n   * // Multiple edge triggers\n   * inputManager.bindEdgeTriggers({\n   *   'Space': 'shoot',\n   *   'E': 'interact',\n   *   'R': 'reload'\n   * });\n   * ```\n   */\n  bindEdgeTrigger(key: string, action: string, input?: any): void {\n    this.keyBindings.set(key.toUpperCase(), {\n      action,\n      input,\n      mode: 'oneshot'\n    });\n  }\n\n  /**\n   * Bind multiple edge-triggered actions at once\n   */\n  bindEdgeTriggers(bindings: Record<string, string | { action: string; input?: any }>): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      if (typeof binding === 'string') {\n        this.bindEdgeTrigger(key, binding);\n      } else {\n        this.bindEdgeTrigger(key, binding.action, binding.input);\n      }\n    }\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * **NEW: Bridge input to actions automatically**\n   *\n   * Eliminates manual edge detection and action submission boilerplate.\n   * Integrates with input profiles for complete automation.\n   *\n   * @example\n   * ```ts\n   * // Simple: Use existing profile bindings\n   * inputManager.useProfile('topDown');\n   * inputManager.bridgeToActions({\n   *   move: 'continuous',  // submits every frame from profile\n   *   shoot: 'edge'        // submits once on press from profile\n   * });\n   *\n   * // Advanced: Custom key mapping\n   * inputManager.bridgeToActions({\n   *   move: { type: 'continuous', keys: { left: 'A', right: 'D', up: 'W', down: 'S' } },\n   *   shoot: { type: 'edge', key: 'SPACE' }\n   * });\n   * ```\n   */\n  bridgeToActions(config: Record<string, 'continuous' | 'edge' | {\n    type: 'continuous' | 'edge';\n    key?: string;\n    keys?: Record<string, string>;\n  }>): void {\n    for (const [action, actionConfig] of Object.entries(config)) {\n      const normalized = typeof actionConfig === 'string'\n        ? { type: actionConfig }\n        : actionConfig;\n\n      if (normalized.type === 'continuous') {\n        // For continuous actions, check if we have aggregated bindings\n        const aggregated = this.aggregatedBindings.get(action);\n        if (aggregated) {\n          // Already configured via useProfile/bindKeysAggregated\n          continue;\n        }\n\n        // Set up new aggregated binding if keys provided\n        if (normalized.keys) {\n          this.bindKeysAggregated(action, normalized.keys, { mode: 'continuous' });\n        }\n      } else if (normalized.type === 'edge') {\n        // For edge triggers, set up binding if key provided\n        if (normalized.key) {\n          this.bindEdgeTrigger(normalized.key, action);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/InputProfiles.ts": "/**\n * Input Profiles - Pre-defined control schemes\n *\n * Eliminates manual key binding boilerplate by providing standard control patterns.\n */\n\nimport type { KeyBindings } from './InputManager.js';\n\nexport interface AggregatedProfileConfig {\n  /** Profile type */\n  type: 'aggregated';\n\n  /** Action name to submit */\n  action: string;\n\n  /** Map of field names to key codes */\n  keys: Record<string, string>;\n\n  /** Continuous or oneshot mode */\n  mode?: 'continuous' | 'oneshot';\n}\n\nexport interface PerKeyProfileConfig {\n  /** Profile type */\n  type: 'per-key';\n\n  /** Key bindings for this profile */\n  bindings: KeyBindings;\n}\n\nexport interface InputProfile {\n  /** Profile name */\n  name: string;\n\n  /** Profile configuration (aggregated or per-key) */\n  config: AggregatedProfileConfig | PerKeyProfileConfig;\n\n  /** Description of the control scheme */\n  description?: string;\n}\n\nexport interface ProfileOptions {\n  /** Override specific keys */\n  overrides?: Partial<KeyBindings>;\n\n  /** Player number (1-based). Changes arrow keys to WASD for player 2 */\n  player?: 1 | 2;\n\n  /** Override action names */\n  action?: string;\n}\n\n/**\n * Built-in input profiles\n */\nexport const BUILT_IN_PROFILES: Record<string, InputProfile> = {\n  platformer: {\n    name: 'platformer',\n    description: 'Side-scrolling platformer controls (Arrow keys + Space for jump)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'Space'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  platformerWASD: {\n    name: 'platformerWASD',\n    description: 'Platformer controls with WASD',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDown: {\n    name: 'topDown',\n    description: '4-directional movement (Arrow keys)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'ArrowUp',\n        down: 'ArrowDown'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDownWASD: {\n    name: 'topDownWASD',\n    description: '4-directional movement (WASD)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W',\n        down: 'S'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  shooter: {\n    name: 'shooter',\n    description: 'Top-down shooter (WASD for move, Space for shoot)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'Space': { action: 'shoot', mode: 'oneshot' },\n      }\n    }\n  },\n\n  twinStick: {\n    name: 'twinStick',\n    description: 'Twin-stick shooter (WASD for move, Arrow keys for aim)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'ArrowLeft': { action: 'aim', input: { x: -1 }, mode: 'continuous' },\n        'ArrowRight': { action: 'aim', input: { x: 1 }, mode: 'continuous' },\n        'ArrowUp': { action: 'aim', input: { y: -1 }, mode: 'continuous' },\n        'ArrowDown': { action: 'aim', input: { y: 1 }, mode: 'continuous' },\n      }\n    }\n  }\n};\n\n/**\n * Custom profile registry\n */\nconst customProfiles = new Map<string, InputProfile>();\n\n/**\n * Register a custom input profile\n *\n * @param name - Profile name\n * @param profile - Profile configuration\n *\n * @example\n * ```ts\n * registerProfile('custom-platformer', {\n *   name: 'custom-platformer',\n *   bindings: {\n *     'A': { action: 'move', input: { left: true }, mode: 'continuous' },\n *     'D': { action: 'move', input: { right: true }, mode: 'continuous' },\n *     'W': { action: 'jump', mode: 'oneshot' },\n *   }\n * });\n * ```\n */\nexport function registerProfile(name: string, profile: InputProfile): void {\n  customProfiles.set(name, profile);\n}\n\n/**\n * Get a profile by name (checks custom profiles first, then built-in)\n *\n * @param name - Profile name\n * @returns Profile or undefined if not found\n */\nexport function getProfile(name: string): InputProfile | undefined {\n  return customProfiles.get(name) || BUILT_IN_PROFILES[name];\n}\n\n/**\n * Apply profile options to a profile config\n *\n * @param profile - Original profile\n * @param options - Profile options\n * @returns Modified profile config\n */\nexport function applyProfileOptions(\n  profile: InputProfile,\n  options?: ProfileOptions\n): AggregatedProfileConfig | PerKeyProfileConfig {\n  if (!options) return profile.config;\n\n  const config = profile.config;\n\n  // For aggregated profiles\n  if (config.type === 'aggregated') {\n    let keys = { ...config.keys };\n\n    // Apply player number (swap arrow keys for WASD)\n    if (options.player === 2) {\n      const keyMap: Record<string, string> = {\n        'ArrowLeft': 'A',\n        'ArrowRight': 'D',\n        'ArrowUp': 'W',\n        'ArrowDown': 'S',\n        'Space': 'Space', // Keep Space unchanged\n      };\n\n      const newKeys: Record<string, string> = {};\n      for (const [field, key] of Object.entries(keys)) {\n        newKeys[field] = keyMap[key] || key;\n      }\n      keys = newKeys;\n    }\n\n    return {\n      type: 'aggregated',\n      action: options.action || config.action,\n      keys,\n      mode: config.mode\n    };\n  }\n\n  // For per-key profiles\n  let bindings = { ...config.bindings };\n\n  // Apply player number (swap arrow keys for WASD)\n  if (options.player === 2) {\n    const keyMap: Record<string, string> = {\n      'ArrowLeft': 'A',\n      'ArrowRight': 'D',\n      'ArrowUp': 'W',\n      'ArrowDown': 'S',\n    };\n\n    const newBindings: KeyBindings = {};\n    for (const [key, binding] of Object.entries(bindings)) {\n      const newKey = keyMap[key] || key;\n      newBindings[newKey] = binding;\n    }\n    bindings = newBindings;\n  }\n\n  // Apply action override\n  if (options.action) {\n    for (const key of Object.keys(bindings)) {\n      const binding = bindings[key];\n      if (typeof binding === 'object') {\n        bindings[key] = { ...binding, action: options.action };\n      }\n    }\n  }\n\n  // Apply key overrides\n  if (options.overrides) {\n    for (const [key, binding] of Object.entries(options.overrides)) {\n      if (binding !== undefined) {\n        bindings[key] = binding;\n      }\n    }\n  }\n\n  return {\n    type: 'per-key',\n    bindings\n  };\n}\n\n/**\n * Merge multiple profiles into one\n *\n * @param profileNames - Array of profile names to merge\n * @returns Merged bindings (only works with per-key profiles)\n *\n * @example\n * ```ts\n * const bindings = mergeProfiles(['shooter', 'twinStick']);\n * // Combines multiple per-key profiles\n * ```\n */\nexport function mergeProfiles(profileNames: string[]): KeyBindings {\n  const merged: KeyBindings = {};\n\n  for (const name of profileNames) {\n    const profile = getProfile(name);\n    if (profile && profile.config.type === 'per-key') {\n      Object.assign(merged, profile.config.bindings);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * List all available profiles\n *\n * @returns Array of profile names\n */\nexport function listProfiles(): string[] {\n  return [\n    ...Object.keys(BUILT_IN_PROFILES),\n    ...Array.from(customProfiles.keys())\n  ];\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/PhysicsManager.ts": "/**\n * PhysicsManager - Automates physics behavior based on inputs\n *\n * Eliminates manual physics loops by automatically reading inputs from state\n * and applying pre-defined or custom physics behaviors.\n *\n * ## Position Syncing (PIT OF SUCCESS!)\n *\n * **NEW:** PhysicsManager now automatically syncs sprite positions BACK to state\n * (enabled by default). This prevents the \"bullets spawn from starting position\" bug\n * where actions reading `state.players[id].x/y` get stale data.\n *\n * **How it works:**\n * 1. PhysicsManager moves sprites via Phaser physics bodies\n * 2. After each physics update, sprite.x/y/rotation → state.players[id].x/y/rotation\n * 3. Actions can now read current positions from state reliably\n *\n * **When to disable:**\n * - Performance optimization for 100+ entities\n * - You're manually syncing positions elsewhere\n * - Set `syncPositionToState: false` in config\n *\n * ## Velocity Updates (Racing Behavior)\n *\n * PhysicsManager provides velocity data through TWO channels:\n *\n * 1. **Local Events** (`onVelocityChange`) - Host only, no network overhead\n *    - Fast, synchronous updates\n *    - Use for: Host-only displays, debug overlays, analytics\n *    - Example: Dev tools showing real-time physics metrics\n *\n * 2. **State Sync** (`state.players[id].velocity`) - Synced across network\n *    - Automatically written to game state\n *    - Use for: Client HUDs, multiplayer displays\n *    - Example: Speed display visible to all players\n *\n * Helpers like `createSpeedDisplay` use BOTH:\n * - Host: Fast event updates (instant feedback)\n * - Clients: State sync (receives velocity from host)\n *\n * @example\n * ```ts\n * // In scene.create()\n * this.physicsManager = this.adapter.createPhysicsManager({\n *   spriteManager: this.spriteManager,\n *   inputKey: 'inputs',\n *   stateKey: 'players', // optional, defaults to 'players'\n *   syncPositionToState: true // optional, defaults to true (PIT OF SUCCESS!)\n * });\n *\n * this.physicsManager.addBehavior('topDown', {\n *   speed: 200\n * });\n *\n * // Now actions can read current positions from state!\n * // shoot action: bullet.x = state.players[id].x ✅ (always up to date)\n *\n * // In scene.update()\n * this.physicsManager.update();\n * ```\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PlatformerBehaviorConfig {\n  speed?: number;\n  jumpPower?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    jump?: string;\n  };\n}\n\nexport interface TopDownBehaviorConfig {\n  speed?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    up?: string;\n    down?: string;\n  };\n}\n\nexport interface RacingBehaviorConfig {\n  /** Acceleration rate when accelerating (default: 5) */\n  acceleration?: number;\n  /** Maximum speed (default: 200) */\n  maxSpeed?: number;\n  /** Turn speed in radians per frame (default: 0.05) */\n  turnSpeed?: number;\n  /** Friction/decay multiplier per frame (default: 0.98) */\n  friction?: number;\n  /** Keys for controls */\n  keys?: {\n    left?: string;\n    right?: string;\n    accelerate?: string;\n  };\n}\n\nexport interface CustomBehaviorConfig {\n  apply: (sprite: any, input: any, body: Phaser.Physics.Arcade.Body) => void;\n}\n\nexport type BehaviorConfig = PlatformerBehaviorConfig | TopDownBehaviorConfig | RacingBehaviorConfig | CustomBehaviorConfig;\n\nexport interface PhysicsManagerConfig {\n  /** SpriteManager to get sprites from */\n  spriteManager: SpriteManager;\n\n  /** Key in state to read inputs from (e.g., 'inputs') */\n  inputKey?: string;\n\n  /** Key prefix for sprite keys (defaults to 'player-') */\n  spriteKeyPrefix?: string;\n\n  /**\n   * Automatically sync sprite positions back to state (default: true)\n   *\n   * **PIT OF SUCCESS:** Enabled by default to prevent the \"bullets spawn from\n   * player's starting position\" bug. When PhysicsManager moves sprites via\n   * physics bodies, those positions need to be written back to state so that\n   * actions (like 'shoot') can read the current position.\n   *\n   * Disable only if you have a specific reason (e.g., performance optimization\n   * for 100+ entities, or you're manually syncing positions elsewhere).\n   *\n   * @default true\n   */\n  syncPositionToState?: boolean;\n\n  /**\n   * State key where player/entity data is stored (default: 'players')\n   * Used for syncing positions back to state when syncPositionToState is enabled\n   */\n  stateKey?: string;\n}\n\n/**\n * Simple event emitter for velocity changes\n */\nclass VelocityEmitter {\n  private listeners: Array<(playerId: string, velocity: number) => void> = [];\n\n  on(callback: (playerId: string, velocity: number) => void): () => void {\n    this.listeners.push(callback);\n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  emit(playerId: string, velocity: number): void {\n    for (const listener of this.listeners) {\n      listener(playerId, velocity);\n    }\n  }\n}\n\nexport class PhysicsManager {\n  private runtime: GameRuntime;\n  private spriteManager: SpriteManager;\n  private inputKey: string;\n  private spriteKeyPrefix: string;\n  private syncPositionToState: boolean;\n  private stateKey: string;\n  private behaviorType: 'platformer' | 'topDown' | 'racing' | 'custom' | null = null;\n  private behaviorConfig: BehaviorConfig | null = null;\n  private velocities: Map<string, number> = new Map(); // Track velocity for racing behavior\n  private velocityEmitter = new VelocityEmitter(); // Event emitter for velocity changes\n\n  constructor(runtime: GameRuntime, config: PhysicsManagerConfig) {\n    this.runtime = runtime;\n    this.spriteManager = config.spriteManager;\n    this.inputKey = config.inputKey || 'inputs';\n    this.spriteKeyPrefix = config.spriteKeyPrefix || 'player-';\n    this.syncPositionToState = config.syncPositionToState !== false; // default true\n    this.stateKey = config.stateKey || 'players';\n  }\n\n  /**\n   * Get velocity for a specific player (racing behavior only)\n   * Useful for displaying speed in HUD\n   *\n   * @param playerId - The player ID to get velocity for\n   * @returns Current velocity, or 0 if not found\n   *\n   * @example\n   * ```ts\n   * const speed = physicsManager.getVelocity(adapter.getLocalPlayerId());\n   * ```\n   */\n  getVelocity(playerId: string): number {\n    return this.velocities.get(playerId) || 0;\n  }\n\n  /**\n   * Get readonly access to all velocities (for debugging/UI)\n   * Returns a readonly map of player IDs to their current velocities\n   */\n  getVelocities(): ReadonlyMap<string, number> {\n    return this.velocities;\n  }\n\n  /**\n   * Subscribe to velocity changes (racing behavior only)\n   *\n   * **Important:** This is a LOCAL event that only fires on the HOST.\n   * Events do NOT cross the network boundary.\n   *\n   * Use cases:\n   * - Host-only displays (debug overlays, dev tools)\n   * - Performance-critical updates (no network overhead)\n   * - Analytics/telemetry (host-side tracking)\n   *\n   * For client displays, use `createSpeedDisplay()` helper which automatically\n   * handles both events (host) and state sync (clients).\n   *\n   * Alternatively, read `state.players[playerId].velocity` which is automatically\n   * synced across the network by PhysicsManager.\n   *\n   * @param callback - Called whenever a player's velocity changes (host only)\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // Host-only analytics\n   * const unsubscribe = physicsManager.onVelocityChange((playerId, velocity) => {\n   *   if (velocity > 250) {\n   *     trackAchievement('speed_demon', playerId);\n   *   }\n   * });\n   *\n   * // Later, cleanup\n   * unsubscribe();\n   * ```\n   */\n  onVelocityChange(callback: (playerId: string, velocity: number) => void): () => void {\n    return this.velocityEmitter.on(callback);\n  }\n\n  /**\n   * Add a physics behavior\n   *\n   * @param type - Behavior type ('platformer', 'topDown', 'racing', 'custom')\n   * @param config - Behavior configuration\n   */\n  addBehavior(\n    type: 'platformer',\n    config?: PlatformerBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'topDown',\n    config?: TopDownBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'racing',\n    config?: RacingBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'custom',\n    config: CustomBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'platformer' | 'topDown' | 'racing' | 'custom',\n    config?: BehaviorConfig\n  ): void {\n    this.behaviorType = type;\n    this.behaviorConfig = config || {};\n  }\n\n  /**\n   * Update physics for all sprites (call in scene.update())\n   * Only runs on host.\n   */\n  update(): void {\n    // Only host applies physics\n    const transport = this.runtime.getTransport();\n    if (!transport.isHost()) return;\n\n    const state = this.runtime.getState() as any;\n    const inputs = state[this.inputKey];\n    if (!inputs) return;\n\n    // Apply physics to each player based on their input\n    for (const [playerId, playerInput] of Object.entries(inputs)) {\n      const sprite = this.spriteManager.get(`${this.spriteKeyPrefix}${playerId}`);\n      if (!sprite || !sprite.body) continue;\n\n      const body = sprite.body as Phaser.Physics.Arcade.Body;\n\n      if (this.behaviorType === 'platformer') {\n        this.applyPlatformerBehavior(body, playerInput as any, this.behaviorConfig as PlatformerBehaviorConfig);\n      } else if (this.behaviorType === 'topDown') {\n        this.applyTopDownBehavior(body, playerInput as any, this.behaviorConfig as TopDownBehaviorConfig);\n      } else if (this.behaviorType === 'racing') {\n        this.applyRacingBehavior(sprite, body, playerInput as any, playerId, this.behaviorConfig as RacingBehaviorConfig);\n      } else if (this.behaviorType === 'custom' && this.behaviorConfig) {\n        const customConfig = this.behaviorConfig as CustomBehaviorConfig;\n        customConfig.apply(sprite, playerInput, body);\n      }\n\n      // Sync sprite position back to state (PIT OF SUCCESS!)\n      // This ensures actions reading from state (e.g., shoot) get current positions\n      if (this.syncPositionToState) {\n        this.syncPositionToStateForPlayer(playerId, sprite);\n      }\n    }\n  }\n\n  private applyPlatformerBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: PlatformerBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const jumpPower = config.jumpPower || 350;\n    const keys = config.keys || { left: 'left', right: 'right', jump: 'up' };\n\n    // Horizontal movement\n    if (input[keys.left!]) {\n      body.setVelocityX(-speed);\n    } else if (input[keys.right!]) {\n      body.setVelocityX(speed);\n    } else {\n      body.setVelocityX(0);\n    }\n\n    // Jumping (only if on ground)\n    if (input[keys.jump!] && body.touching.down) {\n      body.setVelocityY(-jumpPower);\n    }\n  }\n\n  private applyTopDownBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: TopDownBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const keys = config.keys || { left: 'left', right: 'right', up: 'up', down: 'down' };\n\n    let vx = 0;\n    let vy = 0;\n\n    if (input[keys.left!]) vx = -speed;\n    if (input[keys.right!]) vx = speed;\n    if (input[keys.up!]) vy = -speed;\n    if (input[keys.down!]) vy = speed;\n\n    body.setVelocity(vx, vy);\n  }\n\n  private applyRacingBehavior(\n    sprite: any,\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    playerId: string,\n    config: RacingBehaviorConfig\n  ): void {\n    const acceleration = config.acceleration ?? 5;\n    const maxSpeed = config.maxSpeed ?? 200;\n    const turnSpeed = config.turnSpeed ?? 0.05;\n    const friction = config.friction ?? 0.98;\n    const keys = config.keys || { left: 'left', right: 'right', accelerate: 'up' };\n\n    // Get or initialize velocity for this player\n    const prevVelocity = this.velocities.get(playerId) || 0;\n    let velocity = prevVelocity;\n\n    // Rotation (turning)\n    if (input[keys.left!]) {\n      sprite.rotation -= turnSpeed;\n    }\n    if (input[keys.right!]) {\n      sprite.rotation += turnSpeed;\n    }\n\n    // Acceleration\n    if (input[keys.accelerate!]) {\n      velocity = Math.min(velocity + acceleration, maxSpeed);\n    } else {\n      // Apply friction when not accelerating\n      velocity *= friction;\n      // Snap to zero when very slow (avoid asymptotic decay)\n      if (velocity < 0.5) {\n        velocity = 0;\n      }\n    }\n\n    // Store velocity locally\n    this.velocities.set(playerId, velocity);\n\n    // Sync velocity to state so clients can display it\n    this.runtime.mutateState((state: any) => {\n      if (state.players && state.players[playerId]) {\n        state.players[playerId].velocity = velocity;\n      }\n    });\n\n    // Emit event for local reactive displays (host only)\n    this.velocityEmitter.emit(playerId, velocity);\n\n    // Apply velocity in the direction of rotation\n    const vx = Math.cos(sprite.rotation) * velocity;\n    const vy = Math.sin(sprite.rotation) * velocity;\n    body.setVelocity(vx, vy);\n  }\n\n  /**\n   * Sync sprite position and rotation back to state\n   * Called automatically after physics updates when syncPositionToState is enabled\n   */\n  private syncPositionToStateForPlayer(playerId: string, sprite: any): void {\n    this.runtime.mutateState((state: any) => {\n      const entities = state[this.stateKey];\n      if (entities && entities[playerId]) {\n        // Always sync position (this is what PhysicsManager controls)\n        entities[playerId].x = sprite.x;\n        entities[playerId].y = sprite.y;\n\n        // Only sync rotation for racing behavior, where sprite.rotation is modified by physics\n        // For topDown/platformer, rotation is typically managed by actions/game logic\n        if (this.behaviorType === 'racing' && sprite.rotation !== undefined) {\n          entities[playerId].rotation = sprite.rotation;\n        }\n      }\n    });\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/PlayerStatsPanel.ts": "/**\n * PlayerStatsPanel - Display current player's stats/powerups overlay\n *\n * Eliminates the boilerplate of manually tracking and displaying player stats.\n * Perfect for showing equipped powerups, abilities, ammo, inventory, etc.\n *\n * Features:\n * - Auto-reactive to player stat changes\n * - Smart positioning (corners, custom coords)\n * - Icon-based display with optional tooltips\n * - Conditional visibility and highlighting\n * - Type-safe player property access\n *\n * @example\n * ```ts\n * import { createPlayerStatsPanel } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.statsPanel = createPlayerStatsPanel(this.adapter, this, {\n *   position: 'top-left',\n *   stats: {\n *     bombs: {\n *       icon: '💣',\n *       getValue: (player) => `${player.activeBombs}/${player.bombCount}`,\n *       tooltip: 'Bombs (current/max)'\n *     },\n *     speed: {\n *       icon: '⚡',\n *       getValue: (player) => `${Math.round(player.speed * 100)}%`,\n *       highlight: (player) => player.speed > 1.0\n *     }\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport type StatPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | { x: number; y: number };\n\nexport interface StatConfig<TPlayer = any> {\n\t/** Icon/emoji to display */\n\ticon: string;\n\n\t/**\n\t * Get the value to display next to the icon\n\t * @param player - Current player data\n\t * @returns String to display (e.g., \"3/5\", \"120%\", \"✓\")\n\t */\n\tgetValue: (player: TPlayer) => string | number;\n\n\t/**\n\t * Optional tooltip text (for accessibility/clarity)\n\t */\n\ttooltip?: string;\n\n\t/**\n\t * Show this stat only when condition is true\n\t * Useful for abilities that are only visible when active\n\t */\n\tvisible?: (player: TPlayer) => boolean;\n\n\t/**\n\t * Highlight this stat when condition is true (e.g., boosted)\n\t * Adds a glow/color effect\n\t */\n\thighlight?: (player: TPlayer) => boolean;\n}\n\nexport interface PlayerStatsPanelConfig<TPlayer = any> {\n\t/**\n\t * Position of the stats panel\n\t * - 'top-left', 'top-right', 'bottom-left', 'bottom-right'\n\t * - Or custom {x, y} coordinates\n\t */\n\tposition: StatPosition;\n\n\t/**\n\t * Stats to display, keyed by stat name\n\t */\n\tstats: Record<string, StatConfig<TPlayer>>;\n\n\t/**\n\t * Optional styling\n\t */\n\tstyle?: {\n\t\t/** Background color (CSS format) */\n\t\tbackgroundColor?: string;\n\t\t/** Padding around content */\n\t\tpadding?: number;\n\t\t/** Icon font size */\n\t\ticonSize?: number;\n\t\t/** Value text font size */\n\t\tfontSize?: string;\n\t\t/** Spacing between stat items */\n\t\tspacing?: number;\n\t\t/** Highlight color when stat.highlight() returns true */\n\t\thighlightColor?: string;\n\t};\n\n\t/**\n\t * Key in state where players are stored (default: 'players')\n\t */\n\tplayersKey?: string;\n}\n\nexport interface PlayerStatsPanel {\n\t/** Update panel (automatically called when player changes) */\n\tupdate: () => void;\n\t/** Destroy panel elements */\n\tdestroy: () => void;\n\t/** Get container game object */\n\tgetContainer: () => Phaser.GameObjects.Container | null;\n}\n\n/**\n * Create a player stats panel for displaying current player's stats/powerups\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Panel configuration\n * @returns PlayerStatsPanel instance\n */\nexport function createPlayerStatsPanel<TPlayer = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: PlayerStatsPanelConfig<TPlayer>\n): PlayerStatsPanel {\n\tconst playersKey = config.playersKey || 'players';\n\n\t// Default styling\n\tconst style = {\n\t\tbackgroundColor: config.style?.backgroundColor || 'rgba(0, 0, 0, 0.7)',\n\t\tpadding: config.style?.padding ?? 8,\n\t\ticonSize: config.style?.iconSize ?? 24,\n\t\tfontSize: config.style?.fontSize || '16px',\n\t\tspacing: config.style?.spacing ?? 6,\n\t\thighlightColor: config.style?.highlightColor || '#fbbf24'\n\t};\n\n\t// Calculate position\n\tconst getPosition = (): { x: number; y: number } => {\n\t\tif (typeof config.position === 'object' && 'x' in config.position) {\n\t\t\treturn config.position;\n\t\t}\n\n\t\tconst camera = scene.cameras.main;\n\t\tconst padding = 20;\n\n\t\tswitch (config.position) {\n\t\t\tcase 'top-left':\n\t\t\t\treturn { x: padding, y: padding };\n\t\t\tcase 'top-right':\n\t\t\t\treturn { x: camera.width - padding, y: padding };\n\t\t\tcase 'bottom-left':\n\t\t\t\treturn { x: padding, y: camera.height - padding };\n\t\t\tcase 'bottom-right':\n\t\t\t\treturn { x: camera.width - padding, y: camera.height - padding };\n\t\t\tdefault:\n\t\t\t\treturn { x: padding, y: padding };\n\t\t}\n\t};\n\n\tconst pos = getPosition();\n\n\t// Create container\n\tconst container = scene.add.container(pos.x, pos.y);\n\n\t// Background (will be sized dynamically)\n\tconst background = scene.add.rectangle(0, 0, 100, 100, 0x000000, 0.7);\n\tcontainer.add(background);\n\n\t// Track stat elements\n\tconst statElements: Map<\n\t\tstring,\n\t\t{\n\t\t\ticonText: Phaser.GameObjects.Text;\n\t\t\tvalueText: Phaser.GameObjects.Text;\n\t\t\thighlight?: Phaser.GameObjects.Rectangle;\n\t\t}\n\t> = new Map();\n\n\t// Update function\n\tconst update = () => {\n\t\tconst state = adapter.getState();\n\t\tconst myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n\t\tif (!myPlayer) {\n\t\t\t// Hide panel if no player\n\t\t\tcontainer.setVisible(false);\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.setVisible(true);\n\n\t\t// Calculate layout\n\t\tlet currentY = style.padding;\n\t\tlet maxWidth = 0;\n\t\tconst visibleStats: Array<[string, StatConfig<TPlayer>]> = [];\n\n\t\t// First pass: determine visible stats\n\t\tfor (const [statName, statConfig] of Object.entries(config.stats)) {\n\t\t\tif (statConfig.visible && !statConfig.visible(myPlayer)) {\n\t\t\t\t// Hide this stat\n\t\t\t\tconst element = statElements.get(statName);\n\t\t\t\tif (element) {\n\t\t\t\t\telement.iconText.setVisible(false);\n\t\t\t\t\telement.valueText.setVisible(false);\n\t\t\t\t\telement.highlight?.setVisible(false);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvisibleStats.push([statName, statConfig]);\n\t\t}\n\n\t\t// Second pass: create/update visible stats\n\t\tfor (const [statName, statConfig] of visibleStats) {\n\t\t\tlet element = statElements.get(statName);\n\n\t\t\tif (!element) {\n\t\t\t\t// Create new stat element\n\t\t\t\tconst iconText = scene.add.text(style.padding, currentY, statConfig.icon, {\n\t\t\t\t\tfontSize: `${style.iconSize}px`\n\t\t\t\t});\n\n\t\t\t\tconst valueText = scene.add.text(\n\t\t\t\t\tstyle.padding + style.iconSize + 4,\n\t\t\t\t\tcurrentY,\n\t\t\t\t\tString(statConfig.getValue(myPlayer)),\n\t\t\t\t\t{\n\t\t\t\t\t\tfontSize: style.fontSize,\n\t\t\t\t\t\tcolor: '#ffffff'\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Highlight rectangle (behind text, shown conditionally)\n\t\t\t\tconst highlight = scene.add.rectangle(\n\t\t\t\t\t0,\n\t\t\t\t\tcurrentY + style.iconSize / 2,\n\t\t\t\t\t0,\n\t\t\t\t\tstyle.iconSize + 4,\n\t\t\t\t\tparseInt(style.highlightColor.replace('#', '0x'), 16),\n\t\t\t\t\t0.3\n\t\t\t\t);\n\t\t\t\thighlight.setOrigin(0, 0.5);\n\t\t\t\thighlight.setVisible(false);\n\n\t\t\t\tcontainer.add([highlight, iconText, valueText]);\n\n\t\t\t\telement = { iconText, valueText, highlight };\n\t\t\t\tstatElements.set(statName, element);\n\t\t\t}\n\n\t\t\t// Update text\n\t\t\telement.iconText.setText(statConfig.icon);\n\t\t\telement.valueText.setText(String(statConfig.getValue(myPlayer)));\n\n\t\t\t// Update visibility\n\t\t\telement.iconText.setVisible(true);\n\t\t\telement.valueText.setVisible(true);\n\n\t\t\t// Update position\n\t\t\telement.iconText.setPosition(style.padding, currentY);\n\t\t\telement.valueText.setPosition(style.padding + style.iconSize + 4, currentY);\n\n\t\t\t// Update highlight\n\t\t\tconst shouldHighlight = statConfig.highlight ? statConfig.highlight(myPlayer) : false;\n\t\t\tif (element.highlight) {\n\t\t\t\telement.highlight.setVisible(shouldHighlight);\n\t\t\t\telement.highlight.setPosition(style.padding - 2, currentY + style.iconSize / 2);\n\t\t\t\tconst textWidth = element.valueText.width;\n\t\t\t\telement.highlight.width = style.iconSize + 4 + textWidth + 4;\n\t\t\t}\n\n\t\t\t// Track max width\n\t\t\tconst elementWidth = style.iconSize + 4 + element.valueText.width;\n\t\t\tmaxWidth = Math.max(maxWidth, elementWidth);\n\n\t\t\tcurrentY += style.iconSize + style.spacing;\n\t\t}\n\n\t\t// Size background\n\t\tconst bgWidth = maxWidth + style.padding * 2;\n\t\tconst bgHeight = currentY - style.spacing + style.padding;\n\t\tbackground.setSize(bgWidth, bgHeight);\n\n\t\t// Adjust container origin based on position\n\t\tif (config.position === 'top-right' || config.position === 'bottom-right') {\n\t\t\tbackground.setOrigin(1, 0);\n\t\t\tcontainer.x = pos.x;\n\t\t} else {\n\t\t\tbackground.setOrigin(0, 0);\n\t\t}\n\t};\n\n\t// Subscribe to state changes\n\tconst unsubscribe = adapter.onChange(() => {\n\t\tupdate();\n\t});\n\n\t// Initial update\n\tupdate();\n\n\t// Return interface\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\tunsubscribe();\n\t\t\tcontainer.destroy();\n\t\t},\n\t\tgetContainer: () => container\n\t};\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/PlayerUIManager.ts": "/**\n * PlayerUIManager - Automatic UI synchronization for players\n *\n * Eliminates bugs caused by:\n * - Creating UI before player metadata (side, team, etc.) is synced\n * - Forgetting to update UI when player data changes\n * - Manual loops to create/update/destroy UI elements\n *\n * Features:\n * - Waits for staticProperties before creating UI (no race conditions!)\n * - Auto-repositions UI when metadata changes\n * - Auto-creates UI for late-joining players\n * - Auto-destroys UI when players leave\n *\n * Usage:\n * ```ts\n * const playerUI = adapter.createPlayerUIManager({\n *   score: {\n *     position: (player) => ({\n *       x: player.side === 'left' ? 200 : 600,\n *       y: 80\n *     }),\n *     getText: (player) => String(player.score || 0),\n *     style: { fontSize: '48px', color: '#fff' }\n *   },\n *\n *   health: {\n *     position: (player) => ({ x: player.x, y: player.y - 30 }),\n *     width: 50,\n *     height: 5,\n *     getValue: (player) => player.health / player.maxHealth,\n *     backgroundColor: 0x333333,\n *     foregroundColor: 0x00ff00\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TextUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   * Called when UI is created AND when metadata changes\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Text content function\n   */\n  getText: (player: any, playerId: string) => string;\n\n  /**\n   * Phaser text style\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   * Example: ['side', 'team'] - waits until these are synced\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface BarUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Value function (0-1 range)\n   */\n  getValue: (player: any, playerId: string) => number;\n\n  /**\n   * Bar dimensions\n   */\n  width: number;\n  height: number;\n\n  /**\n   * Colors\n   */\n  backgroundColor: number;\n  foregroundColor: number;\n\n  /**\n   * Bar origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface PlayerUIManagerConfig {\n  /**\n   * UI elements keyed by name\n   * Each element can be text or bar type\n   */\n  [elementName: string]: TextUIConfig | BarUIConfig;\n}\n\ntype UIElement = {\n  type: 'text' | 'bar';\n  config: TextUIConfig | BarUIConfig;\n  gameObject: any; // Phaser.GameObjects.Text | Container with rectangles\n};\n\nexport class PlayerUIManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: PlayerUIManagerConfig;\n  private playerElements: Map<string, Map<string, UIElement>> = new Map(); // playerId -> elementName -> UIElement\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, scene: any, config: PlayerUIManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config;\n\n    // Subscribe to state changes\n    this.unsubscribe = adapter.onChange((state: any) => {\n      this.syncFromState(state);\n    });\n  }\n\n  /**\n   * Get UI element for a specific player\n   */\n  get(playerId: string, elementName: string): any {\n    return this.playerElements.get(playerId)?.get(elementName)?.gameObject;\n  }\n\n  /**\n   * Manually update all UI (also called automatically on state changes)\n   */\n  update(): void {\n    const state = this.adapter.getRuntime().getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Destroy all UI elements\n    for (const [playerId, elements] of this.playerElements.entries()) {\n      for (const [elementName, element] of elements.entries()) {\n        this.destroyElement(element);\n      }\n    }\n    this.playerElements.clear();\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * Sync UI from state\n   */\n  private syncFromState(state: any): void {\n    if (!state.players) return;\n\n    const existingPlayers = new Set(this.playerElements.keys());\n\n    // Create/update UI for each player\n    for (const [playerId, playerData] of Object.entries(state.players) as [string, any][]) {\n      existingPlayers.delete(playerId);\n\n      // Get or create element map for this player\n      let elements = this.playerElements.get(playerId);\n      if (!elements) {\n        elements = new Map();\n        this.playerElements.set(playerId, elements);\n      }\n\n      // Create/update each UI element\n      for (const [elementName, elementConfig] of Object.entries(this.config)) {\n        const existing = elements.get(elementName);\n\n        // Check if required metadata exists\n        const requiredMetadata = (elementConfig as any).requiredMetadata || [];\n        const hasMetadata = requiredMetadata.every((key: string) => key in playerData);\n\n        if (!hasMetadata) {\n          // Metadata not ready yet - skip creation\n          continue;\n        }\n\n        if (!existing) {\n          // Create new UI element\n          const element = this.createElement(elementName, elementConfig, playerId, playerData);\n          if (element) {\n            elements.set(elementName, element);\n          }\n        } else {\n          // Update existing UI element\n          this.updateElement(existing, playerId, playerData);\n        }\n      }\n    }\n\n    // Remove UI for players who left\n    for (const playerId of existingPlayers) {\n      const elements = this.playerElements.get(playerId);\n      if (elements) {\n        for (const element of elements.values()) {\n          this.destroyElement(element);\n        }\n      }\n      this.playerElements.delete(playerId);\n    }\n  }\n\n  /**\n   * Create a UI element\n   */\n  private createElement(\n    elementName: string,\n    config: TextUIConfig | BarUIConfig,\n    playerId: string,\n    playerData: any\n  ): UIElement | null {\n    const pos = config.position(playerData, playerId);\n\n    if (this.isTextConfig(config)) {\n      // Create text element\n      const text = this.scene.add.text(\n        pos.x,\n        pos.y,\n        config.getText(playerData, playerId),\n        config.style || {}\n      );\n\n      if (config.origin !== undefined) {\n        if (typeof config.origin === 'number') {\n          text.setOrigin(config.origin);\n        } else {\n          text.setOrigin(config.origin.x, config.origin.y);\n        }\n      }\n\n      if (config.depth !== undefined) {\n        text.setDepth(config.depth);\n      }\n\n      return {\n        type: 'text',\n        config,\n        gameObject: text\n      };\n    } else {\n      // Create bar element (container with two rectangles)\n      const container = this.scene.add.container(pos.x, pos.y);\n\n      const bg = this.scene.add.rectangle(0, 0, config.width, config.height, config.backgroundColor);\n      const fg = this.scene.add.rectangle(\n        0,\n        0,\n        config.width * config.getValue(playerData, playerId),\n        config.height,\n        config.foregroundColor\n      );\n\n      if (config.origin !== undefined) {\n        const originX = typeof config.origin === 'number' ? config.origin : config.origin.x;\n        const originY = typeof config.origin === 'number' ? config.origin : config.origin.y;\n        bg.setOrigin(originX, originY);\n        fg.setOrigin(originX, originY);\n      }\n\n      container.add([bg, fg]);\n\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n\n      // Store references for updates\n      (container as any)._bg = bg;\n      (container as any)._fg = fg;\n\n      return {\n        type: 'bar',\n        config,\n        gameObject: container\n      };\n    }\n  }\n\n  /**\n   * Update a UI element\n   */\n  private updateElement(element: UIElement, playerId: string, playerData: any): void {\n    const pos = element.config.position(playerData, playerId);\n\n    if (element.type === 'text') {\n      const config = element.config as TextUIConfig;\n      const text = element.gameObject;\n\n      text.setPosition(pos.x, pos.y);\n      text.setText(config.getText(playerData, playerId));\n    } else {\n      const config = element.config as BarUIConfig;\n      const container = element.gameObject;\n      const fg = (container as any)._fg;\n\n      container.setPosition(pos.x, pos.y);\n\n      // Update bar width based on value\n      const value = Math.max(0, Math.min(1, config.getValue(playerData, playerId)));\n      fg.width = config.width * value;\n    }\n  }\n\n  /**\n   * Destroy a UI element\n   */\n  private destroyElement(element: UIElement): void {\n    if (element.gameObject && element.gameObject.destroy) {\n      element.gameObject.destroy();\n    }\n  }\n\n  /**\n   * Type guard for TextUIConfig\n   */\n  private isTextConfig(config: TextUIConfig | BarUIConfig): config is TextUIConfig {\n    return 'getText' in config;\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/RoundManager.ts": "/**\n * RoundManager - Complete round-based game system with timer, announcements, and scoring\n *\n * Eliminates 200+ lines of boilerplate for round-based games.\n * Perfect for fighting games, battle royales, sports games, etc.\n *\n * Features:\n * - Round timer with visual warnings\n * - Automatic round end detection\n * - Freeze frames and announcements between rounds\n * - Score tracking UI\n * - Match winner detection\n * - Customizable UI and flow\n *\n * @example\n * ```ts\n * import { createRoundManager } from '@martini-kit/phaser';\n *\n * // In scene.create()\n * this.rounds = createRoundManager(this.adapter, this, {\n *   roundsToWin: 3,\n *   \n *   // State keys\n *   timerStateKey: 'roundTimer',\n *   roundStateKey: 'round',\n *   \n *   // Win detection\n *   checkWinner: (state) => {\n *     const alive = Object.entries(state.players).filter(([, p]) => p.alive);\n *     if (alive.length === 1) return alive[0][0];\n *     if (state.roundTimer <= 0) return null; // Draw\n *     return undefined; // Continue\n *   },\n *   \n *   ui: {\n *     timer: {\n *       position: { x: 400, y: 50 },\n *       format: (ms) => `${Math.ceil(ms / 1000)}s`,\n *       warningAt: 30000\n *     }\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TimerUIConfig {\n\t/** Position of timer display */\n\tposition: { x: number; y: number };\n\n\t/**\n\t * Format timer value for display\n\t * @param milliseconds - Time remaining in milliseconds\n\t * @returns Formatted string (e.g., \"1:23\", \"90s\")\n\t */\n\tformat: (milliseconds: number) => string;\n\n\t/**\n\t * Show warning color when time is below this threshold (ms)\n\t * Default: 30000 (30 seconds)\n\t */\n\twarningAt?: number;\n\n\t/** Style for timer text */\n\tstyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n\t/** Warning style (overrides style when warning) */\n\twarningStyle?: Phaser.Types.GameObjects.Text.TextStyle;\n}\n\nexport interface AnnouncementUIConfig<TPlayer = any> {\n\t/**\n\t * Get announcement text when a player wins the round\n\t */\n\twinner: (player: TPlayer, winnerId: string) => string;\n\n\t/**\n\t * Get announcement text when round ends in a draw\n\t */\n\tdraw: () => string;\n\n\t/**\n\t * Get announcement text when a player wins the match\n\t */\n\tmatchWin: (player: TPlayer, winnerId: string) => string;\n\n\t/**\n\t * Duration to show announcement (ms)\n\t * Default: 3000\n\t */\n\tfreezeDuration?: number;\n\n\t/**\n\t * Position of announcement\n\t * Default: center of screen\n\t */\n\tposition?: { x: number; y: number };\n\n\t/** Style for announcement text */\n\tstyle?: Phaser.Types.GameObjects.Text.TextStyle;\n}\n\nexport interface ScoreboardUIConfig<TPlayer = any> {\n\t/** Position of scoreboard */\n\tposition: { x: number; y: number };\n\n\t/**\n\t * Format score display for each player\n\t * @param player - Player data\n\t * @param index - Player index\n\t * @param playerId - Player ID\n\t * @returns Formatted string\n\t */\n\tformat: (player: TPlayer, index: number, playerId: string) => string;\n\n\t/** Style for score text */\n\tstyle?: Phaser.Types.GameObjects.Text.TextStyle;\n\n\t/** Spacing between score lines */\n\tspacing?: number;\n}\n\nexport interface RoundManagerConfig<TPlayer = any, TState = any> {\n\t/**\n\t * Number of rounds to win the match\n\t */\n\troundsToWin: number;\n\n\t/**\n\t * State key where round timer is stored (in milliseconds)\n\t * Default: 'roundTimer'\n\t */\n\ttimerStateKey?: string;\n\n\t/**\n\t * State key where current round number is stored\n\t * Default: 'round'\n\t */\n\troundStateKey?: string;\n\n\t/**\n\t * State key where players are stored\n\t * Default: 'players'\n\t */\n\tplayersKey?: string;\n\n\t/**\n\t * State key where game over flag is stored\n\t * Default: 'gameOver'\n\t */\n\tgameOverKey?: string;\n\n\t/**\n\t * State key where winner ID is stored\n\t * Default: 'winner'\n\t */\n\twinnerKey?: string;\n\n\t/**\n\t * Check if round should end and determine winner\n\t * @param state - Full game state\n\t * @returns winnerId (string), null (draw), or undefined (continue playing)\n\t */\n\tcheckWinner: (state: TState) => string | null | undefined;\n\n\t/**\n\t * UI configuration\n\t */\n\tui: {\n\t\t/** Timer display config */\n\t\ttimer?: TimerUIConfig;\n\n\t\t/** Announcement config */\n\t\tannouncement?: AnnouncementUIConfig<TPlayer>;\n\n\t\t/** Scoreboard config */\n\t\tscoreboard?: ScoreboardUIConfig<TPlayer>;\n\t};\n}\n\nexport interface RoundManager {\n\t/** Update UI (automatically called on state changes) */\n\tupdate: () => void;\n\t/** Destroy UI elements */\n\tdestroy: () => void;\n\t/** Get timer text object */\n\tgetTimerText: () => Phaser.GameObjects.Text | null;\n\t/** Get announcement text object */\n\tgetAnnouncementText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a round manager with timer, announcements, and scoring\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - Round manager configuration\n * @returns RoundManager instance\n */\nexport function createRoundManager<TPlayer = any, TState = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: RoundManagerConfig<TPlayer, TState>\n): RoundManager {\n\tconst runtime = adapter.getRuntime();\n\n\t// State keys\n\tconst timerKey = config.timerStateKey || 'roundTimer';\n\tconst roundKey = config.roundStateKey || 'round';\n\tconst playersKey = config.playersKey || 'players';\n\tconst gameOverKey = config.gameOverKey || 'gameOver';\n\tconst winnerKey = config.winnerKey || 'winner';\n\n\t// UI elements\n\tlet timerText: Phaser.GameObjects.Text | null = null;\n\tlet announcementText: Phaser.GameObjects.Text | null = null;\n\tconst scoreTexts: Phaser.GameObjects.Text[] = [];\n\n\t// Create timer UI\n\tif (config.ui.timer) {\n\t\tconst timerConfig = config.ui.timer;\n\t\tconst defaultStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n\t\t\tfontSize: '24px',\n\t\t\tcolor: '#ffffff',\n\t\t\tfontStyle: 'bold',\n\t\t\t...timerConfig.style\n\t\t};\n\n\t\ttimerText = scene.add.text(\n\t\t\ttimerConfig.position.x,\n\t\t\ttimerConfig.position.y,\n\t\t\t'',\n\t\t\tdefaultStyle\n\t\t);\n\t\ttimerText.setOrigin(0.5);\n\t}\n\n\t// Create announcement UI (hidden initially)\n\tif (config.ui.announcement) {\n\t\tconst announcementConfig = config.ui.announcement;\n\t\tconst camera = scene.cameras.main;\n\t\tconst pos = announcementConfig.position || { x: camera.width / 2, y: camera.height / 2 };\n\n\t\tconst defaultStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n\t\t\tfontSize: '48px',\n\t\t\tcolor: '#fbbf24',\n\t\t\tfontStyle: 'bold',\n\t\t\tstroke: '#000',\n\t\t\tstrokeThickness: 6,\n\t\t\t...announcementConfig.style\n\t\t};\n\n\t\tannouncementText = scene.add.text(pos.x, pos.y, '', defaultStyle);\n\t\tannouncementText.setOrigin(0.5);\n\t\tannouncementText.setVisible(false);\n\t\tannouncementText.setDepth(1000); // Always on top\n\t}\n\n\t// Freeze state\n\tlet isFrozen = false;\n\tlet freezeTimer = 0;\n\n\t/**\n\t * Show announcement and freeze gameplay\n\t */\n\tconst showAnnouncement = (text: string, duration: number) => {\n\t\tif (!announcementText) return;\n\n\t\tannouncementText.setText(text);\n\t\tannouncementText.setVisible(true);\n\n\t\t// Fade in\n\t\tannouncementText.setAlpha(0);\n\t\tscene.tweens.add({\n\t\t\ttargets: announcementText,\n\t\t\talpha: 1,\n\t\t\tduration: 200,\n\t\t\tease: 'Cubic.easeOut'\n\t\t});\n\n\t\t// Freeze gameplay\n\t\tisFrozen = true;\n\t\tfreezeTimer = duration;\n\n\t\t// Auto-hide after duration\n\t\tscene.time.delayedCall(duration, () => {\n\t\t\tif (!announcementText) return;\n\n\t\t\t// Fade out\n\t\t\tscene.tweens.add({\n\t\t\t\ttargets: announcementText,\n\t\t\t\talpha: 0,\n\t\t\t\tduration: 300,\n\t\t\t\tease: 'Cubic.easeIn',\n\t\t\t\tonComplete: () => {\n\t\t\t\t\tannouncementText?.setVisible(false);\n\t\t\t\t\tisFrozen = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * Update all UI elements\n\t */\n\tconst update = () => {\n\t\tconst state = runtime.getState() as any;\n\n\t\t// Update timer\n\t\tif (timerText && config.ui.timer) {\n\t\t\tconst timerValue = state[timerKey] || 0;\n\t\t\tconst formatted = config.ui.timer.format(timerValue);\n\t\t\ttimerText.setText(formatted);\n\n\t\t\t// Apply warning style\n\t\t\tconst warningAt = config.ui.timer.warningAt ?? 30000;\n\t\t\tif (timerValue <= warningAt && config.ui.timer.warningStyle) {\n\t\t\t\ttimerText.setStyle(config.ui.timer.warningStyle);\n\t\t\t} else if (config.ui.timer.style) {\n\t\t\t\ttimerText.setStyle(config.ui.timer.style);\n\t\t\t}\n\t\t}\n\n\t\t// Update scoreboard\n\t\tif (config.ui.scoreboard) {\n\t\t\tconst scoreConfig = config.ui.scoreboard;\n\t\t\tconst players = state[playersKey] || {};\n\t\t\tconst playerEntries = Object.entries(players) as [string, TPlayer][];\n\n\t\t\t// Remove old score texts\n\t\t\tscoreTexts.forEach((text) => text.destroy());\n\t\t\tscoreTexts.length = 0;\n\n\t\t\t// Create new score texts\n\t\t\tlet yOffset = 0;\n\t\t\tconst spacing = scoreConfig.spacing ?? 25;\n\n\t\t\tplayerEntries.forEach(([playerId, player], index) => {\n\t\t\t\tconst text = scene.add.text(\n\t\t\t\t\tscoreConfig.position.x,\n\t\t\t\t\tscoreConfig.position.y + yOffset,\n\t\t\t\t\tscoreConfig.format(player, index, playerId),\n\t\t\t\t\tscoreConfig.style || { fontSize: '16px', color: '#ffffff' }\n\t\t\t\t);\n\n\t\t\t\tscoreTexts.push(text);\n\t\t\t\tyOffset += spacing;\n\t\t\t});\n\t\t}\n\n\t\t// Check for round end (host only)\n\t\tif (adapter.isHost() && !isFrozen && !state[gameOverKey]) {\n\t\t\tconst winnerId = config.checkWinner(state);\n\n\t\t\tif (winnerId !== undefined) {\n\t\t\t\t// Round ended!\n\t\t\t\tconst players = state[playersKey] || {};\n\n\t\t\t\tif (winnerId === null) {\n\t\t\t\t\t// Draw\n\t\t\t\t\tif (config.ui.announcement) {\n\t\t\t\t\t\tconst text = config.ui.announcement.draw();\n\t\t\t\t\t\tconst duration = config.ui.announcement.freezeDuration ?? 3000;\n\t\t\t\t\t\tshowAnnouncement(text, duration);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Submit endRound action with null winner\n\t\t\t\t\truntime.submitAction('endRound', { winnerId: null });\n\t\t\t\t} else {\n\t\t\t\t\t// Player won\n\t\t\t\t\tconst winner = players[winnerId];\n\n\t\t\t\t\t// Check for match win\n\t\t\t\t\tconst score = (winner as any).score || 0;\n\t\t\t\t\tconst isMatchWin = score + 1 >= config.roundsToWin;\n\n\t\t\t\t\tif (config.ui.announcement) {\n\t\t\t\t\t\tconst text = isMatchWin\n\t\t\t\t\t\t\t? config.ui.announcement.matchWin(winner, winnerId)\n\t\t\t\t\t\t\t: config.ui.announcement.winner(winner, winnerId);\n\t\t\t\t\t\tconst duration = config.ui.announcement.freezeDuration ?? 3000;\n\t\t\t\t\t\tshowAnnouncement(text, duration);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Submit endRound action\n\t\t\t\t\truntime.submitAction('endRound', { winnerId });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Show game over announcement\n\t\tif (state[gameOverKey] && state[winnerKey]) {\n\t\t\tconst players = state[playersKey] || {};\n\t\t\tconst winner = players[state[winnerKey]];\n\n\t\t\tif (winner && config.ui.announcement && announcementText && !announcementText.visible) {\n\t\t\t\tconst text = config.ui.announcement.matchWin(winner, state[winnerKey]);\n\t\t\t\tannouncementText.setText(text);\n\t\t\t\tannouncementText.setVisible(true);\n\t\t\t\tannouncementText.setAlpha(1);\n\t\t\t}\n\t\t}\n\t};\n\n\t// Subscribe to state changes\n\tconst unsubscribe = adapter.onChange(() => {\n\t\tupdate();\n\t});\n\n\t// Initial update\n\tupdate();\n\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\tunsubscribe();\n\t\t\ttimerText?.destroy();\n\t\t\tannouncementText?.destroy();\n\t\t\tscoreTexts.forEach((text) => text.destroy());\n\t\t},\n\t\tgetTimerText: () => timerText,\n\t\tgetAnnouncementText: () => announcementText\n\t};\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/SpeedDisplay.ts": "/**\n * SpeedDisplay - Reactive speed/velocity display helper\n *\n * Automatically updates when PhysicsManager velocity changes.\n * Separates physics logic from presentation concerns.\n *\n * ## How it works:\n *\n * - **Host:** Subscribes to `onVelocityChange` events for instant updates (no network delay)\n * - **Clients:** Subscribes to state changes, reads `state.players[id].velocity` synced from host\n *\n * This hybrid approach ensures:\n * - Host gets instant feedback (local events, no network overhead)\n * - Clients get accurate sync (velocity automatically synced via state)\n * - No manual update() calls needed - fully reactive!\n *\n * @example\n * ```ts\n * import { createSpeedDisplay } from '@martini-kit/phaser';\n *\n * // In scene.create() - after creating PhysicsManager\n * this.speedDisplay = createSpeedDisplay(\n *   this.physicsManager,\n *   this.adapter,\n *   this,\n *   {\n *     position: { x: 400, y: 50 },\n *     format: (velocity) => `${Math.round(velocity)} mph`,\n *     style: { fontSize: '20px', color: '#4a9eff' }\n *   }\n * );\n *\n * // No update() needed - automatically reacts to velocity changes!\n *\n * // In scene shutdown/destroy:\n * this.speedDisplay.destroy();\n * ```\n */\n\nimport type { PhysicsManager } from './PhysicsManager.js';\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpeedDisplayConfig {\n  /**\n   * Position of the speed display text\n   * Default: { x: 400, y: 50 }\n   */\n  position?: { x: number; y: number };\n\n  /**\n   * Format function to convert velocity to display string\n   * Default: (velocity) => `Speed: ${Math.round(velocity)}`\n   */\n  format?: (velocity: number) => string;\n\n  /**\n   * Phaser text style\n   * Default: { fontSize: '20px', color: '#fff' }\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n}\n\nexport interface SpeedDisplay {\n  /**\n   * Manually update the display (rarely needed - auto-updates via events)\n   */\n  update: () => void;\n\n  /**\n   * Destroy the display and cleanup listeners\n   */\n  destroy: () => void;\n\n  /**\n   * Get the underlying Phaser text object\n   */\n  getText: () => Phaser.GameObjects.Text;\n}\n\n/**\n * Create a speed display that reacts to PhysicsManager velocity changes\n *\n * @param physicsManager - PhysicsManager instance to subscribe to\n * @param adapter - PhaserAdapter instance (for getting local player ID)\n * @param scene - Phaser scene to create text in\n * @param config - Display configuration\n * @returns SpeedDisplay instance with update/destroy methods\n */\nexport function createSpeedDisplay(\n  physicsManager: PhysicsManager,\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: SpeedDisplayConfig = {}\n): SpeedDisplay {\n  // Default config\n  const position = config.position ?? { x: 400, y: 50 };\n  const format = config.format ?? ((v: number) => `Speed: ${Math.round(v)}`);\n  const style = config.style ?? { fontSize: '20px', color: '#fff' };\n\n  // Create text object\n  const text = scene.add.text(position.x, position.y, format(0), style);\n\n  // Set origin\n  if (config.origin !== undefined) {\n    if (typeof config.origin === 'number') {\n      text.setOrigin(config.origin);\n    } else {\n      text.setOrigin(config.origin.x, config.origin.y);\n    }\n  } else {\n    text.setOrigin(0.5); // default: centered\n  }\n\n  // Set depth\n  if (config.depth !== undefined) {\n    text.setDepth(config.depth);\n  }\n\n  // Subscribe to velocity changes (host only - events don't cross network)\n  const unsubscribeVelocity = physicsManager.onVelocityChange((playerId, velocity) => {\n    if (playerId === adapter.getLocalPlayerId()) {\n      text.setText(format(velocity));\n    }\n  });\n\n  // Subscribe to state changes (clients get velocity from state)\n  const unsubscribeState = adapter.onChange((state: any) => {\n    const localPlayerId = adapter.getLocalPlayerId();\n    const player = state.players?.[localPlayerId];\n    if (player && player.velocity !== undefined) {\n      text.setText(format(player.velocity));\n    }\n  });\n\n  // Manual update function\n  const update = () => {\n    const velocity = physicsManager.getVelocity(adapter.getLocalPlayerId());\n    text.setText(format(velocity));\n  };\n\n  // Initial update\n  update();\n\n  return {\n    update,\n    destroy: () => {\n      unsubscribeVelocity();\n      unsubscribeState();\n      text.destroy();\n    },\n    getText: () => text\n  };\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/SpriteAttachment.ts": "/**\n * SpriteAttachment - Generic system for attaching auto-updating components to sprites\n *\n * This is the foundation for all sprite attachments (arrows, health bars, name tags, etc.)\n * It provides a unified \"pit of success\" pattern with automatic updates and cleanup.\n *\n * ## Why Use SpriteAttachment?\n *\n * - **Auto-update by default** - No manual update() calls needed\n * - **Auto-cleanup** - Destroys when sprite/scene is destroyed\n * - **Type-safe** - Full TypeScript support\n * - **Reusable** - One pattern for all attachment types\n * - **Efficient** - Uses Phaser's event system\n *\n * ## Creating Custom Attachments\n *\n * @example Basic attachment\n * ```ts\n * import { createSpriteAttachment, SpriteAttachment } from '@martini-kit/phaser';\n *\n * function createCustomIndicator(\n *   scene: Phaser.Scene,\n *   sprite: any\n * ): SpriteAttachment {\n *   const circle = scene.add.circle(sprite.x, sprite.y, 10, 0xff0000);\n *\n *   return createSpriteAttachment(scene, sprite, {\n *     update: () => {\n *       // Follow the sprite\n *       circle.setPosition(sprite.x, sprite.y + 30);\n *     },\n *     destroy: () => {\n *       circle.destroy();\n *     }\n *   });\n * }\n * ```\n *\n * @example With manual update mode\n * ```ts\n * const attachment = createSpriteAttachment(scene, sprite, {\n *   update: () => { ... },\n *   destroy: () => { ... },\n *   autoUpdate: false  // Disable auto-update\n * });\n *\n * // Then in your scene's update loop:\n * attachment.update();\n * ```\n */\n\nimport type Phaser from 'phaser';\n\n/**\n * Core interface for sprite attachments\n *\n * Any component that follows the sprite (arrows, health bars, name tags, etc.)\n * should implement this interface.\n */\nexport interface SpriteAttachment {\n  /**\n   * Update the attachment's position, rotation, or other properties\n   * based on the parent sprite's current state.\n   *\n   * Called automatically every frame if autoUpdate is enabled.\n   */\n  update: () => void;\n\n  /**\n   * Clean up resources and destroy the attachment.\n   *\n   * Called automatically when sprite/scene is destroyed if autoUpdate is enabled.\n   */\n  destroy: () => void;\n\n  /**\n   * Get the underlying Phaser game object (if any)\n   *\n   * Optional - only needed if the attachment has a visual representation\n   */\n  getGameObject?: () => Phaser.GameObjects.GameObject | null;\n}\n\n/**\n * Configuration for sprite attachment auto-update behavior\n */\nexport interface SpriteAttachmentConfig {\n  /**\n   * Automatically update the attachment every frame\n   *\n   * When true (default), the attachment subscribes to the scene's update event\n   * and automatically calls update() each frame.\n   *\n   * When false, you must manually call attachment.update() in your scene loop.\n   *\n   * @default true\n   */\n  autoUpdate?: boolean;\n}\n\n/**\n * Create a sprite attachment with automatic updates and cleanup\n *\n * This is the foundation function used by all attachment helpers\n * (attachDirectionalIndicator, createHealthBar, createNameTag, etc.)\n *\n * **Automatic Lifecycle Management:**\n * - Calls `update()` every frame via scene events (if autoUpdate: true)\n * - Calls `destroy()` when sprite is destroyed\n * - Calls `destroy()` when scene shuts down\n * - Prevents double-destroy and memory leaks\n *\n * @param scene - Phaser scene\n * @param sprite - Sprite to attach to\n * @param attachment - Attachment implementation (update + destroy)\n * @param config - Auto-update configuration\n * @returns Enhanced attachment with lifecycle management\n *\n * @example Creating a simple follower circle\n * ```ts\n * const circle = scene.add.circle(sprite.x, sprite.y, 10, 0xff0000);\n *\n * const attachment = createSpriteAttachment(scene, sprite, {\n *   update: () => {\n *     circle.setPosition(sprite.x + 20, sprite.y);\n *   },\n *   destroy: () => {\n *     circle.destroy();\n *   }\n * });\n * // That's it! Circle auto-follows sprite and auto-cleans up\n * ```\n */\nexport function createSpriteAttachment(\n  scene: Phaser.Scene,\n  sprite: any,\n  attachment: SpriteAttachment,\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment {\n  const autoUpdate = config.autoUpdate ?? true;\n\n  // Track destruction state to prevent double-destroy\n  let isDestroyed = false;\n\n  // Wrap the original destroy to track state\n  const originalDestroy = attachment.destroy;\n  const wrappedDestroy = () => {\n    if (isDestroyed) return;\n    isDestroyed = true;\n\n    // Remove event listener if auto-update is enabled\n    if (updateHandler) {\n      scene.events.off('update', updateHandler);\n      updateHandler = null;\n    }\n\n    // Call original destroy\n    originalDestroy();\n  };\n\n  // Auto-update setup\n  let updateHandler: (() => void) | null = null;\n\n  if (autoUpdate) {\n    // Initial update\n    attachment.update();\n\n    // Create update handler\n    updateHandler = () => {\n      if (!isDestroyed) {\n        attachment.update();\n      }\n    };\n\n    // Subscribe to scene update event\n    scene.events.on('update', updateHandler);\n\n    // Cleanup when sprite is destroyed\n    if (sprite.once) {\n      sprite.once('destroy', () => {\n        wrappedDestroy();\n      });\n    }\n\n    // Cleanup when scene shuts down\n    scene.events.once('shutdown', () => {\n      if (updateHandler) {\n        scene.events.off('update', updateHandler);\n        updateHandler = null;\n      }\n    });\n  } else {\n    // Manual mode - just do initial update\n    attachment.update();\n  }\n\n  // Return wrapped attachment\n  return {\n    update: attachment.update,\n    destroy: wrappedDestroy,\n    getGameObject: attachment.getGameObject\n  };\n}\n\n/**\n * Helper to create multiple attachments at once\n *\n * Useful when you want to attach several components to the same sprite\n * (e.g., arrow + health bar + name tag).\n *\n * @example\n * ```ts\n * createSpriteAttachments(scene, sprite, [\n *   createDirectionalArrow(scene, sprite),\n *   createHealthBar(scene, sprite, { maxHealth: 100 }),\n *   createNameTag(scene, sprite, { text: 'Player 1' })\n * ]);\n * ```\n */\nexport function createSpriteAttachments(\n  scene: Phaser.Scene,\n  sprite: any,\n  attachments: SpriteAttachment[],\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment[] {\n  return attachments.map((attachment) =>\n    createSpriteAttachment(scene, sprite, attachment, config)\n  );\n}\n\n/**\n * Composite attachment that manages multiple child attachments\n *\n * Useful for complex attachments that have multiple visual components.\n *\n * @example\n * ```ts\n * const composite = createCompositeAttachment(scene, sprite, [\n *   { update: () => updateArrow(), destroy: () => arrow.destroy() },\n *   { update: () => updateGlow(), destroy: () => glow.destroy() }\n * ]);\n * // All children auto-update and auto-destroy together\n * ```\n */\nexport function createCompositeAttachment(\n  scene: Phaser.Scene,\n  sprite: any,\n  children: SpriteAttachment[],\n  config: SpriteAttachmentConfig = {}\n): SpriteAttachment {\n  // Create wrapped versions of all children with autoUpdate disabled\n  // (the composite will handle updates)\n  const wrappedChildren = children.map((child) =>\n    createSpriteAttachment(scene, sprite, child, { autoUpdate: false })\n  );\n\n  // Create composite that updates/destroys all children\n  return createSpriteAttachment(\n    scene,\n    sprite,\n    {\n      update: () => {\n        for (const child of wrappedChildren) {\n          child.update();\n        }\n      },\n      destroy: () => {\n        for (const child of wrappedChildren) {\n          child.destroy();\n        }\n      },\n      getGameObject: () => {\n        // Return first child's game object (if any)\n        return wrappedChildren[0]?.getGameObject?.() ?? null;\n      }\n    },\n    config\n  );\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/SpriteManager.ts": "/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Optional motion profile to auto-tune sync defaults.\n   * 'platformer' → faster sync (16ms) to match physics frame rate.\n   */\n  motionProfile?: 'platformer' | 'projectile' | 'prop';\n\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Optional: Called after sprite is fully created and ready (onCreate + onCreatePhysics done)\n   * Fires for BOTH initial sprites and late-joining sprites\n   * Use this for inter-sprite setup (collisions, custom logic, event wiring, etc.)\n   *\n   * @example\n   * ```ts\n   * onAdd: (sprite, key, data, context) => {\n   *   // Attach particle emitter\n   *   const trail = this.add.particles(sprite.x, sprite.y, 'particle');\n   *   trail.startFollow(sprite);\n   *\n   *   // Per-sprite collision with unique object\n   *   if (this.boss) {\n   *     this.physics.add.collider(sprite, this.boss);\n   *   }\n   * }\n   * ```\n   */\n  onAdd?: (\n    sprite: any,\n    key: string,\n    data: TData,\n    context: {\n      manager: SpriteManager<TData>;\n      allSprites: Map<string, any>;\n    }\n  ) => void;\n\n  /**\n   * Optional: Keys from the initial data object to sync exactly once\n   * Useful for metadata like player roles that should be available on clients.\n   */\n  staticProperties?: (keyof TData & string)[];\n\n  /**\n   * **Unified Sync Configuration**\n   *\n   * Controls automatic property synchronization between sprites and state.\n   *\n   * @example\n   * ```ts\n   * // Default: Sync sprite → state (physics-driven, host only)\n   * sync: {\n   *   properties: ['x', 'y', 'rotation', 'alpha'],  // default\n   *   interval: 16  // ms, default (60 FPS)\n   * }\n   *\n   * // Adaptive sync: Only sync when sprite moves\n   * sync: {\n   *   properties: ['x', 'y'],\n   *   adaptive: true,  // Skip sync for idle sprites\n   *   adaptiveThreshold: 1  // pixels per frame\n   * }\n   *\n   * // State-driven: Sync state → sprite (rare, use StateDrivenSpawner instead)\n   * sync: {\n   *   properties: ['x', 'y'],\n   *   direction: 'toSprite'\n   * }\n   * ```\n   */\n  sync?: {\n    /**\n     * Properties to sync (default: ['x', 'y', 'rotation', 'alpha'])\n     */\n    properties?: string[];\n\n    /**\n     * Sync direction (default: 'toState' for SpriteManager)\n     * - 'toState': Sprite properties → State (physics-driven, host only)\n     * - 'toSprite': State properties → Sprite (state-driven, rare)\n     */\n    direction?: 'toState' | 'toSprite';\n\n    /**\n     * Sync interval in milliseconds (default: 16ms / 60 FPS)\n     */\n    interval?: number;\n\n    /**\n     * Enable adaptive sync (default: false)\n     * When true, skips sync for idle sprites (reduces bandwidth)\n     */\n    adaptive?: boolean;\n\n    /**\n     * Movement threshold for adaptive sync (default: 1 pixel/frame)\n     * Only syncs if sprite moved more than this distance\n     */\n    adaptiveThreshold?: number;\n  };\n\n\n  /**\n   * Optional label configuration. When provided, SpriteManager renders labels above sprites.\n   */\n  label?: {\n    getText: (data: TData) => string;\n    offset?: { x?: number; y?: number };\n    style?: Phaser.Types.GameObjects.Text.TextStyle;\n  };\n\n  /**\n   * Optional: Namespace for sprite data in state (default: '_sprites')\n   * Use different namespaces to prevent collisions between multiple managers\n   *\n   * @example\n   * ```ts\n   * const playerMgr = adapter.createSpriteManager({\n   *   namespace: 'players',  // → state.players.*\n   *   onCreate: ...\n   * });\n   *\n   * const enemyMgr = adapter.createSpriteManager({\n   *   namespace: 'enemies',  // → state.enemies.*\n   *   onCreate: ...\n   * });\n   * ```\n   */\n  namespace?: string;\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private spriteData = new Map<string, TData>();\n  private labels = new Map<\n    string,\n    { text: Phaser.GameObjects.Text; offset?: { x?: number; y?: number } }\n  >();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n  public readonly namespace: string;\n  private readonly effectiveSyncInterval?: number;\n\n  /**\n   * Track sprites created locally via add() method\n   * This eliminates the need to know player IDs for filtering\n   */\n  private localSprites = new Set<string>();\n\n  /**\n   * Phaser Group containing all sprites managed by this SpriteManager.\n   * Use this for collision detection:\n   * @example\n   * ```ts\n   * this.physics.add.collider(ball, playerManager.group);\n   * ```\n   *\n   * The group automatically includes all sprites added to this manager,\n   * both early-joining and late-joining, solving the \"forgot to add collider\n   * for new player\" bug.\n   */\n  public readonly group: Phaser.GameObjects.Group;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n    this.namespace = config.namespace || '_sprites';\n    const hasPhysicsManager = adapter.hasPhysicsManagedNamespace(this.namespace);\n    const motionProfile = config.motionProfile;\n    this.effectiveSyncInterval =\n      config.sync?.interval ??\n      (motionProfile === 'platformer' || hasPhysicsManager ? 13 : 13);\n\n    if (hasPhysicsManager && config.sync?.direction !== 'toSprite') {\n      console.warn(\n        `[SpriteManager] Namespace \"${this.namespace}\" is managed by PhysicsManager. ` +\n          'For platformer-style movement, set sync.direction: \"toSprite\" or disable syncPositionToState in PhysicsManager to avoid double writers.'\n      );\n    }\n\n    // Create Phaser group for collision management\n    const scene = adapter.getScene();\n    this.group = scene.add.group();\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Track that we created this sprite locally\n    this.localSprites.add(key);\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n    this.spriteData.set(key, data);\n    this.createLabel(key, data, sprite);\n\n    // Add to group for collision management\n    this.group.add(sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    if (this.config.staticProperties?.length) {\n      const staticData: Partial<TData> = {};\n      for (const prop of this.config.staticProperties) {\n        if (prop in data) {\n          staticData[prop] = data[prop];\n        }\n      }\n      if (Object.keys(staticData).length > 0) {\n        this.adapter.setSpriteStaticData(key, staticData, this.namespace);\n      }\n    }\n\n    // Track for automatic sync (host only)\n    const syncProperties = this.config.sync?.properties || ['x', 'y', 'rotation', 'alpha'];\n    const syncInterval = this.effectiveSyncInterval;\n    // Phase 1: Enable adaptive sync by default for bandwidth efficiency\n    const adaptiveSync = this.config.sync?.adaptive ?? true; // Default: true\n    const adaptiveSyncThreshold = this.config.sync?.adaptiveThreshold;\n\n    this.adapter.trackSprite(sprite, key, {\n      properties: syncProperties,\n      syncInterval: syncInterval,\n      namespace: this.namespace,\n      motionProfile: this.config.motionProfile,\n      adaptiveSync: adaptiveSync,\n      adaptiveSyncThreshold: adaptiveSyncThreshold\n    });\n\n    // Call onAdd hook (if provided)\n    if (this.config.onAdd) {\n      this.config.onAdd(sprite, key, data, {\n        manager: this,\n        allSprites: this.sprites\n      });\n    }\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n    const label = this.labels.get(key);\n    if (label) {\n      label.text.destroy();\n      this.labels.delete(key);\n    }\n    this.spriteData.delete(key);\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key, this.namespace);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   *\n   * Automatically calls update methods on attached components (arrows, health bars, etc.)\n   * if they use the `_update*` naming convention and autoUpdate is disabled.\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n    this.updateLabels();\n\n    // Auto-call attached component updates (fallback for manual mode)\n    // Note: If attachDirectionalIndicator is using autoUpdate: true (default),\n    // this is redundant but harmless. This provides backward compatibility\n    // for code that set autoUpdate: false and expects manual updates.\n    for (const sprite of this.sprites.values()) {\n      if (typeof sprite._updateArrow === 'function') {\n        sprite._updateArrow();\n      }\n      // Future: _updateHealthBar, _updateNameTag, etc.\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteData = state[this.namespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      // Skip sprites we created locally (pit of success: no player ID needed!)\n      if (this.localSprites.has(key)) {\n        continue;\n      }\n\n      if (!this.sprites.has(key)) {\n        // FIX #1: Wait for static properties before creating sprites (pit of success!)\n        // This prevents the \"sprite created before metadata arrives\" race condition.\n        // Matches the pattern used by PlayerUIManager (lines 200-207).\n        if (this.config.staticProperties?.length) {\n          const hasAllStatic = this.config.staticProperties.every(prop => prop in data);\n          if (!hasAllStatic) {\n            // Static metadata not ready yet - skip creation until next sync\n            continue;\n          }\n        }\n\n        // Create new sprite (now guaranteed to have all static properties!)\n        const sprite = this.config.onCreate(key, data as TData);\n        this.sprites.set(key, sprite);\n        this.spriteData.set(key, data as TData);\n        this.group.add(sprite); // Add to group on client side too\n        this.adapter.registerRemoteSprite(key, sprite, this.namespace);\n        this.createLabel(key, data as TData, sprite);\n\n        // Call onAdd hook (if provided) - runs for late-joining sprites on clients\n        if (this.config.onAdd) {\n          this.config.onAdd(sprite, key, data as TData, {\n            manager: this,\n            allSprites: this.sprites\n          });\n        }\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data as TData);\n        }\n        this.spriteData.set(key, data as TData);\n      }\n\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n\n  private createLabel(key: string, data: TData, sprite: any): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n\n    const scene = this.adapter.getScene();\n    if (!scene?.add?.text) return;\n\n    const textValue = labelConfig.getText(data);\n    const style = labelConfig.style || { fontSize: '12px', color: '#ffffff' };\n    const label = scene.add.text(sprite.x, sprite.y, textValue, style).setOrigin(0.5);\n    this.labels.set(key, { text: label, offset: labelConfig.offset });\n  }\n\n  private updateLabels(): void {\n    for (const key of this.labels.keys()) {\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n  }\n\n  private updateLabelText(key: string): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const data = this.spriteData.get(key);\n    if (!data) return;\n\n    const next = labelConfig.getText(data);\n    if (labelEntry.text.text !== next) {\n      labelEntry.text.setText(next);\n    }\n  }\n\n  private updateLabelPosition(key: string): void {\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    const offsetX = labelEntry.offset?.x ?? 0;\n    const offsetY = labelEntry.offset?.y ?? -20;\n    labelEntry.text.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/StateDrivenSpawner.ts": "/**\n * StateDrivenSpawner - Automatic sprite spawning from state collections\n *\n * Eliminates the manual \"check for new players/bullets\" loop in every demo.\n * Watches a state collection (e.g., state.players, state.bullets) and automatically\n * creates/removes sprites as the collection changes.\n *\n * **PIT OF SUCCESS: Positions sync from state by default!**\n * Sprites automatically follow state.x/y changes unless you opt-out.\n *\n * **NEW: Automatic physics integration!**\n * Projectiles/moving entities automatically update from velocity - no manual position updates needed!\n *\n * Usage:\n * ```ts\n * // State-driven entities (default - positions sync automatically!)\n * const blobSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'players',\n *   spriteManager: this.spriteManager,\n *   keyPrefix: 'player-'\n *   // syncProperties: ['x', 'y'] is automatic! Just mutate state and sprites follow.\n * });\n *\n * // NEW: Velocity-based movement (projectiles, moving entities)\n * const bulletSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'bullets',\n *   spriteManager: this.bulletManager,\n *   keyField: 'id',\n *   physics: {\n *     velocityFromState: { x: 'velocityX', y: 'velocityY' }\n *   }\n * });\n *\n * // In scene.update():\n * bulletSpawner.update(delta); // Automatically updates positions from velocity!\n *\n * // Physics-driven entities (opt-out of position sync)\n * const paddleSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'players',\n *   spriteManager: this.spriteManager,\n *   keyPrefix: 'player-',\n *   syncProperties: [] // Empty = physics body controls position, not state\n * });\n *\n * // Custom properties (override default)\n * const bulletSpawner = adapter.createStateDrivenSpawner({\n *   stateKey: 'bullets',\n *   spriteManager: this.bulletManager,\n *   syncProperties: ['x', 'y', 'rotation', 'alpha'] // Sync more than just position\n * });\n * ```\n *\n * This automatically:\n * - Creates sprites when new entries appear in state\n * - **Syncs x,y from state to sprites by default (opt-out with syncProperties: [])**\n * - **NEW: Updates positions from velocity automatically (opt-in with physics config)**\n * - Removes sprites when entries are deleted\n * - Works on both HOST (initial + late joins) and CLIENT (state sync)\n * - Handles arrays (bullets) and objects (players)\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PhysicsConfig {\n  /**\n   * Automatically update position from velocity in state\n   *\n   * @example\n   * ```ts\n   * velocityFromState: { x: 'velocityX', y: 'velocityY' }\n   * ```\n   *\n   * This will automatically apply:\n   * ```ts\n   * data.x += data.velocityX * deltaSeconds;\n   * data.y += data.velocityY * deltaSeconds;\n   * ```\n   */\n  velocityFromState?: { x: string; y: string };\n\n  /**\n   * Future: Acceleration support\n   * acceleration?: { x: string; y: string };\n   * friction?: number;\n   */\n}\n\nexport interface StateDrivenSpawnerConfig {\n  /**\n   * Path to the collection in state (e.g., 'players', 'bullets', 'powerUps')\n   */\n  stateKey: string;\n\n  /**\n   * The SpriteManager to spawn sprites into\n   */\n  spriteManager: SpriteManager;\n\n  /**\n   * Optional prefix for sprite keys (e.g., 'player-' → 'player-abc123')\n   */\n  keyPrefix?: string;\n\n  /**\n   * For array collections, which field to use as the unique key\n   * (e.g., 'id' for bullets)\n   * If not provided, assumes state collection is an object and uses its keys\n   */\n  keyField?: string;\n\n  /**\n   * Optional filter function - only spawn if this returns true\n   * @example\n   * ```ts\n   * filter: (data) => data.isAlive // Only spawn living entities\n   * ```\n   */\n  filter?: (data: any) => boolean;\n\n  /**\n   * **Unified Sync Configuration**\n   *\n   * Controls automatic property synchronization from state to sprites.\n   * **DEFAULT: Syncs ['x', 'y'] from state to sprites** (PIT OF SUCCESS!)\n   *\n   * @example\n   * ```ts\n   * // Default: State → Sprite position sync (automatic!)\n   * // sync: { properties: ['x', 'y'], direction: 'toSprite' }\n   *\n   * // Physics-driven: No sync (physics body controls position)\n   * sync: { properties: [] }\n   *\n   * // Custom properties\n   * sync: { properties: ['x', 'y', 'rotation', 'alpha'] }\n   * ```\n   */\n  sync?: {\n    /**\n     * Properties to sync (default: ['x', 'y'])\n     */\n    properties?: string[];\n\n    /**\n     * Sync direction (always 'toSprite' for StateDrivenSpawner)\n     */\n    direction?: 'toSprite';\n  };\n\n\n  /**\n   * Custom update function for more complex sprite syncing\n   * If provided, this takes precedence over syncProperties\n   *\n   * @example\n   * ```ts\n   * onUpdateSprite: (sprite, data) => {\n   *   sprite.x = data.x;\n   *   sprite.y = data.y;\n   *   sprite.setAlpha(data.health / 100);\n   * }\n   * ```\n   */\n  onUpdateSprite?: (sprite: any, data: any) => void;\n\n  /**\n   * **NEW: Automatic physics integration**\n   *\n   * Automatically update entity positions from velocity in state.\n   * Eliminates manual `entity.x += entity.velocityX * deltaSeconds` boilerplate.\n   *\n   * **Benefits:**\n   * - 80% less code for projectiles/moving entities\n   * - \"Pit of success\" - velocity-based movement just works\n   * - Consistent with PhysicsManager mental model\n   *\n   * @example\n   * ```ts\n   * // Simple projectiles\n   * const bulletSpawner = adapter.createStateDrivenSpawner({\n   *   stateKey: 'bullets',\n   *   spriteManager: bulletManager,\n   *   keyField: 'id',\n   *   physics: {\n   *     velocityFromState: { x: 'velocityX', y: 'velocityY' }\n   *   }\n   * });\n   *\n   * // In update loop:\n   * bulletSpawner.updatePhysics(delta); // Automatically updates positions!\n   * ```\n   */\n  physics?: PhysicsConfig;\n}\n\nexport class StateDrivenSpawner {\n  private config: StateDrivenSpawnerConfig;\n  private adapter: PhaserAdapter;\n  private trackedKeys = new Set<string>();\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: StateDrivenSpawnerConfig) {\n    this.adapter = adapter;\n\n    // PIT OF SUCCESS: Default to syncing positions from state\n    if (!config.sync?.properties && !config.onUpdateSprite) {\n      // Default: sync x,y from state to sprites\n      config.sync = { properties: ['x', 'y'], direction: 'toSprite' };\n    }\n\n    this.config = config;\n\n    // HOST: Poll state every update to spawn new entries\n    // CLIENT: React to state changes via onChange\n    if (adapter.isHost()) {\n      // Host checks state directly (no onChange subscription needed)\n      // Just need to call update() from scene\n    } else {\n      // Client subscribes to state changes\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Call this in scene.update() (HOST ONLY)\n   * Checks for new entries in the state collection and spawns sprites\n   *\n   * @param delta - Optional delta time in milliseconds for physics updates\n   *\n   * @example\n   * ```ts\n   * update(time: number, delta: number) {\n   *   // Without physics: just sync spawning/despawning\n   *   spawner.update();\n   *\n   *   // With physics: update positions from velocity\n   *   spawner.update(delta);\n   * }\n   * ```\n   */\n  update(delta?: number): void {\n    if (!this.adapter.isHost()) {\n      return; // Client uses onChange subscription instead\n    }\n\n    // Update physics before syncing (so new positions are synced)\n    if (delta !== undefined && this.config.physics) {\n      this.updatePhysics(delta);\n    }\n\n    const state = this.adapter.getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * **NEW: Automatic physics updates**\n   *\n   * Updates entity positions from velocity in state.\n   * Call this in your scene.update() with delta time.\n   *\n   * **Only runs on HOST** - clients receive position updates via state sync.\n   *\n   * @param delta - Delta time in milliseconds\n   *\n   * @example\n   * ```ts\n   * update(time: number, delta: number) {\n   *   bulletSpawner.updatePhysics(delta);\n   *   bulletSpawner.update(); // Sync sprites to new positions\n   * }\n   * ```\n   */\n  updatePhysics(delta: number): void {\n    if (!this.adapter.isHost()) {\n      return; // Only host updates physics - clients get state sync\n    }\n\n    if (!this.config.physics?.velocityFromState) {\n      return; // No physics config\n    }\n\n    const state = this.adapter.getState();\n    const collection = state[this.config.stateKey];\n    if (!collection) return;\n\n    const deltaSeconds = delta / 1000;\n    const { x: velXKey, y: velYKey } = this.config.physics.velocityFromState;\n\n    // Determine if collection is array or object\n    const isArray = Array.isArray(collection);\n\n    // Extract entries\n    const entries: Array<[string, any]> = isArray\n      ? collection.map((item: any) => {\n          const key = this.config.keyField ? item[this.config.keyField] : item.id;\n          return [String(key), item];\n        })\n      : Object.entries(collection);\n\n    // Update positions from velocity\n    for (const [_, data] of entries) {\n      // Apply filter if provided\n      if (this.config.filter && !this.config.filter(data)) {\n        continue;\n      }\n\n      // Check if velocity properties exist in state\n      if (velXKey in data && velYKey in data) {\n        // Update position from velocity\n        // Initialize position if missing\n        if (!('x' in data)) data.x = 0;\n        if (!('y' in data)) data.y = 0;\n\n        data.x += data[velXKey] * deltaSeconds;\n        data.y += data[velYKey] * deltaSeconds;\n      }\n    }\n  }\n\n  /**\n   * Manually trigger a sync (useful for initial spawn in create())\n   */\n  sync(): void {\n    const state = this.adapter.getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Core sync logic - creates/removes sprites based on state\n   */\n  private syncFromState(state: any): void {\n    const collection = state[this.config.stateKey];\n    if (!collection) return;\n\n    const currentKeys = new Set<string>();\n\n    // Determine if collection is array or object\n    const isArray = Array.isArray(collection);\n\n    // Extract entries\n    const entries: Array<[string, any]> = isArray\n      ? collection.map((item: any) => {\n          const key = this.config.keyField ? item[this.config.keyField] : item.id;\n          return [String(key), item];\n        })\n      : Object.entries(collection);\n\n    // Create/update sprites for entries\n    for (const [rawKey, data] of entries) {\n      // Apply filter if provided\n      if (this.config.filter && !this.config.filter(data)) {\n        continue;\n      }\n\n      const spriteKey = this.config.keyPrefix ? `${this.config.keyPrefix}${rawKey}` : rawKey;\n      currentKeys.add(spriteKey);\n\n      // If sprite already exists, update its properties\n      if (this.trackedKeys.has(spriteKey)) {\n        this.updateSpriteFromState(spriteKey, data);\n        continue;\n      }\n\n      // Create sprite (only on HOST - SpriteManager handles client sync)\n      if (this.adapter.isHost()) {\n        this.config.spriteManager.add(spriteKey, data);\n        this.trackedKeys.add(spriteKey);\n      } else {\n        // On client, just track that we've seen it (SpriteManager creates it via state sync)\n        this.trackedKeys.add(spriteKey);\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const spriteKey of this.trackedKeys) {\n      if (!currentKeys.has(spriteKey)) {\n        this.config.spriteManager.remove(spriteKey);\n        this.trackedKeys.delete(spriteKey);\n      }\n    }\n  }\n\n  /**\n   * Update sprite properties from state data\n   * Only runs on HOST (clients get updates via SpriteManager sync)\n   */\n  private updateSpriteFromState(spriteKey: string, data: any): void {\n    // Only update on host - clients rely on SpriteManager's automatic sync\n    if (!this.adapter.isHost()) {\n      return;\n    }\n\n    const sprite = this.config.spriteManager.get(spriteKey);\n    if (!sprite) return;\n\n    // Custom update function takes precedence\n    if (this.config.onUpdateSprite) {\n      this.config.onUpdateSprite(sprite, data);\n      return;\n    }\n\n    // Sync properties using unified API\n    const syncProperties = this.config.sync?.properties;\n    if (syncProperties) {\n      for (const prop of syncProperties) {\n        if (prop in data && sprite[prop] !== undefined) {\n          sprite[prop] = data[prop];\n        }\n      }\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    this.unsubscribe?.();\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/index.ts": "/**\n * @martini-kit/phaser - Phaser 3 adapter for multiplayer games\n *\n * Provides high-level helpers for syncing sprites and handling multiplayer in Phaser.\n *\n * @packageDocumentation\n */\n\nexport { PhaserAdapter } from './PhaserAdapter.js';\nexport type { SpriteTrackingOptions, PhaserAdapterConfig } from './PhaserAdapter.js';\n\n// Helpers\nexport { SpriteManager } from './helpers/SpriteManager.js';\nexport type { SpriteManagerConfig, SpriteData } from './helpers/SpriteManager.js';\nexport { InputManager } from './helpers/InputManager.js';\nexport type { ActionBinding, KeyBinding, KeyBindings, CursorBindings } from './helpers/InputManager.js';\nexport { PhysicsManager } from './helpers/PhysicsManager.js';\nexport type { PhysicsManagerConfig, PlatformerBehaviorConfig, TopDownBehaviorConfig, RacingBehaviorConfig, CustomBehaviorConfig } from './helpers/PhysicsManager.js';\nexport { CollisionManager } from './helpers/CollisionManager.js';\nexport type { CollisionManagerConfig, CollisionRule } from './helpers/CollisionManager.js';\nexport { PlayerUIManager } from './helpers/PlayerUIManager.js';\nexport type { PlayerUIManagerConfig, TextUIConfig, BarUIConfig } from './helpers/PlayerUIManager.js';\nexport { StateDrivenSpawner } from './helpers/StateDrivenSpawner.js';\nexport type { StateDrivenSpawnerConfig } from './helpers/StateDrivenSpawner.js';\nexport { HealthBarManager } from './helpers/HealthBarManager.js';\nexport type { HealthBarConfig } from './helpers/HealthBarManager.js';\nexport { GridClickHelper } from './helpers/GridClickHelper.js';\nexport type { GridClickConfig } from './helpers/GridClickHelper.js';\nexport { GridCollisionManager, GridMovementManager } from './helpers/GridCollisionManager.js';\nexport type { GridCollisionConfig, GridMovementConfig, GridEntity, MovementInput, GridPosition } from './helpers/GridCollisionManager.js';\nexport { GridLockedMovementManager } from './helpers/GridLockedMovementManager.js';\nexport type { GridLockedMovementConfig, GridLockedEntity } from './helpers/GridLockedMovementManager.js';\n\n// Input Profiles\nexport { registerProfile, getProfile, listProfiles, BUILT_IN_PROFILES } from './helpers/InputProfiles.js';\nexport type { InputProfile, ProfileOptions } from './helpers/InputProfiles.js';\n\n// HUD Helper\nexport { createPlayerHUD } from './helpers/HUDHelper.js';\nexport type { PlayerHUD, PlayerHUDConfig, HUDLayout, HUDTextStyle } from './helpers/HUDHelper.js';\n\n// Player Stats Panel Helper\nexport { createPlayerStatsPanel } from './helpers/PlayerStatsPanel.js';\nexport type { PlayerStatsPanel, PlayerStatsPanelConfig, StatConfig, StatPosition } from './helpers/PlayerStatsPanel.js';\n\n// Collectible Manager Helper\nexport { createCollectibleManager } from './helpers/CollectibleManager.js';\nexport type { CollectibleManager, CollectibleManagerConfig, CollectibleConfig, CollisionType } from './helpers/CollectibleManager.js';\n\n// Round Manager Helper\nexport { createRoundManager } from './helpers/RoundManager.js';\nexport type { RoundManager, RoundManagerConfig, TimerUIConfig, AnnouncementUIConfig, ScoreboardUIConfig } from './helpers/RoundManager.js';\n\n\n// Speed Display Helper\nexport { createSpeedDisplay } from './helpers/SpeedDisplay.js';\nexport type { SpeedDisplay, SpeedDisplayConfig } from './helpers/SpeedDisplay.js';\n\n// Sprite Attachment System (Generic)\nexport { createSpriteAttachment, createSpriteAttachments, createCompositeAttachment } from './helpers/SpriteAttachment.js';\nexport type { SpriteAttachment, SpriteAttachmentConfig } from './helpers/SpriteAttachment.js';\n\n// Directional Indicator Helper\nexport { attachDirectionalIndicator } from './helpers/DirectionalIndicator.js';\nexport type { DirectionalIndicator, DirectionalIndicatorConfig } from './helpers/DirectionalIndicator.js';\n\n// Camera Follower Helper\nexport { createCameraFollower } from './helpers/CameraFollower.js';\nexport type { CameraFollower, CameraFollowerConfig, CameraFollowerTarget } from './helpers/CameraFollower.js';\n\n// Dual Runtime Factory\nexport { createDualRuntimePreview } from './helpers/DualRuntimeFactory.js';\nexport type { DualRuntimePreview, DualRuntimePreviewConfig } from './helpers/DualRuntimeFactory.js';\n\n// Runtime initialization (transport abstraction)\nexport { initializeGame } from './runtime.js';\nexport type { MartiniKitConfig, GameConfig } from './runtime.js';\n\n// Re-export core types for convenience\nexport type { GameDefinition, Transport, GameRuntime } from '@martini-kit/core';\n",
  "/node_modules/@martini-kit/phaser/runtime.ts": "/**\n * @martini-kit/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\nimport { TrysteroTransport } from '@martini-kit/transport-trystero';\nimport { IframeBridgeTransport } from '@martini-kit/transport-iframe-bridge';\nimport type { Transport } from '@martini-kit/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniKitConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n    rtcConfig?: RTCConfiguration; // For Trystero\n    relayUrls?: string[]; // For Trystero\n  };\n\n  /**\n   * Minimum players required before starting the game loop/rendering.\n   * Useful for P2P transports where peers join asynchronously.\n   */\n  minPlayers?: number;\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\ntype CleanupHandle = () => void;\n\nconst GLOBAL_GAME_KEY = '__martini-kit_CURRENT_GAME__';\n\nfunction getExistingCleanup(): CleanupHandle | null {\n  if (typeof globalThis === 'undefined') return null;\n  const existing = (globalThis as any)[GLOBAL_GAME_KEY];\n  return typeof existing?.cleanup === 'function' ? existing.cleanup : null;\n}\n\nfunction setGlobalCleanup(cleanup: CleanupHandle): void {\n  if (typeof globalThis === 'undefined') return;\n  (globalThis as any)[GLOBAL_GAME_KEY] = { cleanup };\n}\n\nfunction clearGlobalCleanup(): void {\n  if (typeof globalThis === 'undefined') return;\n  delete (globalThis as any)[GLOBAL_GAME_KEY];\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini-kit/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport async function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): Promise<{ runtime: GameRuntime<TState>; phaser: Phaser.Game }> {\n  const hot = typeof import.meta !== 'undefined' ? (import.meta as any).hot : undefined;\n\n  // During HMR, ensure any prior game instance is cleaned up before creating a new one\n  const previousCleanup = getExistingCleanup();\n  if (previousCleanup) {\n    previousCleanup();\n  }\n\n  // Fallback: if a transport is still registered globally (e.g., HMR edge), disconnect it\n  const leakedTransport = (globalThis as any)['__martini-kit_TRANSPORT__'];\n  if (leakedTransport) {\n    console.debug('[Martini] Found leaked transport, cleaning up...', leakedTransport);\n    if (typeof leakedTransport.disconnect === 'function') {\n      leakedTransport.disconnect();\n    } else if (typeof leakedTransport.destroy === 'function') {\n      leakedTransport.destroy();\n    }\n    // Force clear the global to ensure it's gone\n    delete (globalThis as any)['__martini-kit_TRANSPORT__'];\n    console.debug('[Martini] Transport cleanup complete, global cleared');\n  }\n\n  // Read platform-injected config\n  const platformConfig = (window as any)['__martini-kit_CONFIG__'] as MartiniKitConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __martini-kit_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Wait for transport readiness (important for P2P host discovery)\n  if (typeof (transport as any).waitForReady === 'function') {\n    await (transport as any).waitForReady();\n  }\n\n  // Seed only self; peers will be added via onPeerJoin to avoid double-seeding/ordering bugs\n  const initialPlayerIds = [transport.getPlayerId()];\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: initialPlayerIds\n    }\n  );\n\n  // Optionally wait for minimum players before continuing\n  const minPlayers = platformConfig.minPlayers && platformConfig.minPlayers > 0 ? platformConfig.minPlayers : 1;\n  if (minPlayers > 1) {\n    try {\n      await runtime.waitForPlayers(minPlayers, { timeoutMs: 10000 });\n    } catch (err) {\n      console.warn('[Martini] waitForPlayers timed out:', err);\n    }\n  }\n\n  // Resolve Phaser from import or global (Sandpack can fail to hydrate default import)\n  const PhaserLib = Phaser ?? (typeof window !== 'undefined' ? (window as any).Phaser : undefined);\n  if (!PhaserLib) {\n    throw new Error('Phaser failed to load. Ensure the Phaser script is available in the sandbox.');\n  }\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: PhaserLib.Scale.FIT,\n    autoCenter: PhaserLib.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  // Default input configuration ensures pointer/mouse/touch events work\n  // especially when running inside iframes (IDE environment)\n  const defaultInput = {\n    activePointers: 3 // Enable mouse + 2 touch pointers by default\n  };\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: PhaserLib.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    input: defaultInput,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  const phaserGame = new PhaserLib.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any)['__martini-kit_IDE__']) {\n    (window as any)['__martini-kit_IDE__'].registerRuntime(runtime);\n  }\n\n  const disconnectTransport = () => {\n    if ('disconnect' in transport && typeof (transport as any).disconnect === 'function') {\n      (transport as any).disconnect();\n    } else if ('destroy' in transport && typeof (transport as any).destroy === 'function') {\n      (transport as any).destroy();\n    }\n  };\n\n  const handleIdeDisconnect = (event: MessageEvent) => {\n    if (event.data?.type === 'martini-kit:transport:disconnect') {\n      disconnectTransport();\n    }\n  };\n\n  const handleBeforeUnload = () => {\n    disconnectTransport();\n  };\n\n  // Auto-cleanup: Disconnect transport when navigating away\n  // Two mechanisms for defense-in-depth:\n  // 1. Message from parent (IDE-initiated cleanup)\n  // 2. beforeunload event (direct browser navigation)\n  if (typeof window !== 'undefined') {\n    // Listen for IDE cleanup message\n    window.addEventListener('message', handleIdeDisconnect);\n\n    // Fallback: Disconnect on browser navigation/close\n    window.addEventListener('beforeunload', handleBeforeUnload);\n  }\n\n  let cleanedUp = false;\n  const cleanup = () => {\n    if (cleanedUp) return;\n    cleanedUp = true;\n\n    clearGlobalCleanup();\n\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('message', handleIdeDisconnect);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    }\n\n    runtime.destroy();\n    disconnectTransport();\n    phaserGame.destroy(true);\n  };\n\n  setGlobalCleanup(cleanup);\n\n  if (hot?.dispose) {\n    hot.dispose(() => {\n      cleanup();\n    });\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniKitConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'trystero':\n      return new TrysteroTransport({\n        appId: config.appId || 'martini-kit',\n        roomId: config.roomId,\n        isHost: config.isHost,\n        rtcConfig: config.rtcConfig,\n        relayUrls: config.relayUrls\n      });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local', 'iframe-bridge', and 'trystero' are supported in IDE mode.`);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/package.json": "{\n  \"name\": \"@martini-kit/phaser\",\n  \"version\": \"0.1.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}"
}