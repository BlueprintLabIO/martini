{
  "__metadata": {
    "version": "2.0.0-alpha.1",
    "gitSha": "aaf8286986fdd233c574cdee625d8c52f09f1caf",
    "gitBranch": "main",
    "buildTime": "2025-11-14T08:34:50.969Z"
  },
  "/node_modules/@martini-kit/phaser/PhaserAdapter.ts": "/**\n * PhaserAdapter - Bridge between Phaser and @martini-kit/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini-kit/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 50ms / 20 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Interpolate movement on clients for smoothness */\n  interpolate?: boolean;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Enable automatic interpolation for remote sprites (default: true)\n   * When enabled, remote sprites smoothly lerp to target positions\n   */\n  autoInterpolate?: boolean;\n\n  /**\n   * Interpolation lerp factor (default: 0.3)\n   * Lower = smoother but laggier, Higher = snappier but jerkier\n   * Range: 0.1 (very smooth) to 0.5 (very snappy)\n   */\n  lerpFactor?: number;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   autoInterpolate: true,           // optional, defaults to true\n *   lerpFactor: 0.3                  // optional, defaults to 0.3\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<string, { sprite: any; options: SpriteTrackingOptions }> = new Map();\n  private remoteSprites: Map<string, any> = new Map(); // Sprites created for remote players\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly autoInterpolate: boolean;\n  private readonly lerpFactor: number;\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.autoInterpolate = config.autoInterpolate !== false; // default true\n    this.lerpFactor = config.lerpFactor ?? 0.3;\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, { sprite, options });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 50;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // Note: We do NOT immediately sync here to avoid infinite loops\n    // when trackSprite is called inside onChange callbacks.\n    // The interval-based sync will handle the first sync.\n  }\n\n  /**\n   * Stop tracking a sprite\n   */\n  untrackSprite(key: string): void {\n    this.trackedSprites.delete(key);\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[this.spriteNamespace];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, { sprite, options }] of this.trackedSprites.entries()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n      const sprites = state[this.spriteNamespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   */\n  private updateSpritesFromState(state: any): void {\n    const sprites = state[this.spriteNamespace];\n    if (this.isHost() || !sprites) return;\n\n    // Update tracked sprites (sprites that exist on this client)\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const spriteData = sprites[key];\n      if (spriteData) {\n        this.applySpriteData(tracked.sprite, spriteData);\n      }\n    }\n\n    // Update remote sprites (sprites from other players)\n    // Store target positions for interpolation\n    for (const [key, spriteData] of Object.entries(sprites)) {\n      // Skip if this is our own sprite\n      if (this.trackedSprites.has(key)) continue;\n\n      // If we have a remote sprite for this key, store target position\n      const remoteSprite = this.remoteSprites.get(key);\n      if (remoteSprite) {\n        // Store target position for smooth interpolation\n        remoteSprite._targetX = (spriteData as any).x;\n        remoteSprite._targetY = (spriteData as any).y;\n        remoteSprite._targetRotation = (spriteData as any).rotation;\n\n        // First update - snap to position immediately\n        if (remoteSprite._targetX !== undefined && remoteSprite.x === undefined) {\n          remoteSprite.x = remoteSprite._targetX;\n          remoteSprite.y = remoteSprite._targetY;\n          remoteSprite.rotation = remoteSprite._targetRotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any): void {\n    this.remoteSprites.set(key, sprite);\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Note: If autoInterpolate is enabled in config, you don't need to call this manually.\n   */\n  updateInterpolation(): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    for (const [key, sprite] of this.remoteSprites.entries()) {\n      if (sprite._targetX !== undefined) {\n        // Lerp towards target position\n        sprite.x += (sprite._targetX - sprite.x) * this.lerpFactor;\n        sprite.y += (sprite._targetY - sprite.y) * this.lerpFactor;\n\n        if (sprite._targetRotation !== undefined) {\n          sprite.rotation += (sprite._targetRotation - sprite.rotation) * this.lerpFactor;\n        }\n      }\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const sprite = this.remoteSprites.get(key);\n    if (sprite && sprite.destroy) {\n      sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    return new SpriteManager(this, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/InputManager.ts": "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini-kit/core';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    console.log('[InputManager] bindKeys called with:', bindings);\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n      console.log(`[InputManager] Registered key: ${key.toUpperCase()}`, normalized);\n    }\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          console.log(`[InputManager] Key pressed (oneshot): ${key}`, binding);\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          console.log(`[InputManager] Key held (continuous): ${key}`, binding);\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            console.log(`[InputManager] Cursor pressed (oneshot):`, normalized);\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            console.log(`[InputManager] Cursor held (continuous):`, normalized);\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    console.log(`[InputManager] submitAction('${binding.action}', ${JSON.stringify(binding.input)}, ${binding.targetId || 'self'})`);\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/helpers/SpriteManager.ts": "/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Properties to sync (default: x, y, rotation, alpha)\n   */\n  syncProperties?: string[];\n\n  /**\n   * Sync interval in ms (default: 50ms / 20 FPS)\n   */\n  syncInterval?: number;\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    // Track for automatic sync (host only)\n    this.adapter.trackSprite(sprite, key, {\n      properties: this.config.syncProperties || ['x', 'y', 'rotation', 'alpha'],\n      syncInterval: this.config.syncInterval\n    });\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteNamespace = (this.adapter as any).spriteNamespace || '_sprites';\n    const spriteData = state[spriteNamespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      if (!this.sprites.has(key)) {\n        // Create new sprite\n        const sprite = this.config.onCreate(key, data);\n        this.sprites.set(key, sprite);\n        this.adapter.registerRemoteSprite(key, sprite);\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data);\n        }\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/index.ts": "/**\n * @martini-kit/phaser - Phaser 3 adapter for multiplayer games\n *\n * Provides high-level helpers for syncing sprites and handling multiplayer in Phaser.\n *\n * @packageDocumentation\n */\n\nexport { PhaserAdapter } from './PhaserAdapter.js';\nexport type { SpriteTrackingOptions, PhaserAdapterConfig } from './PhaserAdapter.js';\n\n// Helpers\nexport { SpriteManager } from './helpers/SpriteManager.js';\nexport type { SpriteManagerConfig, SpriteData } from './helpers/SpriteManager.js';\nexport { InputManager } from './helpers/InputManager.js';\nexport type { ActionBinding, KeyBinding, KeyBindings, CursorBindings } from './helpers/InputManager.js';\n\n// Runtime initialization (transport abstraction)\nexport { initializeGame } from './runtime.js';\nexport type { martini-kitConfig, GameConfig } from './runtime.js';\n\n// Re-export core types for convenience\nexport type { GameDefinition, Transport, GameRuntime } from '@martini-kit/core';\n",
  "/node_modules/@martini-kit/phaser/runtime.ts": "/**\n * @martini-kit/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini-kit/core';\nimport { LocalTransport } from '@martini-kit/transport-local';\n// import { TrysteroTransport } from '@martini-kit/transport-trystero'; // Disabled for IDE\nimport { IframeBridgeTransport } from '@martini-kit/transport-iframe-bridge';\nimport type { Transport } from '@martini-kit/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface martini-kitConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n  };\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini-kit/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): { runtime: GameRuntime<TState>; phaser: Phaser.Game } {\n  // Read platform-injected config\n  const platformConfig = (window as any).__martini-kit_CONFIG__ as martini-kitConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __martini-kit_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: [transport.getPlayerId()]\n    }\n  );\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  console.log('ðŸ”¥ðŸ”¥ðŸ”¥ [martini-kit] Applying Phaser scale config:', defaultScale);\n  console.log('ðŸ”¥ðŸ”¥ðŸ”¥ [martini-kit] Scale mode:', defaultScale.mode, '(2 = FIT, 0 = NONE)');\n  alert('Phaser Scale Config Applied! Mode: ' + defaultScale.mode);\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  console.log('[martini-kit] Final Phaser config:', phaserConfig);\n  console.log('[martini-kit] Final scale mode:', phaserConfig.scale?.mode);\n\n  const phaserGame = new Phaser.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any).__martini-kit_IDE__) {\n    (window as any).__martini-kit_IDE__.registerRuntime(runtime);\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: martini-kitConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    // case 'trystero':\n    //   return new TrysteroTransport({\n    //     appId: config.appId || 'martini-kit',\n    //     roomId: config.roomId,\n    //     isHost: config.isHost\n    //   });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local' and 'iframe-bridge' are supported in IDE mode.`);\n  }\n}\n",
  "/node_modules/@martini-kit/phaser/package.json": "{\n  \"name\": \"@martini-kit/phaser\",\n  \"version\": \"2.0.0-alpha.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}"
}