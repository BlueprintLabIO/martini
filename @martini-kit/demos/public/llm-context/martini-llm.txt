# martini-kit Multiplayer Game Framework - Complete Reference

**Version:** 2.0
**Last Updated:** 2025-01-19
**Purpose:** Complete API reference for AI assistants and developers

---

## Table of Contents

1. [Installation & Setup](#installation--setup)
2. [Core Concepts](#core-concepts)
3. [State Management & Game Definition](#state-management--game-definition)
4. [Actions & Input](#actions--input)
5. [GameRuntime API](#gameruntime-api)
6. [Transport Layer](#transport-layer)
7. [Phaser Integration Basics](#phaser-integration-basics)
8. [Helper System - Recommended Approach](#helper-system---recommended-approach)
9. [Manual Approach - Advanced](#manual-approach---advanced)
10. [Best Practices & Patterns](#best-practices--patterns)
11. [Common Recipes](#common-recipes)
12. [TypeScript Interfaces Reference](#typescript-interfaces-reference)
13. [Troubleshooting](#troubleshooting)

---

## Installation & Setup

### Basic Setup

```bash
pnpm add @martini-kit/core @martini-kit/phaser @martini-kit/transport-local phaser
```

### Project Structure

```
src/
  game.ts         # GameDefinition (state + actions)
  scene.ts        # Phaser Scene with PhaserAdapter
  main.ts         # Initialization
index.html        # Entry point
```

### TypeScript Config

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true
  }
}
```

---

## Core Concepts

### Host-Authoritative Architecture

martini-kit uses a **host-authoritative** model:

1. **Host** (server): Runs game logic, applies actions, owns state
2. **Clients** (players): Submit actions, receive state updates, render

```
Player Input → Client → Host → State Update → Broadcast → All Clients
```

**Key Rule:** Only the host modifies state. Clients are read-only.

### State Synchronization

martini-kit automatically:
- Detects state changes (JSON-Patch algorithm)
- Broadcasts minimal diffs to clients
- Applies patches in-order
- Handles late joins (send full state)

### Determinism

State changes are deterministic - same inputs + same initial state = same output.

This enables:
- Replay/rewind during development
- Consistent physics across all clients
- Bug reproducibility

---

## State Management & Game Definition

### defineGame API

```typescript
import { defineGame } from '@martini-kit/core';

const game = defineGame<GameState>({
  // Called once on game start to initialize state
  setup: ({ playerIds }) => ({
    players: {},
    inputs: {},
    gameOver: false
  }),

  // Actions that modify state
  actions: {
    // Action name as key
    move: {
      // Called on host to apply action to state
      apply: (state, context, input: { x: number; y: number }) => {
        const player = state.players[context.targetId];
        if (player) {
          player.x = input.x;
          player.y = input.y;
        }
      }
    }
  },

  // Called when player joins mid-game
  onPlayerJoin: (state, playerId) => {
    state.players[playerId] = {
      x: 400,
      y: 300,
      score: 0
    };
  },

  // Called when player disconnects
  onPlayerLeave: (state, playerId) => {
    delete state.players[playerId];
  }
});
```

### GameState Interface

```typescript
interface GameState {
  // All networked data goes here
  players: Record<string, PlayerData>;
  ball?: BallData;
  inputs: Record<string, InputData>;
  gameOver?: boolean;
}
```

**Rules:**
- ✅ Supports: primitives, objects, arrays, nested structures
- ❌ Don't use: Functions, Symbols, Sets, Maps (not JSON-serializable)
- ✅ Can have optional fields (use `?`)
- ✅ Must be JSON-serializable

### ActionContext

```typescript
interface ActionContext {
  // The player who submitted this action
  playerId: string;

  // Target player (set via submitAction's 3rd parameter)
  // Defaults to playerId if not specified
  targetId: string;

  // Game tick number
  tick: number;
}
```

---

## Actions & Input

### Submitting Actions (from Client/Host)

```typescript
// Basic action
runtime.submitAction('move', { x: 100, y: 200 });

// Action targeted at another player (e.g., "give points to player 2")
runtime.submitAction('award_points', { amount: 10 }, playerIdOfWinner);

// Return value (async)
runtime.submitAction('attack', { targetId: '123' }).then(result => {
  console.log('Action processed');
});
```

### Action Naming

- Use snake_case: `move`, `jump`, `shoot`, `spawn_enemy`
- Avoid keywords: `update`, `apply`, `init`
- Descriptive: `award_points` not `give`, `take_damage` not `hit`

### targetId Parameter

The **third parameter** in `submitAction` specifies which player is affected:

```typescript
// Reward the winner
runtime.submitAction('score', undefined, winnerId);

// Penalty for a specific player
runtime.submitAction('take_damage', { amount: 10 }, targetPlayerId);

// If omitted, defaults to submitting player
runtime.submitAction('move', { x: 100 }); // affects context.targetId (submitter)
```

---

## GameRuntime API

### Creating a Runtime

```typescript
import { GameRuntime } from '@martini-kit/core';
import { LocalTransport } from '@martini-kit/transport-local';

const transport = new LocalTransport({
  roomId: 'my-game-room',
  isHost: true
});

const runtime = new GameRuntime(game, transport, {
  isHost: transport.isHost(),
  playerIds: [transport.getPlayerId()]
});
```

### Core Methods

```typescript
// Get current game state
const state = runtime.getState();

// Submit an action
runtime.submitAction('move', { x: 100, y: 200 });

// Get runtime info
runtime.getPlayerId();          // My player ID
runtime.isHost();               // Am I the host?
runtime.getConnectedPlayers();  // List of player IDs
runtime.getTick();              // Current game tick

// Listen to state changes
runtime.onStateChange((newState, patches) => {
  console.log('State changed:', patches);
});

// Destroy and cleanup
runtime.destroy();
```

### Runtime Config

```typescript
interface GameRuntimeConfig {
  isHost: boolean;
  playerIds: string[];
  maxPlayers?: number;
  tickRate?: number;  // Default: 60
  doDiffOptimization?: boolean;  // Default: true
}
```

---

## Transport Layer

### What is Transport?

Transport handles **networking**:
- Sending/receiving messages
- Detecting disconnections
- Reconnection logic
- Player lifecycle

martini-kit provides several transports:

### LocalTransport (Testing Only)

```typescript
import { LocalTransport } from '@martini-kit/transport-local';

const transport = new LocalTransport({
  roomId: 'my-room',
  isHost: true  // True = host, false = client
});

// Open two tabs with same roomId:
// Tab 1: isHost=true
// Tab 2: isHost=false
```

**Use case:** Local development, testing with multiple browser tabs

### IframeBridgeRelay (Embedded Games)

```typescript
import { IframeBridgeRelay } from '@martini-kit/transport-iframe-bridge';

const transport = new IframeBridgeRelay({
  roomId: 'game-123',
  targetOrigin: 'https://your-domain.com',
  isHost: window.parent !== window  // Host = parent frame
});
```

**Use case:** Embedding games in websites (iframe/Codepen style)

### Custom Transport

```typescript
import type { Transport, WireMessage } from '@martini-kit/core';

class MyTransport implements Transport {
  private callbacks: Map<string, (msg: WireMessage) => void> = new Map();

  isHost(): boolean {
    // Return true if this client is the host
    return true;
  }

  getPlayerId(): string {
    // Return unique player ID
    return 'player-' + Math.random();
  }

  on(event: 'message' | 'disconnect', callback: (data: any) => void) {
    this.callbacks.set(event, callback);
  }

  send(message: WireMessage) {
    // Send to remote host/players
    // Call this.callbacks.get('message')?.(incomingMessage)
  }
}
```

---

## Phaser Integration Basics

### PhaserAdapter

```typescript
import { PhaserAdapter } from '@martini-kit/phaser';
import Phaser from 'phaser';

export function createScene(runtime: GameRuntime) {
  return class MyScene extends Phaser.Scene {
    private adapter!: PhaserAdapter;

    create() {
      // Initialize adapter (connects martini-kit to Phaser)
      this.adapter = new PhaserAdapter(runtime, this);

      // Now use helpers or manual tracking
    }

    update() {
      // Keep it clean - helpers call update() in here
    }
  };
}
```

### Adapter Core Methods

```typescript
// Track a sprite (host only usually)
this.adapter.trackSprite(sprite, 'unique-key');

// Register remote sprite (clients)
this.adapter.registerRemoteSprite('key', sprite);

// Get current player ID
const myId = this.adapter.playerId;

// Check if this is host
if (this.adapter.isHost()) {
  // Run host logic
}

// Listen to state changes
this.adapter.onChange((newState) => {
  console.log('State changed');
});

// Get current state
const state = this.adapter.getState();
```

---

## Helper System - Recommended Approach

### Why Helpers?

| Feature | Manual | Helper |
|---------|--------|--------|
| Lines of code | 450+ | 150+ |
| Sprite sync | Manual tracking | Automatic |
| Input handling | Keyboard listeners | Profile-based |
| Physics | Manual Arcade | Behavior-based |
| HUD | Manual text objects | Built-in |
| Late joins | Must handle explicitly | Automatic |
| Interpolation | Manual lerp | Automatic |

**Recommendation:** Use helpers for 90% of games.

### SpriteManager

Automatically syncs sprites between host and clients.

```typescript
const spriteManager = this.adapter.createSpriteManager({
  // Static metadata (synced once on creation)
  staticProperties: ['role', 'team', 'color'],

  // Optional: built-in sprite labels
  label: {
    getText: (data) => data.role === 'fire' ? 'Fire' : 'Ice',
    offset: { y: -30 },
    style: { fontSize: '12px', color: '#fff' }
  },

  // Create visual sprite
  onCreate: (key: string, data: any) => {
    const color = data.role === 'fire' ? 0xff0000 : 0x0000ff;
    return this.add.circle(data.x, data.y, 20, color);
  },

  // Setup physics (host + clients)
  onCreatePhysics: (sprite: any) => {
    this.physics.add.existing(sprite);
    sprite.body.setCollideWorldBounds(true);
  },

  // Optional: called every frame with latest state
  onUpdate: (sprite: any, data: any) => {
    // Sprite position already synced automatically
    // Use this for custom visual updates
  }
});

// Add sprite (host side, in setup or onPlayerJoin)
spriteManager.add('player-123', { x: 100, y: 200, role: 'fire' });

// Get sprite by key
const sprite = spriteManager.get('player-123');

// Remove sprite
spriteManager.remove('player-123');

// Update (in scene.update)
spriteManager.update();
```

**Key Features:**
- ✅ Automatic synchronization
- ✅ Smooth interpolation
- ✅ Built-in labels
- ✅ Physics setup via callback
- ✅ Handles late joins automatically

### InputManager

Simplifies keyboard + pointer input.

```typescript
const inputManager = this.adapter.createInputManager();

// Use preset profiles
inputManager.useProfile('platformer');  // up/down/left/right + jump
inputManager.useProfile('topdown');      // up/down/left/right
inputManager.useProfile('racing');       // forward/back/left/right
inputManager.useProfile('topdown_shooter'); // movement + aim + shoot

// Custom keybindings
inputManager.bindKeys('move', {
  left: 'A',
  right: 'D',
  up: 'W',
  down: 'S'
});

inputManager.bindKeys('action', {
  jump: 'SPACE',
  dash: 'E'
});

// In update()
inputManager.update();

// Get input state
const state = inputManager.getState();
if (state.move.left) {
  // Player pressing A
}

// Submit input as action
runtime.submitAction('move', {
  up: state.move.up || false,
  down: state.move.down || false,
  left: state.move.left || false,
  right: state.move.right || false
});
```

**Built-in Profiles:**
- `platformer`: WASD/Arrows + Space (jump)
- `topdown`: WASD/Arrows (4-direction movement)
- `racing`: WASD/Arrows (forward/back/left/right)
- `topdown_shooter`: WASD movement + Mouse aim + Space/Click shoot

### PhysicsManager

Automates physics behaviors.

```typescript
const physicsManager = this.adapter.createPhysicsManager({
  spriteManager,      // Required
  inputKey: 'inputs'  // State key with input data
});

// Platformer behavior
physicsManager.addBehavior('platformer', {
  speed: 200,
  jumpPower: 350,
  acceleration: 500,
  friction: 0.8
});

// Top-down behavior
physicsManager.addBehavior('topdown', {
  speed: 250,
  acceleration: 600,
  friction: 0.9
});

// Racing behavior
physicsManager.addBehavior('racing', {
  maxSpeed: 300,
  acceleration: 100,
  deceleration: 80,
  turnSpeed: 0.1,
  driftFactor: 0.2
});

// Custom behavior
physicsManager.addBehavior('custom', {
  apply: (sprite, input, state) => {
    // Custom physics logic
    if (input.up) {
      sprite.body.setVelocityY(-300);
    }
  }
});

// In update()
physicsManager.update();
```

### PlayerHUD Helper

Displays player info, scores, and custom stats.

```typescript
import { createPlayerHUD } from '@martini-kit/phaser';

const hud = createPlayerHUD(this.adapter, this, {
  title: 'My Game',

  roleText: (myPlayer: any) => {
    return myPlayer?.team === 'red' ? 'Team Red' : 'Team Blue';
  },

  controlHints: (myPlayer: any) => {
    return 'WASD to Move, SPACE to Jump';
  },

  // Custom stats
  stats: (state: any) => {
    const myId = adapter.playerId;
    const myScore = state.players[myId]?.score || 0;
    return `Score: ${myScore}`;
  },

  // Layout options
  layout: {
    title: 'top',           // 'top' | 'bottom' | 'hidden'
    stats: 'top-left',      // 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
    hints: 'bottom-right'
  }
});
```

### StateDrivenSpawner

Spawns sprites based on state arrays (bullets, enemies, etc).

```typescript
const spawner = this.adapter.createStateDrivenSpawner({
  stateKey: 'projectiles',  // state.projectiles = [...]

  onCreate: (data: any) => {
    return this.add.circle(data.x, data.y, 5, 0xffff00);
  },

  onUpdate: (sprite: any, data: any) => {
    sprite.x = data.x;
    sprite.y = data.y;
  },

  onRemove: (sprite: any) => {
    sprite.destroy();
  }
});

// In update()
spawner.update();
```

### HealthBarManager

Displays health bars above sprites.

```typescript
const healthBars = this.adapter.createHealthBarManager({
  getHealth: (data) => data.health,
  getMaxHealth: (data) => data.maxHealth || 100,

  width: 40,
  height: 6,
  offset: { y: -30 },

  colors: {
    background: 0x333333,
    bar: 0x00ff00
  }
});

// In update()
healthBars.update();
```

### CameraFollower

Auto-following camera with smooth tracking.

```typescript
const cameraFollower = this.adapter.createCameraFollower({
  target: 'player-123',  // Sprite key to follow
  mode: 'lerp',          // 'lerp' | 'instant'
  lerpFactor: 0.1,       // 0.0 - 1.0

  bounds: {
    width: 1600,
    height: 1200
  }
});

// In update()
cameraFollower.update();
```

---

## Manual Approach - Advanced

### When to Use Manual

- Need fine-grained control over sprite lifecycle
- Custom physics not covered by behaviors
- Want to understand how martini-kit works
- Advanced networking scenarios

### Manual Sprite Tracking

```typescript
// HOST: Create and track sprite
if (this.adapter.isHost()) {
  const paddle = this.add.rectangle(50, 300, 15, 100, 0xffffff);
  this.physics.add.existing(paddle);

  // Track position updates
  this.adapter.trackSprite(paddle, 'paddle-123');
}

// CLIENT: Register remote sprite
this.adapter.onChange((state) => {
  if (state._sprites?.['paddle-123']) {
    const data = state._sprites['paddle-123'];
    if (!this.paddle) {
      this.paddle = this.add.rectangle(data.x, data.y, 15, 100, 0xffffff);
    }
    // trackSprite handles position sync
    this.adapter.registerRemoteSprite('paddle-123', this.paddle);
  }
});

// In update() - client side
this.adapter.updateInterpolation();
```

### Manual Input Handling

```typescript
// Get keyboard input
const cursors = this.input.keyboard!.createCursorKeys();
const wasd = this.input.keyboard!.addKeys('W,A,S,D');

// Submit action
if (cursors.up.isDown || wasd.W.isDown) {
  runtime.submitAction('move', { up: true });
}
```

### Manual Physics

```typescript
update() {
  const state = runtime.getState();
  const speed = 300;

  // Apply physics based on inputs
  for (const [playerId, input] of Object.entries(state.inputs)) {
    const sprite = this.sprites[playerId];
    if (!sprite?.body) continue;

    const body = sprite.body as Phaser.Physics.Arcade.Body;

    if (input.up) {
      body.setVelocityY(-speed);
    } else if (input.down) {
      body.setVelocityY(speed);
    } else {
      body.setVelocityY(0);
    }

    // Update state with new position
    state.players[playerId].y = sprite.y;
  }
}
```

---

## Best Practices & Patterns

### Pit of Success Patterns

#### 1. State-First Design

```typescript
// ✅ GOOD: Everything stored in state
runtime.submitAction('move', { x: 100, y: 200 });
// Host reads from state and applies physics

// ❌ BAD: Direct sprite manipulation
paddle.y -= 10;  // Not synced!
```

#### 2. Host-Only Logic

```typescript
// ✅ GOOD: Host applies physics
if (this.adapter.isHost()) {
  physicsManager.update();  // Only host runs logic
}

// ❌ BAD: All clients run logic
physicsManager.update();  // Divergence!
```

#### 3. Use Helpers for Boilerplate

```typescript
// ✅ GOOD: Helpers handle details
this.spriteManager.add('player-1', playerData);
this.spriteManager.update();

// ❌ BAD: Manual tracking for everything
this.sprites[key] = sprite;
this.adapter.trackSprite(sprite, key);
this.positions[key] = { x: sprite.x, y: sprite.y };
```

#### 4. Input → State → Physics

```typescript
// ✅ GOOD: One-way flow
Input(WASD)
  → submitAction('move', { up: true })
  → state.inputs[playerId] = { up: true }
  → host reads state.inputs
  → applies physics
  → sprites update via tracker

// ❌ BAD: Input directly moves sprites
KeyDown(W) → paddle.y -= 10  // Not synced!
```

### Common Anti-Patterns

**Don't:**
- ❌ Modify state outside of actions
- ❌ Assume clients run logic
- ❌ Use non-JSON-serializable data
- ❌ Skip targeting for multi-player actions
- ❌ Forget to call helper.update()

**Do:**
- ✅ Use actions for all state changes
- ✅ Only run game logic on host
- ✅ Keep state JSON-serializable
- ✅ Use targetId for player-specific actions
- ✅ Call helpers in update()

---

## Common Recipes

### Player Movement (Platformer)

```typescript
// Game definition
actions: {
  move: {
    apply: (state, context, input) => {
      state.inputs[context.targetId] = input;
    }
  }
}

// Scene
const inputManager = this.adapter.createInputManager();
inputManager.useProfile('platformer');

const physicsManager = this.adapter.createPhysicsManager({
  spriteManager: this.spriteManager,
  inputKey: 'inputs'
});
physicsManager.addBehavior('platformer', {
  speed: 200,
  jumpPower: 300
});

update() {
  inputManager.update();
  const state = inputManager.getState();
  runtime.submitAction('move', state.move);
  physicsManager.update();
  spriteManager.update();
}
```

### Health & Damage

```typescript
// State
interface GameState {
  players: {
    health: number;
    maxHealth: number;
  }[]
}

// Action
actions: {
  take_damage: {
    apply: (state, context, damage: number) => {
      const player = state.players[context.targetId];
      if (player) {
        player.health = Math.max(0, player.health - damage);
      }
    }
  }
}

// Usage
runtime.submitAction('take_damage', 10, enemyId);
```

### Shooting Mechanics

```typescript
// State
interface GameState {
  projectiles: Array<{
    x: number;
    y: number;
    vx: number;
    vy: number;
    ownerId: string;
  }>;
}

// Action
actions: {
  fire: {
    apply: (state, context, direction: { x: number; y: number }) => {
      state.projectiles.push({
        x: state.players[context.playerId].x,
        y: state.players[context.playerId].y,
        vx: direction.x * 500,
        vy: direction.y * 500,
        ownerId: context.playerId
      });
    }
  }
}

// Scene
const spawner = this.adapter.createStateDrivenSpawner({
  stateKey: 'projectiles',
  onCreate: (data) => this.add.circle(data.x, data.y, 5, 0xffff00),
  onUpdate: (sprite, data) => {
    sprite.x = data.x;
    sprite.y = data.y;
  }
});
```

### Collisions & Interactions

```typescript
// State
interface GameState {
  players: { x: number; y: number; radius: number }[];
  powerups: { x: number; y: number; type: string }[];
}

// Host-side collision check (in update)
const checkCollisions = () => {
  const state = runtime.getState();

  for (const powerup of state.powerups) {
    for (const [playerId, player] of Object.entries(state.players)) {
      const dist = Math.hypot(
        powerup.x - player.x,
        powerup.y - player.y
      );

      if (dist < (player.radius + 10)) {
        runtime.submitAction('pickup_powerup',
          { type: powerup.type },
          playerId
        );
      }
    }
  }
};
```

---

## TypeScript Interfaces Reference

### GameDefinition

```typescript
interface GameDefinition<T = any> {
  setup: (context: SetupContext) => T;
  actions: Record<string, ActionDefinition<T>>;
  onPlayerJoin?: (state: T, playerId: string) => void;
  onPlayerLeave?: (state: T, playerId: string) => void;
}

interface SetupContext {
  playerIds: string[];
  config?: any;
}

interface ActionDefinition<T = any> {
  apply: (
    state: T,
    context: ActionContext,
    input?: any
  ) => void | Promise<void>;
}

interface ActionContext {
  playerId: string;
  targetId: string;
  tick: number;
}
```

### PhaserAdapter

```typescript
class PhaserAdapter {
  constructor(runtime: GameRuntime, scene: Phaser.Scene);

  playerId: string;
  isHost(): boolean;
  getState(): any;

  trackSprite(sprite: any, key: string): void;
  registerRemoteSprite(key: string, sprite: any): void;
  updateInterpolation(): void;
  onChange(callback: (state: any, patches?: any[]) => void): void;

  createSpriteManager(config: SpriteManagerConfig): SpriteManager;
  createInputManager(): InputManager;
  createPhysicsManager(config: PhysicsManagerConfig): PhysicsManager;
  createCollisionManager(): CollisionManager;
  createStateDrivenSpawner(config: StateDrivenSpawnerConfig): StateDrivenSpawner;
  createHealthBarManager(config: HealthBarConfig): HealthBarManager;
  createCameraFollower(config: CameraFollowerConfig): CameraFollower;
}
```

### Transport

```typescript
interface Transport {
  isHost(): boolean;
  getPlayerId(): string;
  on(event: 'message' | 'disconnect', callback: (data: any) => void): void;
  send(message: WireMessage): void;
  destroy(): void;
}

interface WireMessage {
  type: 'state' | 'action' | 'ping' | 'join' | 'leave';
  playerId: string;
  payload: any;
}
```

---

## Troubleshooting

### Sprites Not Syncing

**Issue:** Sprites move on host but not on clients

**Solutions:**
1. Check `trackSprite()` called on host
2. Check clients calling `registerRemoteSprite()`
3. Check `updateInterpolation()` called in client update
4. Check state actually changed (inspect `state._sprites`)

### Input Not Working

**Issue:** Player presses keys but nothing happens

**Solutions:**
1. Check `inputManager.update()` called in update()
2. Check action is actually submitted: `runtime.submitAction('move', ...)`
3. Check action is defined in game definition
4. Check host applies the action (console.log in apply())

### Desync / Divergence

**Issue:** Host and clients show different state

**Solutions:**
1. ✅ Run game logic only on host
2. ✅ Use deterministic code (no Math.random() without SeededRandom)
3. ✅ Ensure clients don't modify state
4. ✅ Check action order is same on all machines

### Physics Not Smooth

**Issue:** Sprites move jerkily on clients

**Solutions:**
1. Call `updateInterpolation()` every frame
2. Use SpriteManager (has built-in interpolation)
3. Check frame rate (60 FPS expected)
4. Check network latency (high ping = choppier)

### Late Joiners Don't See Game

**Issue:** New players joining see empty game

**Solutions:**
1. ✅ SpriteManager handles this automatically
2. If manual: send full state on join: `runtime.onStateChange(() => { /* ... */ })`
3. Check server sends current state to new clients

### Actions Not Applying

**Issue:** submitAction called but state doesn't change

**Solutions:**
1. Check action name matches game definition
2. Check `apply()` function has correct logic
3. Check only host runs game logic (clients should also submit, but host applies)
4. Use runtime.getState() to verify state changed
5. Check targetId if action targets specific player

---

## Resources

**Online Documentation:**
- Installation: https://docs.martini-kit.dev
- Examples: https://martini-kit.dev/preview/fire-and-ice
- Playground: https://martini-kit.dev/playground

**Community:**
- GitHub: https://github.com/anthropics/martini-kit
- Issues: Report bugs and feature requests

---

## Tips for AI Assistants

When helping with martini-kit code:

1. **Always recommend helpers first** - they're the modern approach
2. **Check state management** - most issues are state-related
3. **Verify host/client logic** - common source of bugs
4. **Use SpriteManager** instead of manual tracking
5. **Remember targetId** for multi-player actions
6. **Call update()** on all helpers every frame
7. **Keep state JSON-serializable** - no functions/symbols
8. **Use SeededRandom** for deterministic randomness
9. **Recommend /playground** for trying ideas
10. **Link to docs** for API details

**When unsure:**
- Check the example games in `/preview/[gameId]`
- Reference the helper-based first game tutorial
- Verify with `runtime.getState()` in devtools
