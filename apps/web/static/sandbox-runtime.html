<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net; style-src 'unsafe-inline'; img-src 'self' data: blob: https://*.supabase.co; media-src 'self' data: blob: https://*.supabase.co;">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    #game {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <div id="game"></div>

  <!-- Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <!-- Martini Multiplayer SDK (Advanced deterministic multiplayer) -->
  <script src="/martini-multiplayer.browser.js"></script>

  <!-- Sandbox Runtime -->
  <script>
    /**
     * Controlled Runtime for Phaser 3 Games
     *
     * User code defines scenes via window.scenes object and uses gameAPI.
     * Sandbox controls the Phaser.Game instance for stability, hot reload, and multiplayer.
     *
     * See CUSTOM_API.md for full documentation.
     */

    // Runtime state
    let phaserGame = null;
    let userScenes = {};
    let currentSceneKey = null;
    let userCodeLoaded = false;

    // Scene state storage (persists across scene switches)
    const sceneStates = new Map();

    // Global gameAPI - Exposed to user code
    window.gameAPI = {
      _frameCounter: 0,
      _randomSeed: Date.now(),

      // === Scene Management ===

      /**
       * Switch to a different scene
       * @param {string} sceneKey - Key of the scene to switch to
       * @param {object} data - Optional data to pass to the new scene
       */
      switchScene(sceneKey, data = {}) {
        if (!userScenes[sceneKey]) {
          this.log(`ERROR: Scene "${sceneKey}" not found`);
          return;
        }

        if (phaserGame && phaserGame.scene.scenes[0]) {
          currentSceneKey = sceneKey;
          phaserGame.scene.scenes[0].scene.restart(data);
        }
      },

      /**
       * Get the current active scene key
       * @returns {string} Current scene key
       */
      getCurrentScene() {
        return currentSceneKey;
      },

      /**
       * Pause the current scene
       */
      pauseScene() {
        if (phaserGame && phaserGame.scene.scenes[0]) {
          phaserGame.scene.scenes[0].scene.pause();
        }
      },

      /**
       * Resume the current scene
       */
      resumeScene() {
        if (phaserGame && phaserGame.scene.scenes[0]) {
          phaserGame.scene.scenes[0].scene.resume();
        }
      },

      // === Utilities ===


      /**
       * Get current frame number
       * @returns {number} Frame count since game started
       */
      getFrame() {
        return this._frameCounter;
      },

      /**
       * Log a message to the parent console
       * @param {string} message - Message to log
       */
      log(message) {
        parent.postMessage({
          type: 'LOG',
          payload: { message: String(message), frame: this._frameCounter }
        }, '*');
      },

      // === Advanced Access ===

      /**
       * Get the current Phaser scene object (advanced users)
       * @returns {Phaser.Scene} Current scene
       */
      get scene() {
        return phaserGame?.scene?.scenes[0] || null;
      },

      /**
       * Get the Phaser game instance (read-only, advanced users)
       * @returns {Phaser.Game} Game instance
       */
      get game() {
        return phaserGame;
      },

      // === Multiplayer API ===
      // Will be replaced by Martini SDK integration
      // TODO: Implement new @martini/phaser adapter

      // === Multiplayer API (Martini SDK) ===
      // Placeholder - will be integrated with @martini/phaser
      
      multiplayer: null,  // Will be initialized by Martini SDK
          }
        }
      },


      // Internal: Heartbeat for watchdog
      _sendHeartbeat() {
        parent.postMessage({ type: 'HEARTBEAT' }, '*');
      }
    };

    // Expose scene and game as top-level globals for convenience
    Object.defineProperty(window, 'scene', {
      get() { return gameAPI.scene; }
    });

    Object.defineProperty(window, 'game', {
      get() { return gameAPI.game; }
    });

    // === Phaser Scene Wrapper ===
    // This is the single scene that Phaser sees. It delegates to user scenes.

    function preloadFn() {
      // Call user's preload if current scene has one
      if (currentSceneKey && userScenes[currentSceneKey]?.preload) {
        try {
          userScenes[currentSceneKey].preload.call(
            sceneStates.get(currentSceneKey) || {},
            this
          );
        } catch (error) {
          reportError(error);
        }
      }
    }

    function createFn(data) {
      // Initialize scene state storage
      if (!sceneStates.has(currentSceneKey)) {
        sceneStates.set(currentSceneKey, {});
      }

      // Call user's create function for current scene
      if (currentSceneKey && userScenes[currentSceneKey]?.create) {
        try {
          userScenes[currentSceneKey].create.call(
            sceneStates.get(currentSceneKey),
            this,
            data
          );
        } catch (error) {
          reportError(error);
        }
      }
    }

    function updateFn(time, delta) {
      // Increment frame counter
      gameAPI._frameCounter++;

      // Call user's update function for current scene
      if (currentSceneKey && userScenes[currentSceneKey]?.update) {
        try {
          userScenes[currentSceneKey].update.call(
            sceneStates.get(currentSceneKey),
            this,
            time,
            delta
          );
        } catch (error) {
          reportError(error);
        }
      }
    }

    // === Code Loading ===

    function loadUserCode(code) {
      try {
        console.log('üì• [Iframe] loadUserCode() called');
        console.log('   [Iframe] userCodeLoaded:', userCodeLoaded, '| phaserGame exists:', !!phaserGame);

        // Clear old scene states
        sceneStates.clear();
        userScenes = {};

        // Execute user code (defines window.scenes and window.startScene)
        const userFunction = new Function(code);
        userFunction();
        console.log('‚úÖ [Iframe] User code executed successfully');

        // Validate user code
        if (!window.scenes || typeof window.scenes !== 'object') {
          throw new Error('User code must define window.scenes object. See CUSTOM_API.md for documentation.');
        }

        // Store user scenes
        userScenes = window.scenes;

        // Determine starting scene
        currentSceneKey = window.startScene || Object.keys(userScenes)[0];

        if (!currentSceneKey || !userScenes[currentSceneKey]) {
          throw new Error(`Starting scene "${currentSceneKey}" not found in window.scenes`);
        }

        // If game already exists, restart the scene
        if (phaserGame) {
          console.log('üîÑ [Iframe] HOT RELOAD: Restarting scene...');
          phaserGame.scene.scenes[0].scene.restart();
          console.log('üì§ [Iframe] Sending READY + heartbeat (hot reload)');
          gameAPI._sendHeartbeat();
          parent.postMessage({ type: 'READY' }, '*');
          return; // Early return - game already exists
        }

        // FIRST LOAD: Create Phaser.Game now that user code is ready
        console.log('üÜï [Iframe] FIRST LOAD: Creating Phaser.Game with user code...');
        phaserGame = new Phaser.Game(createPhaserConfig());
        console.log('‚úÖ [Iframe] Phaser.Game created');
        console.log('‚úÖ [Iframe] Scene started automatically (user code ready!)');

        // Start heartbeat now that game is running
        setInterval(() => gameAPI._sendHeartbeat(), 1000);

        userCodeLoaded = true;

        // First load complete - notify parent that game is ready
        // Send immediate heartbeat with READY to initialize watchdog
        console.log('üì§ [Iframe] Sending READY + initial heartbeat (first load complete)');
        gameAPI._sendHeartbeat();
        parent.postMessage({ type: 'READY' }, '*');

      } catch (error) {
        console.error('‚ùå [Iframe] Error loading user code:', error);
        reportError(error);
      }
    }

    // === Message Handling ===

    window.addEventListener('message', (event) => {
      if (!event.data || !event.data.type) return;

      const { type, payload } = event.data;

      switch (type) {
        case 'LOAD_CODE':
          console.log('üì® [Iframe] Received LOAD_CODE message from parent');
          loadUserCode(payload.code);
          break;

        case 'MULTIPLAYER_STATE':
          // Update multiplayer state from parent (preserve existing methods!)
          console.log('üì® [Iframe] Received MULTIPLAYER_STATE:', payload);

          // Merge state updates into the existing multiplayer object
          if (payload._enabled !== undefined) gameAPI.multiplayer._enabled = payload._enabled;
          if (payload._isHost !== undefined) gameAPI.multiplayer._isHost = payload._isHost;
          if (payload._myId !== undefined) gameAPI.multiplayer._myId = payload._myId;
          if (payload._players !== undefined) gameAPI.multiplayer._players = payload._players;

          console.log('‚úÖ [Iframe] Multiplayer state updated:', {
            enabled: gameAPI.multiplayer._enabled,
            isHost: gameAPI.multiplayer._isHost,
            myId: gameAPI.multiplayer._myId,
            players: gameAPI.multiplayer._players
          });
          break;

        case 'MULTIPLAYER_DATA':
          // Received data from peer - handle multiplayer events
          // Format: { from: peerId, data: { eventName, data } }
          if (payload.from && payload.data) {
            const { eventName, data: eventData } = payload.data;
            gameAPI.multiplayer._handleEvent(payload.from, eventName, eventData);
          }
          break;

        case 'MULTIPLAYER_PLAYER_JOINED':
          // Trigger player joined callbacks
          gameAPI.multiplayer._handleEvent('__system', '__player_joined', payload);
          break;

        case 'MULTIPLAYER_PLAYER_LEFT':
          // Trigger player left callbacks
          gameAPI.multiplayer._handleEvent('__system', '__player_left', payload);
          break;

        case 'CAPTURE_SCREENSHOT':
          // Capture canvas screenshot and send back to parent
          const canvas = document.querySelector('canvas');
          if (canvas) {
            try {
              const dataUrl = canvas.toDataURL('image/png');
              parent.postMessage({
                type: 'SCREENSHOT_CAPTURED',
                payload: {
                  image: dataUrl,
                  width: canvas.width,
                  height: canvas.height,
                  timestamp: Date.now()
                }
              }, '*');
            } catch (error) {
              parent.postMessage({
                type: 'SCREENSHOT_ERROR',
                payload: { error: error.message }
              }, '*');
            }
          } else {
            parent.postMessage({
              type: 'SCREENSHOT_ERROR',
              payload: { error: 'Canvas not found in iframe. Game may not be loaded yet.' }
            }, '*');
          }
          break;
      }
    });

    // === Error Handling ===

    function reportError(error) {
      parent.postMessage({
        type: 'ERROR',
        payload: {
          message: error.message,
          stack: error.stack,
          line: error.lineNumber,
          column: error.columnNumber
        }
      }, '*');
    }

    window.addEventListener('error', (event) => {
      reportError(event.error || { message: event.message });
      event.preventDefault();
    });

    window.addEventListener('unhandledrejection', (event) => {
      reportError(event.reason || { message: 'Unhandled promise rejection' });
      event.preventDefault();
    });

    // === Security: Block dangerous APIs ===
    // WebRTC APIs are ALLOWED for multiplayer

    try {
      delete window.fetch;
      delete window.XMLHttpRequest;
      delete window.WebSocket;
      delete window.localStorage;
      delete window.sessionStorage;
      delete window.indexedDB;
      delete window.open;
    } catch (e) {
      console.warn('Could not delete some APIs');
    }

    // === Initialize ===

    /**
     * Create Phaser game configuration
     * Returns config object with wrapper scene that delegates to user scenes
     */
    function createPhaserConfig() {
      return {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'game',
        backgroundColor: '#2d2d2d',
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH
        },
        physics: {
          default: 'arcade',
          arcade: {
            gravity: { y: 300 },
            debug: false
          }
        },
        scene: {
          preload: preloadFn,
          create: createFn,
          update: updateFn
        }
      };
    }

    console.log('üèÅ [Iframe] Sandbox initialized, waiting for user code via LOAD_CODE message...');
    // Don't create Phaser.Game yet - wait for user code to load first
    // Game will be created inside loadUserCode() when user scenes are ready
  </script>
</body>
</html>
