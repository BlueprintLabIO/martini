<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!-- Content Security Policy -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'none';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
    style-src 'unsafe-inline';
    img-src 'self' data: blob: https://*.supabase.co;
    media-src 'self' data: blob: https://*.supabase.co;
    connect-src https://*.supabase.co wss://*.supabase.co wss://test.mosquitto.org:8081 wss://broker.emqx.io:8084 wss://broker.hivemq.com:8884;
    worker-src blob:;
  ">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    #game {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <div id="game"></div>

  <!-- Load dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="/martini-multiplayer.browser.js"></script>

  <!-- Sandbox Runtime -->
  <script>
    /**
     * Martini SDK Sandbox Runtime
     *
     * Executes user TypeScript (compiled to JS) in isolated iframe.
     * Provides: security, HMR support, automatic Martini SDK wiring.
     */

    let currentGame = null;
    let isFirstLoad = true;

    // HMR support - exposed globally for user code
    window.__HMR__ = {
      runtime: null,
      adapter: null,
      savedState: null
    };

    // Security: Block dangerous APIs (defense in depth)
    delete window.localStorage;
    delete window.sessionStorage;
    delete window.indexedDB;
    delete window.open;

    // Allow fetch ONLY for multiplayer services
    const originalFetch = window.fetch;
    window.fetch = (url, ...args) => {
      const urlStr = url.toString();
      if (
        urlStr.includes('supabase.co') ||
        urlStr.includes('mqtt') ||
        urlStr.includes('mosquitto') ||
        urlStr.includes('emqx') ||
        urlStr.includes('hivemq')
      ) {
        return originalFetch(url, ...args);
      }
      throw new Error('fetch() blocked by sandbox - only multiplayer services allowed');
    };

    // Watchdog - prevent infinite loops
    setInterval(() => {
      parent.postMessage({ type: 'HEARTBEAT' }, '*');
    }, 1000);

    /**
     * Load and execute user code
     */
    async function loadUserCode(code, roomId, isHost) {
      try {
        console.log('[Sandbox] Loading user code...', { isFirstLoad, roomId, isHost });

        // HMR: Save state (skip on first load)
        if (!isFirstLoad && window.__HMR__.runtime) {
          console.log('[Sandbox] HMR: Capturing current state...');
          window.__HMR__.savedState = captureState();
        }

        // Destroy existing game
        if (currentGame) {
          console.log('[Sandbox] Destroying previous game...');
          currentGame.destroy(true);
          currentGame = null;

          // Small delay to ensure cleanup
          await new Promise((resolve) => setTimeout(resolve, 100));
        }

        // Clear old references
        window.__HMR__.runtime = null;
        window.__HMR__.adapter = null;

        // Inject multiplayer config as globals (accessed by user's main.ts)
        window.__ROOM_ID__ = roomId;
        window.__IS_HOST__ = isHost;

        // Execute user code (IIFE bundle from esbuild)
        console.log('[Sandbox] Executing user code...');
        eval(code);

        // Wait for game to initialize
        await new Promise((resolve) => setTimeout(resolve, 200));

        // HMR: Restore state (skip on first load)
        if (!isFirstLoad && window.__HMR__.savedState) {
          console.log('[Sandbox] HMR: Restoring state...');
          restoreState(window.__HMR__.savedState);
          window.__HMR__.savedState = null;
        }

        isFirstLoad = false;

        // Notify parent
        parent.postMessage({ type: 'READY' }, '*');
        console.log('[Sandbox] Code loaded successfully');

      } catch (error) {
        console.error('[Sandbox] Error loading user code:', error);
        reportError(error);
      }
    }

    /**
     * Capture current game state for HMR
     */
    function captureState() {
      if (!window.__HMR__.runtime) {
        return null;
      }

      const runtime = window.__HMR__.runtime;
      const adapter = window.__HMR__.adapter;

      // Capture core state from runtime
      const gameState = JSON.parse(JSON.stringify(runtime.getState()));

      // Capture sprite states (if adapter exists)
      const sprites = [];
      if (adapter && adapter.trackedSprites) {
        for (const [key, { sprite }] of adapter.trackedSprites.entries()) {
          sprites.push({
            key,
            x: sprite.x,
            y: sprite.y,
            texture: sprite.texture?.key || 'default',
            velocityX: sprite.body?.velocity?.x,
            velocityY: sprite.body?.velocity?.y,
            scaleX: sprite.scaleX,
            scaleY: sprite.scaleY,
            rotation: sprite.rotation,
            alpha: sprite.alpha
          });
        }
      }

      return {
        gameState,
        sprites,
        capturedAt: Date.now()
      };
    }

    /**
     * Restore game state after HMR
     */
    function restoreState(savedState) {
      if (!window.__HMR__.runtime || !savedState) {
        return;
      }

      console.log('[HMR] Restoring state from', new Date(savedState.capturedAt));

      const runtime = window.__HMR__.runtime;

      // Restore core game state
      runtime.mutateState((state) => {
        Object.assign(state, savedState.gameState);
      });

      // Sprites will be recreated by scene's onChange listener
      console.log('[HMR] State restored successfully');
    }

    /**
     * Error reporting
     */
    function reportError(error) {
      parent.postMessage({
        type: 'ERROR',
        payload: {
          message: error.message,
          stack: error.stack,
          line: error.lineNumber,
          column: error.columnNumber
        }
      }, '*');
    }

    // Global error handlers
    window.addEventListener('error', (event) => {
      reportError(event.error || { message: event.message });
      event.preventDefault();
    });

    window.addEventListener('unhandledrejection', (event) => {
      reportError(event.reason || { message: 'Unhandled promise rejection' });
      event.preventDefault();
    });

    /**
     * Message handling from parent
     */
    window.addEventListener('message', (event) => {
      if (!event.data || !event.data.type) return;

      const { type, payload } = event.data;

      switch (type) {
        case 'LOAD_CODE':
          const { code, roomId = 'default-room', isHost = false } = payload;
          loadUserCode(code, roomId, isHost);
          break;

        case 'CAPTURE_SCREENSHOT':
          const canvas = document.querySelector('canvas');
          if (canvas) {
            try {
              const dataUrl = canvas.toDataURL('image/png');
              parent.postMessage({
                type: 'SCREENSHOT_CAPTURED',
                payload: {
                  image: dataUrl,
                  width: canvas.width,
                  height: canvas.height,
                  timestamp: Date.now()
                }
              }, '*');
            } catch (error) {
              parent.postMessage({
                type: 'SCREENSHOT_ERROR',
                payload: { error: error.message }
              }, '*');
            }
          } else {
            parent.postMessage({
              type: 'SCREENSHOT_ERROR',
              payload: { error: 'Canvas not found - game may not be loaded' }
            }, '*');
          }
          break;
      }
    });

    console.log('[Sandbox] Martini SDK runtime initialized, waiting for user code...');
  </script>
</body>
</html>
