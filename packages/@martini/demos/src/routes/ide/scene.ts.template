import type { GameRuntime } from '@martini/core';
import { PhaserAdapter } from '@martini/phaser';
import Phaser from 'phaser';

export function createScene(runtime: GameRuntime) {
	return class GameScene extends Phaser.Scene {
		private adapter!: PhaserAdapter;
		private platforms?: Phaser.Physics.Arcade.StaticGroup;
		private spriteManager: any;
		private inputManager: any;
		private playerLabels = new Map<string, Phaser.GameObjects.Text>();

		create() {
			// Initialize adapter
			this.adapter = new PhaserAdapter(runtime, this);

			// Title
			this.add.text(400, 20, 'Fire & Ice Demo', {
				fontSize: '20px',
				color: '#fff'
			}).setOrigin(0.5);

			// Instructions
			this.add.text(400, 45, 'Arrow Keys: Move & Jump', {
				fontSize: '12px',
				color: '#aaa'
			}).setOrigin(0.5);

			// Create platforms
			this.platforms = this.physics.add.staticGroup();
			this.platforms.add(this.add.rectangle(400, 580, 800, 40, 0x4a5568));
			this.platforms.add(this.add.rectangle(200, 450, 200, 20, 0x4a5568));
			this.platforms.add(this.add.rectangle(600, 350, 200, 20, 0x4a5568));
			this.platforms.add(this.add.rectangle(400, 250, 150, 20, 0x4a5568));

			// ✨ NEW: SpriteManager - handles all host/client sprite logic automatically
			this.spriteManager = this.adapter.createSpriteManager({
				onCreate: (key: string, data: any) => {
					// Create sprite (runs on both host and client)
					const color = data.role === 'fire' ? 0xff4444 : 0x4488ff;
					const sprite = this.add.rectangle(data.x, data.y, 32, 32, color);

					// Add label (both host + client)
					const label = this.add.text(0, 0, data.role === 'fire' ? 'Fire' : 'Ice', {
						fontSize: '10px',
						color: '#fff'
					}).setOrigin(0.5);
					this.playerLabels.set(key, label);

					return sprite;
				},
				// ✨ Physics setup (HOST ONLY - automatic!)
				onCreatePhysics: (sprite: any) => {
					this.physics.add.existing(sprite);
					const body = sprite.body as Phaser.Physics.Arcade.Body;
					body.setCollideWorldBounds(true);
					body.setBounce(0.2);
					this.physics.add.collider(sprite, this.platforms!);
				}
			});

			// ✨ NEW: InputManager - handles keyboard input automatically
			this.inputManager = this.adapter.createInputManager();
			this.inputManager.bindKeys({
				'ArrowLeft': { action: 'move', input: { x: -1, y: 0 }, mode: 'continuous' },
				'ArrowRight': { action: 'move', input: { x: 1, y: 0 }, mode: 'continuous' },
				'ArrowUp': { action: 'move', input: { x: 0, y: -1 }, mode: 'continuous' }
			});

			// HOST: Create initial players
			if (this.adapter.isHost()) {
				const state = runtime.getState();
				for (const [playerId, playerData] of Object.entries(state.players)) {
					this.spriteManager.add(`player-${playerId}`, playerData);
				}
			}
		}

		update() {
			// Update labels to follow sprites
			for (const [key, sprite] of this.spriteManager.getAll().entries()) {
				const label = this.playerLabels.get(key);
				if (label) {
					label.setPosition(sprite.x, sprite.y - 25);
				}
			}

			// ✨ SpriteManager handles interpolation automatically
			this.spriteManager.update();

			// ✨ InputManager handles keyboard input automatically
			this.inputManager.update();

			// HOST: Apply physics based on inputs
			if (!this.adapter.isHost()) return;

			const state = runtime.getState();
			if (!state?.players || !state?.inputs) return;

			for (const [playerId, inputData] of Object.entries(state.inputs)) {
				const sprite = this.spriteManager.get(`player-${playerId}`);
				if (!sprite || !sprite.body) continue;

				const body = sprite.body as Phaser.Physics.Arcade.Body;
				const speed = 200;
				const jumpPower = 330;

				body.setVelocityX(inputData.x * speed);

				// Jumping (only if on ground)
				if (inputData.y === -1 && body.touching.down) {
					body.setVelocityY(-jumpPower);
				}
			}
		}
	};
}
