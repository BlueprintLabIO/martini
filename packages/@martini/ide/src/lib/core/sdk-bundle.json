{
  "/node_modules/@martini/core/package.json": "{\n  \"name\": \"@martini/core\",\n  \"version\": \"2.0.0-alpha.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}",
  "/node_modules/@martini/core/GameRuntime.ts": "/**\n * GameRuntime - Host-authoritative game state manager\n *\n * v2: Simplified, no determinism, no prediction, no rollback.\n * The host runs the game, clients mirror the state.\n */\n\nimport type { GameDefinition } from './defineGame.ts';\nimport type { Transport, WireMessage, RuntimeConfig } from './transport.ts';\nimport { generateDiff, applyPatch, deepClone, type Patch } from './sync.ts';\nimport { SeededRandom } from './SeededRandom.ts';\n\ntype StateChangeCallback<TState> = (state: TState) => void;\ntype EventCallback = (senderId: string, eventName: string, payload: any) => void;\n\n/**\n * Extended runtime configuration with strict mode\n */\nexport interface GameRuntimeConfig extends RuntimeConfig {\n  /** Throw errors instead of warnings (recommended for development) */\n  strict?: boolean;\n}\n\nexport class GameRuntime<TState = any> {\n  private state: TState = {} as TState;\n  private previousState: TState = {} as TState;\n  private _isHost: boolean;\n  private syncIntervalId: any = null;\n  private unsubscribes: Array<() => void> = [];\n  private strict: boolean;\n  private actionCounter: number = 100000; // For seeding action random (start high to avoid LCG collisions)\n\n  private stateChangeCallbacks: StateChangeCallback<TState>[] = [];\n  private eventCallbacks: Map<string, EventCallback[]> = new Map();\n\n  constructor(\n    private gameDef: GameDefinition<TState>,\n    private transport: Transport,\n    private config: GameRuntimeConfig\n  ) {\n    this._isHost = config.isHost;\n    this.strict = config.strict ?? false;\n\n    // Initialize state\n    const initialPlayerIds = config.playerIds || [];\n    if (gameDef.setup) {\n      // Create deterministic random for setup (same seed for all clients)\n      const setupRandom = new SeededRandom(12345);\n      this.state = gameDef.setup({ playerIds: initialPlayerIds, random: setupRandom });\n    }\n    this.previousState = deepClone(this.state);\n\n    // Setup transport listeners\n    this.setupTransport();\n\n    // Start sync loop if host\n    if (this._isHost) {\n      const syncInterval = config.syncInterval || 50; // 20 FPS default\n      this.syncIntervalId = setInterval(() => this.syncState(), syncInterval);\n    }\n  }\n\n  /**\n   * Get current state (read-only, typed)\n   */\n  getState(): TState {\n    return this.state;\n  }\n\n  /**\n   * Check if this runtime is the host\n   */\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  /**\n   * Get transport (for adapters to check isHost, getPlayerId, etc)\n   * @internal\n   */\n  getTransport(): Transport {\n    return this.transport;\n  }\n\n  /**\n   * Directly mutate state (for adapters only - bypasses actions)\n   * Only the host should call this\n   * @internal\n   */\n  mutateState(mutator: (state: TState) => void): void {\n    if (!this._isHost) {\n      this.handleError('mutateState called on non-host - ignoring');\n      return;\n    }\n    mutator(this.state);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Execute an action (validates input, applies to state, broadcasts)\n   * @param actionName - Name of the action to execute\n   * @param input - Action payload/input data\n   * @param targetId - Optional target player ID (defaults to caller's ID)\n   */\n  submitAction(actionName: string, input: any, targetId?: string): void {\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined in game');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      const suggestion = this.findClosestMatch(actionName, availableActions);\n\n      let errorMsg = `Action \"${actionName}\" not found.`;\n\n      if (availableActions.length > 0) {\n        errorMsg += `\\n\\nAvailable actions: ${availableActions.join(', ')}`;\n        if (suggestion) {\n          errorMsg += `\\n\\nDid you mean \"${suggestion}\"?`;\n        }\n      } else {\n        errorMsg += '\\n\\nNo actions are defined in your game.';\n      }\n\n      this.handleError(errorMsg);\n      return;\n    }\n\n    const playerId = this.transport.getPlayerId();\n\n    // Create deterministic random for this action\n    const actionSeed = this.actionCounter++;\n    const actionRandom = new SeededRandom(actionSeed);\n\n    const context = {\n      playerId,                          // Who called submitAction\n      targetId: targetId || playerId,    // Who is affected (defaults to caller)\n      isHost: this._isHost,\n      random: actionRandom\n    };\n\n    // If we're the host, apply immediately\n    if (this._isHost) {\n      action.apply(this.state, context, input);\n      this.notifyStateChange();\n    }\n\n    // Broadcast action to all peers (include actionSeed for determinism)\n    this.transport.send({\n      type: 'action',\n      payload: { actionName, input, context, actionSeed },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcastEvent(eventName: string, payload: any): void {\n    const playerId = this.transport.getPlayerId();\n    this.transport.send({\n      type: 'event',\n      payload: { eventName, payload },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Listen for custom events\n   */\n  onEvent(eventName: string, callback: EventCallback): () => void {\n    if (!this.eventCallbacks.has(eventName)) {\n      this.eventCallbacks.set(eventName, []);\n    }\n    this.eventCallbacks.get(eventName)!.push(callback);\n\n    return () => {\n      const callbacks = this.eventCallbacks.get(eventName);\n      if (callbacks) {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Listen for state changes (typed)\n   */\n  onChange(callback: StateChangeCallback<TState>): () => void {\n    this.stateChangeCallbacks.push(callback);\n    return () => {\n      const index = this.stateChangeCallbacks.indexOf(callback);\n      if (index !== -1) this.stateChangeCallbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.unsubscribes.forEach(unsub => unsub());\n    this.unsubscribes = [];\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  private setupTransport(): void {\n    // Listen for incoming messages\n    this.unsubscribes.push(\n      this.transport.onMessage((msg, senderId) => {\n        this.handleMessage(msg, senderId);\n      })\n    );\n\n    // Listen for peer join\n    this.unsubscribes.push(\n      this.transport.onPeerJoin((peerId) => {\n        if (this.gameDef.onPlayerJoin) {\n          this.gameDef.onPlayerJoin(this.state, peerId);\n        }\n\n        // If we're the host, send full state to new peer\n        if (this._isHost) {\n          this.transport.send({\n            type: 'state_sync',\n            payload: { fullState: this.state }\n          }, peerId);\n        }\n      })\n    );\n\n    // Listen for peer leave\n    this.unsubscribes.push(\n      this.transport.onPeerLeave((peerId) => {\n        if (this.gameDef.onPlayerLeave) {\n          this.gameDef.onPlayerLeave(this.state, peerId);\n        }\n      })\n    );\n  }\n\n  private handleMessage(msg: WireMessage, senderId: string): void {\n    switch (msg.type) {\n      case 'state_sync':\n        // Only clients should receive state syncs\n        if (!this._isHost) {\n          this.handleStateSync(msg.payload);\n        }\n        break;\n\n      case 'action':\n        // Only host processes actions from clients\n        if (this._isHost && senderId !== this.transport.getPlayerId()) {\n          this.handleActionFromClient(msg.payload);\n        }\n        break;\n\n      case 'event':\n        this.handleEvent(senderId, msg.payload);\n        break;\n    }\n  }\n\n  private handleStateSync(payload: any): void {\n    if (payload.fullState) {\n      // Full state replacement\n      this.state = payload.fullState;\n      this.notifyStateChange();\n    } else if (payload.patches) {\n      // Apply patches\n      for (const patch of payload.patches) {\n        applyPatch(this.state, patch);\n      }\n      this.notifyStateChange();\n    }\n  }\n\n  private handleActionFromClient(payload: any): void {\n    const { actionName, input, context, actionSeed } = payload;\n\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      this.handleError(\n        `Unknown action from client: ${actionName}. Available: ${availableActions.join(', ')}`\n      );\n      return;\n    }\n\n    // Recreate the same random from the actionSeed for determinism\n    const contextWithRandom = {\n      ...context,\n      random: new SeededRandom(actionSeed)\n    };\n\n    // Apply action to state with context\n    action.apply(this.state, contextWithRandom, input);\n    this.notifyStateChange();\n  }\n\n  private handleEvent(senderId: string, payload: any): void {\n    const { eventName, payload: eventPayload } = payload;\n    const callbacks = this.eventCallbacks.get(eventName) || [];\n\n    for (const callback of callbacks) {\n      callback(senderId, eventName, eventPayload);\n    }\n  }\n\n  private syncState(): void {\n    if (!this._isHost) return;\n\n    // Generate diff\n    const patches = generateDiff(this.previousState, this.state);\n\n    if (patches.length > 0) {\n      // Broadcast patches to all clients\n      this.transport.send({\n        type: 'state_sync',\n        payload: { patches }\n      });\n\n      // Update previous state\n      this.previousState = deepClone(this.state);\n    }\n  }\n\n  private notifyStateChange(): void {\n    for (const callback of this.stateChangeCallbacks) {\n      callback(this.state);\n    }\n  }\n\n  /**\n   * Handle errors with strict mode support\n   */\n  private handleError(message: string): void {\n    if (this.strict) {\n      throw new Error(`[Martini] ${message}`);\n    } else {\n      console.warn(`[Martini] ${message}`);\n    }\n  }\n\n  /**\n   * Find closest string match (for typo suggestions)\n   */\n  private findClosestMatch(input: string, options: string[]): string | null {\n    if (options.length === 0) return null;\n\n    let minDistance = Infinity;\n    let closest: string | null = null;\n\n    for (const option of options) {\n      const distance = this.levenshteinDistance(input.toLowerCase(), option.toLowerCase());\n      if (distance < minDistance && distance <= 3) { // Max 3 character difference\n        minDistance = distance;\n        closest = option;\n      }\n    }\n\n    return closest;\n  }\n\n  /**\n   * Calculate Levenshtein distance for typo detection\n   */\n  private levenshteinDistance(str1: string, str2: string): number {\n    const m = str1.length;\n    const n = str2.length;\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (str1[i - 1] === str2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = Math.min(\n            dp[i - 1][j] + 1,    // deletion\n            dp[i][j - 1] + 1,    // insertion\n            dp[i - 1][j - 1] + 1 // substitution\n          );\n        }\n      }\n    }\n\n    return dp[m][n];\n  }\n}\n",
  "/node_modules/@martini/core/Logger.ts": "/**\n * Logger - Unity-inspired logging system for Martini\n *\n * Provides structured logging with channels, levels, assertions, and DevTools integration.\n * Inspired by Unity's Debug class and browser console API.\n */\n\nexport type LogLevel = 'log' | 'warn' | 'error';\n\nexport interface LogEntry {\n\tlevel: LogLevel;\n\tchannel: string;\n\tmessage: string;\n\tdata: any[];\n\ttimestamp: number;\n\tcontext?: Record<string, any>;\n\tstack?: string;\n}\n\nexport type LogListener = (entry: LogEntry) => void;\n\nexport class Logger {\n\tprivate channelName: string;\n\tprivate listeners: LogListener[] = [];\n\tprivate enabled: boolean = true;\n\tprivate minLevel: LogLevel = 'log';\n\tprivate context?: Record<string, any>;\n\tprivate parentContext?: Record<string, any>;\n\tprivate includeStack: boolean = false;\n\tprivate timers: Map<string, number> = new Map();\n\n\tprivate static readonly LEVEL_PRIORITY: Record<LogLevel, number> = {\n\t\tlog: 0,\n\t\twarn: 1,\n\t\terror: 2\n\t};\n\n\tconstructor(channel: string = '', parentContext?: Record<string, any>) {\n\t\tthis.channelName = channel;\n\t\tthis.parentContext = parentContext;\n\t}\n\n\t/**\n\t * Log an informational message\n\t */\n\tlog(message: string, ...data: any[]): void {\n\t\tthis.writeLog('log', message, data);\n\t}\n\n\t/**\n\t * Log a warning message\n\t */\n\twarn(message: string, ...data: any[]): void {\n\t\tthis.writeLog('warn', message, data);\n\t}\n\n\t/**\n\t * Log an error message\n\t */\n\terror(message: string, ...data: any[]): void {\n\t\tthis.writeLog('error', message, data);\n\t}\n\n\t/**\n\t * Create a collapsible group in the console\n\t */\n\tgroup(label: string): void {\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(label);\n\t\t\tconsole.group(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * End the current group\n\t */\n\tgroupEnd(): void {\n\t\tif (this.enabled) {\n\t\t\tconsole.groupEnd();\n\t\t}\n\t}\n\n\t/**\n\t * Assert a condition, log error if false\n\t */\n\tassert(condition: boolean, message?: string): void {\n\t\tif (!condition) {\n\t\t\tconst assertMessage = message ? `Assertion failed: ${message}` : 'Assertion failed';\n\t\t\tthis.writeLog('error', assertMessage, []);\n\t\t}\n\t}\n\n\t/**\n\t * Start a performance timer\n\t */\n\ttime(label: string): void {\n\t\tthis.timers.set(label, performance.now());\n\t}\n\n\t/**\n\t * End a performance timer and log the duration\n\t */\n\ttimeEnd(label: string): void {\n\t\tconst startTime = this.timers.get(label);\n\n\t\tif (startTime === undefined) {\n\t\t\tthis.warn(`Timer \"${label}\" does not exist`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst duration = performance.now() - startTime;\n\t\tthis.timers.delete(label);\n\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(`${label}: ${duration.toFixed(2)}ms`);\n\t\t\tconsole.log(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * Create a child logger with a nested channel name\n\t */\n\tchannel(name: string): Logger {\n\t\tconst childChannel = this.channelName ? `${this.channelName}:${name}` : name;\n\t\tconst mergedContext = this.getMergedContext();\n\t\tconst child = new Logger(childChannel, mergedContext);\n\t\tchild.enabled = this.enabled;\n\t\tchild.minLevel = this.minLevel;\n\t\tchild.includeStack = this.includeStack;\n\t\treturn child;\n\t}\n\n\t/**\n\t * Register a listener for log entries (used by DevTools)\n\t */\n\tonLog(listener: LogListener): () => void {\n\t\tthis.listeners.push(listener);\n\n\t\t// Return unsubscribe function\n\t\treturn () => {\n\t\t\tconst index = this.listeners.indexOf(listener);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.listeners.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Enable or disable console output\n\t * Note: Listeners are still notified when disabled (for DevTools)\n\t */\n\tsetEnabled(enabled: boolean): void {\n\t\tthis.enabled = enabled;\n\t}\n\n\t/**\n\t * Set minimum log level (filters out lower priority logs)\n\t */\n\tsetMinLevel(level: LogLevel): void {\n\t\tthis.minLevel = level;\n\t}\n\n\t/**\n\t * Attach context data to all log entries\n\t */\n\tsetContext(context: Record<string, any> | undefined): void {\n\t\tthis.context = context;\n\t}\n\n\t/**\n\t * Include stack traces in all log entries\n\t */\n\tsetIncludeStack(include: boolean): void {\n\t\tthis.includeStack = include;\n\t}\n\n\t/**\n\t * Internal: Write a log entry\n\t */\n\tprivate writeLog(level: LogLevel, message: string, data: any[]): void {\n\t\t// Check if this level should be logged\n\t\tif (!this.shouldLog(level)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entry: LogEntry = {\n\t\t\tlevel,\n\t\t\tchannel: this.channelName,\n\t\t\tmessage,\n\t\t\tdata,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontext: this.getMergedContext()\n\t\t};\n\n\t\t// Add stack trace if needed\n\t\tif (this.includeStack || level === 'error') {\n\t\t\tentry.stack = this.captureStack();\n\t\t}\n\n\t\t// Notify listeners (even if console is disabled)\n\t\tthis.notifyListeners(entry);\n\n\t\t// Write to console if enabled\n\t\tif (this.enabled) {\n\t\t\tthis.writeToConsole(level, message, data);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a log level should be output\n\t */\n\tprivate shouldLog(level: LogLevel): boolean {\n\t\tconst levelPriority = Logger.LEVEL_PRIORITY[level];\n\t\tconst minPriority = Logger.LEVEL_PRIORITY[this.minLevel];\n\t\treturn levelPriority >= minPriority;\n\t}\n\n\t/**\n\t * Format message with channel prefix\n\t */\n\tprivate formatMessage(message: string): string {\n\t\tif (this.channelName) {\n\t\t\treturn `[${this.channelName}] ${message}`;\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Write to browser console\n\t */\n\tprivate writeToConsole(level: LogLevel, message: string, data: any[]): void {\n\t\tconst formatted = this.formatMessage(message);\n\n\t\tswitch (level) {\n\t\t\tcase 'log':\n\t\t\t\tconsole.log(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'warn':\n\t\t\t\tconsole.warn(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'error':\n\t\t\t\tconsole.error(formatted, ...data);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Notify all listeners\n\t */\n\tprivate notifyListeners(entry: LogEntry): void {\n\t\tfor (const listener of this.listeners) {\n\t\t\ttry {\n\t\t\t\tlistener(entry);\n\t\t\t} catch (err) {\n\t\t\t\t// Don't let listener errors break logging\n\t\t\t\tconsole.error('Error in log listener:', err);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Merge parent and local context\n\t */\n\tprivate getMergedContext(): Record<string, any> | undefined {\n\t\tif (!this.parentContext && !this.context) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\t...this.parentContext,\n\t\t\t...this.context\n\t\t};\n\t}\n\n\t/**\n\t * Capture current stack trace\n\t */\n\tprivate captureStack(): string {\n\t\tconst error = new Error();\n\t\tif (error.stack) {\n\t\t\t// Remove the first few lines (Error constructor, this function, writeLog)\n\t\t\tconst lines = error.stack.split('\\n');\n\t\t\treturn lines.slice(3).join('\\n');\n\t\t}\n\t\treturn '';\n\t}\n}\n\n/**\n * Default logger instance\n */\nexport const logger = new Logger('Martini');\n",
  "/node_modules/@martini/core/SeededRandom.ts": "/**\n * SeededRandom - Deterministic Pseudo-Random Number Generator\n *\n * Provides a deterministic PRNG that produces the same sequence of\n * random numbers given the same seed. This ensures all clients in a\n * multiplayer game generate identical random values during setup and gameplay.\n *\n * Uses a simple Linear Congruential Generator (LCG) algorithm which is\n * fast, deterministic, and sufficient for game randomness (not cryptography).\n *\n * @example\n * ```typescript\n * const rng = new SeededRandom(12345);\n *\n * // Generate random numbers\n * rng.next();              // 0.0 to 1.0\n * rng.range(10, 20);       // 10 to 19 (integer)\n * rng.float(0, 100);       // 0.0 to 100.0 (float)\n * rng.choice(['a', 'b']);  // Random element\n * rng.shuffle([1, 2, 3]);  // Shuffled array\n * rng.boolean(0.7);        // 70% chance of true\n * ```\n */\n\nexport class SeededRandom {\n  private state: number;\n\n  // LCG parameters (from Numerical Recipes)\n  private readonly m = 0x80000000; // 2^31\n  private readonly a = 1103515245;\n  private readonly c = 12345;\n\n  /**\n   * Creates a new SeededRandom instance\n   *\n   * @param seed - Initial seed value (any integer)\n   */\n  constructor(seed: number) {\n    // Ensure seed is a positive integer\n    this.state = Math.abs(Math.floor(seed)) % this.m;\n    if (this.state === 0) this.state = 1;\n  }\n\n  /**\n   * Generate next random number in sequence\n   *\n   * @returns Random float in range [0, 1)\n   */\n  next(): number {\n    this.state = (this.a * this.state + this.c) % this.m;\n    return this.state / this.m;\n  }\n\n  /**\n   * Generate random integer in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random integer in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.range(0, 10);   // 0-9\n   * rng.range(10, 20);  // 10-19\n   * rng.range(-5, 5);   // -5 to 4\n   * ```\n   */\n  range(min: number, max: number): number {\n    if (min === max) return min;\n    return Math.floor(this.next() * (max - min)) + min;\n  }\n\n  /**\n   * Generate random float in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random float in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.float(0, 1);      // 0.0 to 0.999...\n   * rng.float(0, 100);    // 0.0 to 99.999...\n   * rng.float(-1, 1);     // -1.0 to 0.999...\n   * ```\n   */\n  float(min: number, max: number): number {\n    return this.next() * (max - min) + min;\n  }\n\n  /**\n   * Choose random element from array\n   *\n   * @param array - Array to choose from\n   * @returns Random element from array\n   * @throws Error if array is empty\n   *\n   * @example\n   * ```typescript\n   * rng.choice(['red', 'blue', 'green']);\n   * rng.choice([1, 2, 3, 4, 5]);\n   * ```\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.range(0, array.length)];\n  }\n\n  /**\n   * Shuffle array (Fisher-Yates algorithm)\n   * Returns a new shuffled array without modifying the original\n   *\n   * @param array - Array to shuffle\n   * @returns New shuffled array\n   *\n   * @example\n   * ```typescript\n   * const cards = ['A', 'K', 'Q', 'J'];\n   * const shuffled = rng.shuffle(cards);\n   * // cards is unchanged, shuffled is randomized\n   * ```\n   */\n  shuffle<T>(array: T[]): T[] {\n    if (array.length <= 1) return [...array];\n\n    const result = [...array];\n\n    // Fisher-Yates shuffle\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = this.range(0, i + 1);\n      [result[i], result[j]] = [result[j], result[i]];\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate random boolean with optional probability\n   *\n   * @param probability - Probability of returning true (0.0 to 1.0, default 0.5)\n   * @returns true or false based on probability\n   *\n   * @example\n   * ```typescript\n   * rng.boolean();      // 50% chance of true\n   * rng.boolean(0.7);   // 70% chance of true\n   * rng.boolean(1.0);   // Always true\n   * rng.boolean(0.0);   // Always false\n   * ```\n   */\n  boolean(probability = 0.5): boolean {\n    return this.next() < probability;\n  }\n}\n",
  "/node_modules/@martini/core/defineGame.ts": "/**\n * High-level API for defining multiplayer games (v2)\n *\n * Host-authoritative: the host runs the game, others mirror the state.\n */\n\nimport type { SeededRandom } from './SeededRandom.ts';\n\n/**\n * Setup context - provides initial player list and deterministic random\n */\nexport interface SetupContext {\n  /** Initial player IDs */\n  playerIds: string[];\n\n  /** Deterministic random number generator (seeded, same across all clients) */\n  random: SeededRandom;\n}\n\n/**\n * Action context - provides information about who submitted the action\n */\nexport interface ActionContext {\n  /** ID of the player who called submitAction */\n  playerId: string;\n\n  /** ID of the player being affected (defaults to playerId) */\n  targetId: string;\n\n  /** Whether this action is being applied on the host */\n  isHost: boolean;\n\n  /** Deterministic random number generator (seeded per action) */\n  random: SeededRandom;\n}\n\n/**\n * Action definition with typed state and input\n */\nexport interface ActionDefinition<TState = any, TInput = any> {\n  /** Input validation schema (optional) */\n  input?: any;\n\n  /** Apply function - modifies state directly */\n  apply: (state: TState, context: ActionContext, input: TInput) => void;\n}\n\n/**\n * Game definition with typed state\n */\nexport interface GameDefinition<TState = any> {\n  /** Initial state factory */\n  setup?: (context: SetupContext) => TState;\n\n  /** Actions - only way to modify state (optional - sprite syncing is automatic) */\n  actions?: Record<string, ActionDefinition<TState, any>>;\n\n  /** Called when a player joins mid-game */\n  onPlayerJoin?: (state: TState, playerId: string) => void;\n\n  /** Called when a player leaves */\n  onPlayerLeave?: (state: TState, playerId: string) => void;\n}\n\n/**\n * Define a multiplayer game with full TypeScript type safety\n *\n * @example\n * ```ts\n * interface GameState {\n *   players: Record<string, { x: number; y: number; score: number }>;\n * }\n *\n * const game = defineGame<GameState>({\n *   setup: ({ playerIds, random }) => ({\n *     players: Object.fromEntries(\n *       playerIds.map(id => [id, {\n *         x: random.range(0, 800),  // ✅ Deterministic!\n *         y: random.range(0, 600),\n *         score: 0\n *       }])\n *     )\n *   }),\n *\n *   actions: {\n *     move: {\n *       input: { x: 'number', y: 'number' },\n *       apply(state, context, input) {\n *         // ✅ Full type safety - autocomplete works!\n *         state.players[context.targetId].x = input.x;\n *         state.players[context.targetId].y = input.y;\n *       }\n *     }\n *   }\n * });\n * ```\n */\nexport function defineGame<TState = any>(\n  definition: GameDefinition<TState>\n): GameDefinition<TState> {\n  // Basic validation\n  if (!definition.actions) {\n    definition.actions = {};\n  }\n\n  // Validate actions if they exist\n  for (const [name, action] of Object.entries(definition.actions)) {\n    if (typeof action.apply !== 'function') {\n      throw new Error(`Action \"${name}\" must have an apply function`);\n    }\n  }\n\n  return definition;\n}\n",
  "/node_modules/@martini/core/index.ts": "/**\n * @martini/core v2 - Engine-agnostic multiplayer SDK\n *\n * Host-authoritative state synchronization. Simple, clean, works with any engine.\n *\n * @packageDocumentation\n */\n\n// Core API\nexport { defineGame } from './defineGame.ts';\nexport type { GameDefinition, ActionDefinition, ActionContext, SetupContext } from './defineGame.ts';\n\n// Runtime\nexport { GameRuntime } from './GameRuntime.ts';\nexport type { GameRuntimeConfig } from './GameRuntime.ts';\nexport type {\n  Transport,\n  WireMessage,\n  RuntimeConfig,\n  TransportMetrics,\n  ConnectionState,\n  MessageStats\n} from './transport.ts';\n\n// Utilities (kept from v1 for state sync)\nexport { generateDiff, applyPatch } from './sync.ts';\nexport type { Patch } from './sync.ts';\n\n// Deterministic Random\nexport { SeededRandom } from './SeededRandom.ts';\n\n// Logger\nexport { Logger, logger } from './Logger.ts';\nexport type { LogLevel, LogEntry, LogListener } from './Logger.ts';\n",
  "/node_modules/@martini/core/sync.ts": "/**\n * State synchronization using diffs/patches\n * Kept from v1 because it's efficient and engine-agnostic\n */\n\nexport interface Patch {\n  op: 'replace' | 'add' | 'remove';\n  path: string[];\n  value?: any;\n}\n\n/**\n * Generate a minimal diff between two states\n */\nexport function generateDiff(oldState: any, newState: any): Patch[] {\n  const patches: Patch[] = [];\n\n  function diff(oldVal: any, newVal: any, path: string[] = []) {\n    // Type change or primitive difference\n    if (typeof oldVal !== typeof newVal || oldVal === null || newVal === null) {\n      if (oldVal !== newVal) {\n        patches.push({ op: 'replace', path, value: newVal });\n      }\n      return;\n    }\n\n    // Array handling\n    if (Array.isArray(newVal)) {\n      if (!Array.isArray(oldVal) || oldVal.length !== newVal.length) {\n        patches.push({ op: 'replace', path, value: newVal });\n        return;\n      }\n\n      for (let i = 0; i < newVal.length; i++) {\n        diff(oldVal[i], newVal[i], [...path, String(i)]);\n      }\n      return;\n    }\n\n    // Object handling\n    if (typeof newVal === 'object') {\n      const oldKeys = Object.keys(oldVal || {});\n      const newKeys = Object.keys(newVal || {});\n\n      // Check removed keys\n      for (const key of oldKeys) {\n        if (!(key in newVal)) {\n          patches.push({ op: 'remove', path: [...path, key] });\n        }\n      }\n\n      // Check added/changed keys\n      for (const key of newKeys) {\n        if (!(key in oldVal)) {\n          patches.push({ op: 'add', path: [...path, key], value: newVal[key] });\n        } else {\n          diff(oldVal[key], newVal[key], [...path, key]);\n        }\n      }\n      return;\n    }\n\n    // Primitive comparison\n    if (oldVal !== newVal) {\n      patches.push({ op: 'replace', path, value: newVal });\n    }\n  }\n\n  diff(oldState, newState);\n  return patches;\n}\n\n/**\n * Apply a patch to state (mutates state)\n */\nexport function applyPatch(state: any, patch: Patch): void {\n  const { op, path, value } = patch;\n\n  if (path.length === 0) {\n    throw new Error('Cannot patch root - path must have at least one element');\n  }\n\n  // Navigate to parent\n  let current = state;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (!(key in current)) {\n      current[key] = {};\n    }\n    current = current[key];\n  }\n\n  const finalKey = path[path.length - 1];\n\n  switch (op) {\n    case 'add':\n    case 'replace':\n      current[finalKey] = value;\n      break;\n\n    case 'remove':\n      if (Array.isArray(current)) {\n        current.splice(Number(finalKey), 1);\n      } else {\n        delete current[finalKey];\n      }\n      break;\n  }\n}\n\n/**\n * Deep clone an object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as any;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n\n  const cloned: any = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n",
  "/node_modules/@martini/core/transport.ts": "/**\n * Transport interface - how messages flow between peers\n */\n\nexport interface WireMessage {\n  type: 'state_sync' | 'action' | 'player_join' | 'player_leave' | 'event' | 'heartbeat' | 'host_migration' | 'host_query' | 'host_announce';\n  payload?: any;\n  senderId?: string;\n  timestamp?: number;\n  sessionId?: string; // for heartbeat messages\n  newHost?: string; // for host migration\n  hostId?: string; // for host announce\n  [key: string]: any; // allow additional properties\n}\n\n/**\n * Connection state for transport observability\n */\nexport type ConnectionState = 'disconnected' | 'connecting' | 'connected';\n\n/**\n * Message statistics for transport metrics\n */\nexport interface MessageStats {\n  sent: number;\n  received: number;\n  errors: number;\n}\n\n/**\n * TransportMetrics - Optional interface for transport observability\n *\n * Inspired by libp2p's StatTransport and WebRTC's getStats() API.\n * Transports can optionally implement this interface to expose metrics\n * for debugging, monitoring, and DevTools integration.\n *\n * @example\n * ```typescript\n * const transport = new LocalTransport(config);\n * if (transport.metrics) {\n *   console.log('Connection state:', transport.metrics.getConnectionState());\n *\n *   transport.metrics.onConnectionChange((state) => {\n *     console.log('Connection changed:', state);\n *   });\n * }\n * ```\n */\nexport interface TransportMetrics {\n  /**\n   * Get current connection state\n   * @returns Current state: disconnected, connecting, or connected\n   */\n  getConnectionState(): ConnectionState;\n\n  /**\n   * Listen for connection state changes\n   * @param callback Function called when connection state changes\n   * @returns Unsubscribe function\n   */\n  onConnectionChange(callback: (state: ConnectionState) => void): () => void;\n\n  /**\n   * Get number of connected peers (excluding self)\n   * @returns Count of active peer connections\n   */\n  getPeerCount(): number;\n\n  /**\n   * Get message statistics (counters)\n   * @returns Object with sent/received/error counts\n   */\n  getMessageStats(): MessageStats;\n\n  /**\n   * Get round-trip latency in milliseconds (optional, transport-dependent)\n   * @returns Latency in ms, or undefined if not supported\n   */\n  getLatencyMs?(): number | undefined;\n\n  /**\n   * Reset all metrics counters (useful for testing)\n   */\n  resetStats?(): void;\n}\n\nexport interface Transport {\n  /** Send a message to specific peer or broadcast to all */\n  send(message: WireMessage, targetId?: string): void;\n\n  /** Listen for incoming messages */\n  onMessage(handler: (message: WireMessage, senderId: string) => void): () => void;\n\n  /** Listen for peer joining */\n  onPeerJoin(handler: (peerId: string) => void): () => void;\n\n  /** Listen for peer leaving */\n  onPeerLeave(handler: (peerId: string) => void): () => void;\n\n  /** Get current peer ID */\n  getPlayerId(): string;\n\n  /** Get all connected peer IDs */\n  getPeerIds(): string[];\n\n  /** Is this peer the host */\n  isHost(): boolean;\n\n  /**\n   * Optional metrics interface for observability\n   * Transports can implement this to expose connection state,\n   * message statistics, and other debugging information.\n   */\n  metrics?: TransportMetrics;\n}\n\nexport interface RuntimeConfig {\n  /** Is this instance the host (runs authoritative simulation) */\n  isHost: boolean;\n\n  /** Initial player IDs (optional, can be added dynamically) */\n  playerIds?: string[];\n\n  /** How often to sync state (ms) - default 50ms (20 FPS) */\n  syncInterval?: number;\n}\n",
  "/node_modules/@martini/phaser/package.json": "{\n  \"name\": \"@martini/phaser\",\n  \"version\": \"2.0.0-alpha.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}",
  "/node_modules/@martini/phaser/PhaserAdapter.ts": "/**\n * PhaserAdapter - Bridge between Phaser and @martini/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.ts';\nimport { InputManager } from './helpers/InputManager.ts';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 50ms / 20 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Interpolate movement on clients for smoothness */\n  interpolate?: boolean;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Enable automatic interpolation for remote sprites (default: true)\n   * When enabled, remote sprites smoothly lerp to target positions\n   */\n  autoInterpolate?: boolean;\n\n  /**\n   * Interpolation lerp factor (default: 0.3)\n   * Lower = smoother but laggier, Higher = snappier but jerkier\n   * Range: 0.1 (very smooth) to 0.5 (very snappy)\n   */\n  lerpFactor?: number;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   autoInterpolate: true,           // optional, defaults to true\n *   lerpFactor: 0.3                  // optional, defaults to 0.3\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<string, { sprite: any; options: SpriteTrackingOptions }> = new Map();\n  private remoteSprites: Map<string, any> = new Map(); // Sprites created for remote players\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly autoInterpolate: boolean;\n  private readonly lerpFactor: number;\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.autoInterpolate = config.autoInterpolate !== false; // default true\n    this.lerpFactor = config.lerpFactor ?? 0.3;\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, { sprite, options });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 50;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // Note: We do NOT immediately sync here to avoid infinite loops\n    // when trackSprite is called inside onChange callbacks.\n    // The interval-based sync will handle the first sync.\n  }\n\n  /**\n   * Stop tracking a sprite\n   */\n  untrackSprite(key: string): void {\n    this.trackedSprites.delete(key);\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[this.spriteNamespace];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, { sprite, options }] of this.trackedSprites.entries()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n      const sprites = state[this.spriteNamespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   */\n  private updateSpritesFromState(state: any): void {\n    const sprites = state[this.spriteNamespace];\n    if (this.isHost() || !sprites) return;\n\n    // Update tracked sprites (sprites that exist on this client)\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const spriteData = sprites[key];\n      if (spriteData) {\n        this.applySpriteData(tracked.sprite, spriteData);\n      }\n    }\n\n    // Update remote sprites (sprites from other players)\n    // Store target positions for interpolation\n    for (const [key, spriteData] of Object.entries(sprites)) {\n      // Skip if this is our own sprite\n      if (this.trackedSprites.has(key)) continue;\n\n      // If we have a remote sprite for this key, store target position\n      const remoteSprite = this.remoteSprites.get(key);\n      if (remoteSprite) {\n        // Store target position for smooth interpolation\n        remoteSprite._targetX = (spriteData as any).x;\n        remoteSprite._targetY = (spriteData as any).y;\n        remoteSprite._targetRotation = (spriteData as any).rotation;\n\n        // First update - snap to position immediately\n        if (remoteSprite._targetX !== undefined && remoteSprite.x === undefined) {\n          remoteSprite.x = remoteSprite._targetX;\n          remoteSprite.y = remoteSprite._targetY;\n          remoteSprite.rotation = remoteSprite._targetRotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any): void {\n    this.remoteSprites.set(key, sprite);\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Note: If autoInterpolate is enabled in config, you don't need to call this manually.\n   */\n  updateInterpolation(): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    for (const [key, sprite] of this.remoteSprites.entries()) {\n      if (sprite._targetX !== undefined) {\n        // Lerp towards target position\n        sprite.x += (sprite._targetX - sprite.x) * this.lerpFactor;\n        sprite.y += (sprite._targetY - sprite.y) * this.lerpFactor;\n\n        if (sprite._targetRotation !== undefined) {\n          sprite.rotation += (sprite._targetRotation - sprite.rotation) * this.lerpFactor;\n        }\n      }\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const sprite = this.remoteSprites.get(key);\n    if (sprite && sprite.destroy) {\n      sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    return new SpriteManager(this, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n}\n",
  "/node_modules/@martini/phaser/helpers/InputManager.ts": "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.ts';\nimport type { GameRuntime } from '@martini/core';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    console.log('[InputManager] bindKeys called with:', bindings);\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n      console.log(`[InputManager] Registered key: ${key.toUpperCase()}`, normalized);\n    }\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          console.log(`[InputManager] Key pressed (oneshot): ${key}`, binding);\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          console.log(`[InputManager] Key held (continuous): ${key}`, binding);\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            console.log(`[InputManager] Cursor pressed (oneshot):`, normalized);\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            console.log(`[InputManager] Cursor held (continuous):`, normalized);\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    console.log(`[InputManager] submitAction('${binding.action}', ${JSON.stringify(binding.input)}, ${binding.targetId || 'self'})`);\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n",
  "/node_modules/@martini/phaser/helpers/SpriteManager.ts": "/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.ts';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Properties to sync (default: x, y, rotation, alpha)\n   */\n  syncProperties?: string[];\n\n  /**\n   * Sync interval in ms (default: 50ms / 20 FPS)\n   */\n  syncInterval?: number;\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    // Track for automatic sync (host only)\n    this.adapter.trackSprite(sprite, key, {\n      properties: this.config.syncProperties || ['x', 'y', 'rotation', 'alpha'],\n      syncInterval: this.config.syncInterval\n    });\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteNamespace = (this.adapter as any).spriteNamespace || '_sprites';\n    const spriteData = state[spriteNamespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      if (!this.sprites.has(key)) {\n        // Create new sprite\n        const sprite = this.config.onCreate(key, data);\n        this.sprites.set(key, sprite);\n        this.adapter.registerRemoteSprite(key, sprite);\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data);\n        }\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n}\n",
  "/node_modules/@martini/phaser/index.ts": "/**\n * @martini/phaser - Phaser 3 adapter for multiplayer games\n *\n * Provides high-level helpers for syncing sprites and handling multiplayer in Phaser.\n *\n * @packageDocumentation\n */\n\nexport { PhaserAdapter } from './PhaserAdapter.ts';\nexport type { SpriteTrackingOptions, PhaserAdapterConfig } from './PhaserAdapter.ts';\n\n// Helpers\nexport { SpriteManager } from './helpers/SpriteManager.ts';\nexport type { SpriteManagerConfig, SpriteData } from './helpers/SpriteManager.ts';\nexport { InputManager } from './helpers/InputManager.ts';\nexport type { ActionBinding, KeyBinding, KeyBindings, CursorBindings } from './helpers/InputManager.ts';\n\n// Runtime initialization (transport abstraction)\nexport { initializeGame } from './runtime.ts';\nexport type { MartiniConfig, GameConfig } from './runtime.ts';\n\n// Re-export core types for convenience\nexport type { GameDefinition, Transport, GameRuntime } from '@martini/core';\n",
  "/node_modules/@martini/phaser/runtime.ts": "/**\n * @martini/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini/core';\nimport { LocalTransport } from '@martini/transport-local';\n// import { TrysteroTransport } from '@martini/transport-trystero'; // Disabled for IDE\nimport { IframeBridgeTransport } from '@martini/transport-iframe-bridge';\nimport type { Transport } from '@martini/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n  };\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): { runtime: GameRuntime<TState>; phaser: Phaser.Game } {\n  // Read platform-injected config\n  const platformConfig = (window as any).__MARTINI_CONFIG__ as MartiniConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __MARTINI_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: [transport.getPlayerId()]\n    }\n  );\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  console.log('🔥🔥🔥 [Martini] Applying Phaser scale config:', defaultScale);\n  console.log('🔥🔥🔥 [Martini] Scale mode:', defaultScale.mode, '(2 = FIT, 0 = NONE)');\n  alert('Phaser Scale Config Applied! Mode: ' + defaultScale.mode);\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  console.log('[Martini] Final Phaser config:', phaserConfig);\n  console.log('[Martini] Final scale mode:', phaserConfig.scale?.mode);\n\n  const phaserGame = new Phaser.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any).__MARTINI_IDE__) {\n    (window as any).__MARTINI_IDE__.registerRuntime(runtime);\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    // case 'trystero':\n    //   return new TrysteroTransport({\n    //     appId: config.appId || 'martini',\n    //     roomId: config.roomId,\n    //     isHost: config.isHost\n    //   });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local' and 'iframe-bridge' are supported in IDE mode.`);\n  }\n}\n",
  "/node_modules/@martini/transport-local/package.json": "{\n  \"name\": \"@martini/transport-local\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}",
  "/node_modules/@martini/transport-local/LocalTransport.ts": "/**\n * LocalTransport - In-memory transport for same-page multiplayer\n *\n * Perfect for:\n * - Side-by-side demo instances on the same page\n * - Unit/integration testing\n * - Local development without network overhead\n *\n * All instances in the same room share messages instantly via an in-memory event bus.\n */\n\nimport type { Transport, WireMessage, TransportMetrics, ConnectionState, MessageStats } from '@martini/core';\n\ntype MessageHandler = (message: WireMessage, senderId: string) => void;\ntype PeerHandler = (peerId: string) => void;\ntype ConnectionChangeHandler = (state: ConnectionState) => void;\n\n/**\n * Static registry of all local transport instances, grouped by room\n */\nclass LocalTransportRegistry {\n  private static rooms = new Map<string, Set<LocalTransport>>();\n\n  static register(roomId: string, transport: LocalTransport): void {\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n    this.rooms.get(roomId)!.add(transport);\n\n    // Notify existing peers about the new peer\n    const room = this.rooms.get(roomId)!;\n    for (const peer of room) {\n      if (peer !== transport) {\n        // Notify existing peer about new peer\n        peer.notifyPeerJoin(transport.playerId);\n        // Notify new peer about existing peer\n        transport.notifyPeerJoin(peer.playerId);\n      }\n    }\n  }\n\n  static unregister(roomId: string, transport: LocalTransport): void {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    // Check if the leaving peer is the host before removing\n    const isLeavingPeerHost = transport.isHost();\n\n    room.delete(transport);\n\n    // Notify remaining peers about the disconnect\n    for (const peer of room) {\n      peer.notifyPeerLeave(transport.playerId, isLeavingPeerHost);\n    }\n\n    if (room.size === 0) {\n      this.rooms.delete(roomId);\n    }\n  }\n\n  static getPeers(roomId: string, excludeId: string): LocalTransport[] {\n    const room = this.rooms.get(roomId);\n    if (!room) return [];\n    return Array.from(room).filter((t) => t.playerId !== excludeId);\n  }\n\n  static broadcast(roomId: string, message: WireMessage, senderId: string): void {\n    const peers = this.getPeers(roomId, senderId);\n    for (const peer of peers) {\n      peer.deliver(message, senderId);\n    }\n  }\n\n  static unicast(roomId: string, message: WireMessage, senderId: string, targetId: string): void {\n    const room = this.rooms.get(roomId);\n    if (!room) return;\n\n    const target = Array.from(room).find((p) => p.playerId === targetId);\n    if (target) {\n      target.deliver(message, senderId);\n    }\n  }\n}\n\n/**\n * Metrics implementation for LocalTransport\n * Tracks connection state, peer count, and message statistics\n */\nclass LocalTransportMetrics implements TransportMetrics {\n  private connectionState: ConnectionState = 'disconnected';\n  private connectionChangeHandlers: ConnectionChangeHandler[] = [];\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private messagesErrored = 0;\n\n  constructor(private transport: LocalTransport) {\n    // LocalTransport is always \"connected\" since it's in-memory\n    this.connectionState = 'connected';\n  }\n\n  getConnectionState(): ConnectionState {\n    return this.connectionState;\n  }\n\n  onConnectionChange(callback: ConnectionChangeHandler): () => void {\n    this.connectionChangeHandlers.push(callback);\n    return () => {\n      const idx = this.connectionChangeHandlers.indexOf(callback);\n      if (idx >= 0) this.connectionChangeHandlers.splice(idx, 1);\n    };\n  }\n\n  getPeerCount(): number {\n    return this.transport.getPeerIds().length;\n  }\n\n  getMessageStats(): MessageStats {\n    return {\n      sent: this.messagesSent,\n      received: this.messagesReceived,\n      errors: this.messagesErrored\n    };\n  }\n\n  resetStats(): void {\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.messagesErrored = 0;\n  }\n\n  /** @internal - Called by LocalTransport when message is sent */\n  trackMessageSent(): void {\n    this.messagesSent++;\n  }\n\n  /** @internal - Called by LocalTransport when message is received */\n  trackMessageReceived(): void {\n    this.messagesReceived++;\n  }\n\n  /** @internal - Called by LocalTransport when message fails */\n  trackMessageError(): void {\n    this.messagesErrored++;\n  }\n\n  /** @internal - Called by LocalTransport when disconnecting */\n  setDisconnected(): void {\n    if (this.connectionState !== 'disconnected') {\n      this.connectionState = 'disconnected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  private notifyConnectionChange(): void {\n    this.connectionChangeHandlers.forEach(h => {\n      try {\n        h(this.connectionState);\n      } catch (error) {\n        console.error('Error in connection change handler:', error);\n      }\n    });\n  }\n}\n\nexport interface LocalTransportConfig {\n  roomId: string;\n  playerId?: string;\n  isHost: boolean;\n}\n\nexport class LocalTransport implements Transport {\n  public readonly playerId: string;\n  private readonly roomId: string;\n  private readonly _isHost: boolean;\n  public readonly metrics: TransportMetrics;\n\n  private messageHandlers: MessageHandler[] = [];\n  private peerJoinHandlers: PeerHandler[] = [];\n  private peerLeaveHandlers: PeerHandler[] = [];\n  private hostDisconnectHandlers: (() => void)[] = [];\n\n  constructor(config: LocalTransportConfig) {\n    this.roomId = config.roomId;\n    this.playerId = config.playerId || `player-${Math.random().toString(36).substring(2, 9)}`;\n    this._isHost = config.isHost;\n\n    // Initialize metrics\n    this.metrics = new LocalTransportMetrics(this);\n\n    // Register with the global registry\n    LocalTransportRegistry.register(this.roomId, this);\n  }\n\n  send(message: WireMessage, targetId?: string): void {\n    try {\n      if (targetId) {\n        // Unicast\n        LocalTransportRegistry.unicast(this.roomId, message, this.playerId, targetId);\n      } else {\n        // Broadcast\n        LocalTransportRegistry.broadcast(this.roomId, message, this.playerId);\n      }\n      (this.metrics as LocalTransportMetrics).trackMessageSent();\n    } catch (error) {\n      (this.metrics as LocalTransportMetrics).trackMessageError();\n      throw error;\n    }\n  }\n\n  onMessage(handler: MessageHandler): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      const idx = this.messageHandlers.indexOf(handler);\n      if (idx >= 0) this.messageHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerJoin(handler: PeerHandler): () => void {\n    this.peerJoinHandlers.push(handler);\n    return () => {\n      const idx = this.peerJoinHandlers.indexOf(handler);\n      if (idx >= 0) this.peerJoinHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerLeave(handler: PeerHandler): () => void {\n    this.peerLeaveHandlers.push(handler);\n    return () => {\n      const idx = this.peerLeaveHandlers.indexOf(handler);\n      if (idx >= 0) this.peerLeaveHandlers.splice(idx, 1);\n    };\n  }\n\n  onHostDisconnect(handler: () => void): () => void {\n    this.hostDisconnectHandlers.push(handler);\n    return () => {\n      const idx = this.hostDisconnectHandlers.indexOf(handler);\n      if (idx >= 0) this.hostDisconnectHandlers.splice(idx, 1);\n    };\n  }\n\n  getPlayerId(): string {\n    return this.playerId;\n  }\n\n  getPeerIds(): string[] {\n    return LocalTransportRegistry.getPeers(this.roomId, this.playerId).map((p) => p.playerId);\n  }\n\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  disconnect(): void {\n    (this.metrics as LocalTransportMetrics).setDisconnected();\n    LocalTransportRegistry.unregister(this.roomId, this);\n  }\n\n  // Internal methods called by the registry\n\n  /** @internal */\n  deliver(message: WireMessage, senderId: string): void {\n    (this.metrics as LocalTransportMetrics).trackMessageReceived();\n    this.messageHandlers.forEach((h) => h(message, senderId));\n  }\n\n  /** @internal */\n  notifyPeerJoin(peerId: string): void {\n    this.peerJoinHandlers.forEach((h) => h(peerId));\n  }\n\n  /** @internal */\n  notifyPeerLeave(peerId: string, wasHost: boolean): void {\n    this.peerLeaveHandlers.forEach((h) => h(peerId));\n\n    // If the leaving peer was the host, notify host disconnect handlers\n    if (wasHost) {\n      this.hostDisconnectHandlers.forEach((h) => h());\n    }\n  }\n}\n",
  "/node_modules/@martini/transport-local/index.ts": "/**\n * @martini/transport-local\n *\n * In-memory transport for same-page multiplayer demos and testing.\n *\n * Use this transport when you want to run multiple game instances\n * on the same page (e.g., side-by-side demo views) without the\n * complexity of WebRTC signaling.\n *\n * @example\n * ```ts\n * // Create two instances in the same room\n * const host = new LocalTransport({\n *   roomId: 'demo-room',\n *   isHost: true\n * });\n *\n * const client = new LocalTransport({\n *   roomId: 'demo-room',\n *   isHost: false\n * });\n *\n * // They instantly see each other\n * host.getPeerIds(); // [client.playerId]\n * client.getPeerIds(); // [host.playerId]\n * ```\n */\n\nexport { LocalTransport, type LocalTransportConfig } from './LocalTransport';\n",
  "/node_modules/@martini/transport-iframe-bridge/package.json": "{\n  \"name\": \"@martini/transport-iframe-bridge\",\n  \"version\": \"2.0.0-alpha.1\",\n  \"main\": \"./index.ts\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.ts\"\n  }\n}",
  "/node_modules/@martini/transport-iframe-bridge/IframeBridgeRelay.ts": "/**\n * IframeBridgeRelay - Parent window coordinator for iframe-based multiplayer\n *\n * Runs in the parent window and relays messages between sandboxed iframes.\n * Acts as a message hub - receives messages from one iframe and forwards to others.\n *\n * @example\n * ```typescript\n * // In parent window (IDE component)\n * const relay = new IframeBridgeRelay();\n *\n * // When iframes are created\n * relay.registerIframe('host-player-123', hostIframeElement);\n * relay.registerIframe('client-player-456', clientIframeElement);\n *\n * // Cleanup when done\n * relay.destroy();\n * ```\n */\n\nimport type { BridgeMessage } from './IframeBridgeTransport.ts';\n\nexport interface PeerInfo {\n  playerId: string;\n  roomId: string;\n  iframe: HTMLIFrameElement;\n  isHost: boolean;\n}\n\nexport class IframeBridgeRelay {\n  private peers: Map<string, PeerInfo> = new Map();\n  private rooms: Map<string, Set<string>> = new Map(); // roomId → Set<playerId>\n  private messageHandler: ((event: MessageEvent) => void) | null = null;\n\n  constructor() {\n    this.setupMessageListener();\n  }\n\n  /**\n   * Set up listener for messages from iframes\n   */\n  private setupMessageListener(): void {\n    this.messageHandler = (event: MessageEvent) => {\n      const data = event.data as BridgeMessage;\n\n      // Ignore non-bridge messages\n      if (!data || !data.type || !data.type.startsWith('BRIDGE_')) {\n        return;\n      }\n\n      switch (data.type) {\n        case 'BRIDGE_REGISTER':\n          this.handleRegister(data, event.source as Window);\n          break;\n\n        case 'BRIDGE_SEND':\n          this.handleSend(data);\n          break;\n\n        case 'BRIDGE_PEER_LEAVE':\n          this.handlePeerLeave(data);\n          break;\n      }\n    };\n\n    window.addEventListener('message', this.messageHandler);\n  }\n\n  /**\n   * Handle peer registration\n   */\n  private handleRegister(data: BridgeMessage, source: Window): void {\n    const { playerId, roomId } = data;\n\n    // Find the iframe that sent this message\n    const iframe = Array.from(document.querySelectorAll('iframe')).find(\n      (iframe) => iframe.contentWindow === source\n    );\n\n    if (!iframe) {\n      console.warn('[IframeBridgeRelay] Could not find iframe for registration:', playerId);\n      return;\n    }\n\n    // Determine if this is the host (first peer in room)\n    const room = this.rooms.get(roomId);\n    const isHost = !room || room.size === 0;\n\n    // Register peer\n    this.peers.set(playerId, {\n      playerId,\n      roomId,\n      iframe,\n      isHost\n    });\n\n    // Add to room\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n    this.rooms.get(roomId)!.add(playerId);\n\n    // Notify existing peers about new peer\n    const existingPeers = this.getPeersInRoom(roomId).filter(p => p.playerId !== playerId);\n    for (const peer of existingPeers) {\n      this.sendToIframe(peer.iframe, {\n        type: 'BRIDGE_PEER_JOIN',\n        roomId,\n        playerId: peer.playerId,\n        payload: { peerId: playerId }\n      });\n    }\n\n    // Notify new peer about existing peers\n    for (const peer of existingPeers) {\n      this.sendToIframe(iframe, {\n        type: 'BRIDGE_PEER_JOIN',\n        roomId,\n        playerId,\n        payload: { peerId: peer.playerId }\n      });\n    }\n  }\n\n  /**\n   * Handle message send from a peer\n   */\n  private handleSend(data: BridgeMessage): void {\n    const { playerId, roomId, payload } = data;\n\n    if (!payload?.message) {\n      console.warn('[IframeBridgeRelay] No message in BRIDGE_SEND');\n      return;\n    }\n\n    const sender = this.peers.get(playerId);\n    if (!sender) {\n      console.warn('[IframeBridgeRelay] Unknown sender:', playerId);\n      return;\n    }\n\n    // Get target peer(s)\n    const targets = payload.targetId\n      ? [this.peers.get(payload.targetId)].filter(Boolean) as PeerInfo[]\n      : this.getPeersInRoom(roomId).filter(p => p.playerId !== playerId);\n\n    // Deliver message to target(s)\n    for (const target of targets) {\n      this.sendToIframe(target.iframe, {\n        type: 'BRIDGE_DELIVER',\n        roomId,\n        playerId, // Original sender ID\n        payload: { message: payload.message }\n      });\n    }\n  }\n\n  /**\n   * Handle peer leaving\n   */\n  private handlePeerLeave(data: BridgeMessage): void {\n    const { playerId, roomId, payload } = data;\n\n    const peer = this.peers.get(playerId);\n    if (!peer) return;\n\n    // Remove from tracking\n    this.peers.delete(playerId);\n    const room = this.rooms.get(roomId);\n    if (room) {\n      room.delete(playerId);\n      if (room.size === 0) {\n        this.rooms.delete(roomId);\n      }\n    }\n\n    console.log(`[IframeBridgeRelay] Peer ${playerId} left room ${roomId}`);\n\n    // Notify remaining peers\n    const remainingPeers = this.getPeersInRoom(roomId);\n    for (const otherPeer of remainingPeers) {\n      this.sendToIframe(otherPeer.iframe, {\n        type: 'BRIDGE_PEER_LEAVE',\n        roomId,\n        playerId: otherPeer.playerId,\n        payload: {\n          peerId: playerId,\n          wasHost: payload?.wasHost || false\n        }\n      });\n    }\n\n    // If host left, notify about host disconnect\n    if (peer.isHost) {\n      for (const otherPeer of remainingPeers) {\n        this.sendToIframe(otherPeer.iframe, {\n          type: 'BRIDGE_HOST_DISCONNECT',\n          roomId,\n          playerId: otherPeer.playerId,\n          payload: { wasHost: true }\n        });\n      }\n    }\n  }\n\n  /**\n   * Get all peers in a room\n   */\n  private getPeersInRoom(roomId: string): PeerInfo[] {\n    const room = this.rooms.get(roomId);\n    if (!room) return [];\n\n    return Array.from(room)\n      .map(playerId => this.peers.get(playerId))\n      .filter(Boolean) as PeerInfo[];\n  }\n\n  /**\n   * Send message to an iframe\n   */\n  private sendToIframe(iframe: HTMLIFrameElement, message: BridgeMessage): void {\n    if (!iframe.contentWindow) {\n      console.warn('[IframeBridgeRelay] Iframe has no contentWindow');\n      return;\n    }\n\n    iframe.contentWindow.postMessage(message, '*');\n  }\n\n  /**\n   * Manually register an iframe (useful for testing or explicit control)\n   */\n  registerIframe(playerId: string, roomId: string, iframe: HTMLIFrameElement, isHost: boolean): void {\n    this.peers.set(playerId, {\n      playerId,\n      roomId,\n      iframe,\n      isHost\n    });\n\n    if (!this.rooms.has(roomId)) {\n      this.rooms.set(roomId, new Set());\n    }\n    this.rooms.get(roomId)!.add(playerId);\n\n    console.log(`[IframeBridgeRelay] Manually registered ${playerId} in ${roomId}`);\n  }\n\n  /**\n   * Get info about registered peers\n   */\n  getPeers(): PeerInfo[] {\n    return Array.from(this.peers.values());\n  }\n\n  /**\n   * Get peers in a specific room\n   */\n  getPeersInRoomById(roomId: string): PeerInfo[] {\n    return this.getPeersInRoom(roomId);\n  }\n\n  /**\n   * Clean up\n   */\n  destroy(): void {\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n      this.messageHandler = null;\n    }\n\n    this.peers.clear();\n    this.rooms.clear();\n  }\n}\n",
  "/node_modules/@martini/transport-iframe-bridge/IframeBridgeTransport.ts": "/**\n * IframeBridgeTransport - Iframe-based transport for sandboxed multiplayer\n *\n * Perfect for:\n * - IDE dual-view local testing (sandboxed iframes)\n * - Any scenario where peers are in separate sandboxed iframes\n * - Testing with iframe isolation\n *\n * Architecture:\n * - Parent window runs IframeBridgeRelay (message hub)\n * - Each iframe has IframeBridgeTransport instance\n * - Messages flow: iframe → parent relay → other iframes\n *\n * @example\n * ```typescript\n * // In parent window\n * const relay = new IframeBridgeRelay();\n * relay.registerIframe('host', hostIframe);\n * relay.registerIframe('client', clientIframe);\n *\n * // In host iframe\n * const transport = new IframeBridgeTransport({ roomId: 'room-1', isHost: true });\n *\n * // In client iframe\n * const transport = new IframeBridgeTransport({ roomId: 'room-1', isHost: false });\n * ```\n */\n\nimport type { Transport, WireMessage, TransportMetrics, ConnectionState, MessageStats } from '@martini/core';\n\ntype ConnectionChangeHandler = (state: ConnectionState) => void;\n\nexport interface IframeBridgeConfig {\n  /** Unique room identifier */\n  roomId: string;\n\n  /** Player ID (auto-generated if not provided) */\n  playerId?: string;\n\n  /** Whether this instance is the host */\n  isHost: boolean;\n}\n\n/**\n * Message types for iframe ↔ parent communication\n */\nexport interface BridgeMessage {\n  type: 'BRIDGE_REGISTER' | 'BRIDGE_SEND' | 'BRIDGE_DELIVER' | 'BRIDGE_PEER_JOIN' | 'BRIDGE_PEER_LEAVE' | 'BRIDGE_HOST_DISCONNECT';\n  roomId: string;\n  playerId: string;\n  payload?: {\n    message?: WireMessage;\n    targetId?: string;\n    peerId?: string;\n    wasHost?: boolean;\n  };\n}\n\n/**\n * Metrics implementation for IframeBridgeTransport\n */\nclass IframeBridgeTransportMetrics implements TransportMetrics {\n  private connectionState: ConnectionState = 'connecting';\n  private connectionChangeHandlers: ConnectionChangeHandler[] = [];\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private messagesErrored = 0;\n\n  constructor(private transport: IframeBridgeTransport) {\n    // Start as 'connecting', will change to 'connected' when relay responds\n  }\n\n  getConnectionState(): ConnectionState {\n    return this.connectionState;\n  }\n\n  onConnectionChange(callback: ConnectionChangeHandler): () => void {\n    this.connectionChangeHandlers.push(callback);\n    return () => {\n      const idx = this.connectionChangeHandlers.indexOf(callback);\n      if (idx >= 0) this.connectionChangeHandlers.splice(idx, 1);\n    };\n  }\n\n  getPeerCount(): number {\n    return this.transport.getPeerIds().length;\n  }\n\n  getMessageStats(): MessageStats {\n    return {\n      sent: this.messagesSent,\n      received: this.messagesReceived,\n      errors: this.messagesErrored\n    };\n  }\n\n  resetStats(): void {\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.messagesErrored = 0;\n  }\n\n  /** @internal */\n  trackMessageSent(): void {\n    this.messagesSent++;\n  }\n\n  /** @internal */\n  trackMessageReceived(): void {\n    this.messagesReceived++;\n  }\n\n  /** @internal */\n  trackMessageError(): void {\n    this.messagesErrored++;\n  }\n\n  /** @internal */\n  setConnected(): void {\n    if (this.connectionState !== 'connected') {\n      this.connectionState = 'connected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  /** @internal */\n  setDisconnected(): void {\n    if (this.connectionState !== 'disconnected') {\n      this.connectionState = 'disconnected';\n      this.notifyConnectionChange();\n    }\n  }\n\n  private notifyConnectionChange(): void {\n    this.connectionChangeHandlers.forEach(h => {\n      try {\n        h(this.connectionState);\n      } catch (error) {\n        console.error('Error in connection change handler:', error);\n      }\n    });\n  }\n}\n\nexport class IframeBridgeTransport implements Transport {\n  public readonly playerId: string;\n  private readonly roomId: string;\n  private readonly _isHost: boolean;\n  public readonly metrics: TransportMetrics;\n\n  private messageHandlers: Array<(msg: WireMessage, senderId: string) => void> = [];\n  private peerJoinHandlers: Array<(peerId: string) => void> = [];\n  private peerLeaveHandlers: Array<(peerId: string) => void> = [];\n  private hostDisconnectHandlers: Array<() => void> = [];\n\n  private peerIds: Set<string> = new Set();\n  private messageHandler: ((event: MessageEvent) => void) | null = null;\n  private isDisconnected = false;\n\n  constructor(config: IframeBridgeConfig) {\n    this.roomId = config.roomId;\n    this.playerId = config.playerId || `player-${Math.random().toString(36).substring(2, 9)}`;\n    this._isHost = config.isHost;\n\n    // Initialize metrics\n    this.metrics = new IframeBridgeTransportMetrics(this);\n\n    this.setupMessageListener();\n    this.registerWithRelay();\n  }\n\n  /**\n   * Set up listener for messages from parent relay\n   */\n  private setupMessageListener(): void {\n    this.messageHandler = (event: MessageEvent) => {\n      const data = event.data as BridgeMessage;\n\n      // Ignore messages not from our relay system\n      if (!data || !data.type || !data.type.startsWith('BRIDGE_')) {\n        return;\n      }\n\n      // Ignore messages for other rooms\n      if (data.roomId !== this.roomId) {\n        return;\n      }\n\n      switch (data.type) {\n        case 'BRIDGE_DELIVER':\n          // Received message from another peer\n          if (data.payload?.message && data.playerId !== this.playerId) {\n            (this.metrics as IframeBridgeTransportMetrics).trackMessageReceived();\n            this.messageHandlers.forEach(h => h(data.payload!.message!, data.playerId));\n          }\n          break;\n\n        case 'BRIDGE_PEER_JOIN':\n          // Another peer joined the room\n          if (data.payload?.peerId && data.payload.peerId !== this.playerId) {\n            this.peerIds.add(data.payload.peerId);\n            (this.metrics as IframeBridgeTransportMetrics).setConnected(); // Mark as connected when first peer joins\n            this.peerJoinHandlers.forEach(h => h(data.payload!.peerId!));\n          }\n          break;\n\n        case 'BRIDGE_PEER_LEAVE':\n          // Another peer left the room\n          if (data.payload?.peerId) {\n            this.peerIds.delete(data.payload.peerId);\n            this.peerLeaveHandlers.forEach(h => h(data.payload!.peerId!));\n          }\n          break;\n\n        case 'BRIDGE_HOST_DISCONNECT':\n          // Host disconnected\n          if (data.payload?.wasHost && !this._isHost) {\n            this.hostDisconnectHandlers.forEach(h => h());\n          }\n          break;\n      }\n    };\n\n    window.addEventListener('message', this.messageHandler);\n  }\n\n  /**\n   * Register this transport instance with parent relay\n   */\n  private registerWithRelay(): void {\n    if (!window.parent || window.parent === window) {\n      console.warn('[IframeBridgeTransport] No parent window found - transport may not work');\n      return;\n    }\n\n    const registerMessage: BridgeMessage = {\n      type: 'BRIDGE_REGISTER',\n      roomId: this.roomId,\n      playerId: this.playerId,\n      payload: {}\n    };\n\n    window.parent.postMessage(registerMessage, '*');\n  }\n\n  /**\n   * Send message to peer(s)\n   */\n  send(message: WireMessage, targetId?: string): void {\n    if (this.isDisconnected) {\n      console.warn('[IframeBridgeTransport] Cannot send - transport is disconnected');\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageError();\n      return;\n    }\n\n    if (!window.parent || window.parent === window) {\n      console.warn('[IframeBridgeTransport] No parent window - message not sent');\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageError();\n      return;\n    }\n\n    try {\n      const bridgeMessage: BridgeMessage = {\n        type: 'BRIDGE_SEND',\n        roomId: this.roomId,\n        playerId: this.playerId,\n        payload: {\n          message,\n          targetId\n        }\n      };\n\n      window.parent.postMessage(bridgeMessage, '*');\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageSent();\n    } catch (error) {\n      (this.metrics as IframeBridgeTransportMetrics).trackMessageError();\n      throw error;\n    }\n  }\n\n  onMessage(handler: (msg: WireMessage, senderId: string) => void): () => void {\n    this.messageHandlers.push(handler);\n    return () => {\n      const idx = this.messageHandlers.indexOf(handler);\n      if (idx >= 0) this.messageHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerJoin(handler: (peerId: string) => void): () => void {\n    this.peerJoinHandlers.push(handler);\n    return () => {\n      const idx = this.peerJoinHandlers.indexOf(handler);\n      if (idx >= 0) this.peerJoinHandlers.splice(idx, 1);\n    };\n  }\n\n  onPeerLeave(handler: (peerId: string) => void): () => void {\n    this.peerLeaveHandlers.push(handler);\n    return () => {\n      const idx = this.peerLeaveHandlers.indexOf(handler);\n      if (idx >= 0) this.peerLeaveHandlers.splice(idx, 1);\n    };\n  }\n\n  onHostDisconnect(handler: () => void): () => void {\n    this.hostDisconnectHandlers.push(handler);\n    return () => {\n      const idx = this.hostDisconnectHandlers.indexOf(handler);\n      if (idx >= 0) this.hostDisconnectHandlers.splice(idx, 1);\n    };\n  }\n\n  getPlayerId(): string {\n    return this.playerId;\n  }\n\n  getPeerIds(): string[] {\n    return Array.from(this.peerIds);\n  }\n\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  disconnect(): void {\n    if (this.isDisconnected) return;\n\n    (this.metrics as IframeBridgeTransportMetrics).setDisconnected();\n    this.isDisconnected = true;\n\n    // Notify relay\n    if (window.parent && window.parent !== window) {\n      const disconnectMessage: BridgeMessage = {\n        type: 'BRIDGE_PEER_LEAVE',\n        roomId: this.roomId,\n        playerId: this.playerId,\n        payload: {\n          peerId: this.playerId,\n          wasHost: this._isHost\n        }\n      };\n\n      window.parent.postMessage(disconnectMessage, '*');\n    }\n\n    // Clean up\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n      this.messageHandler = null;\n    }\n\n    this.messageHandlers = [];\n    this.peerJoinHandlers = [];\n    this.peerLeaveHandlers = [];\n    this.hostDisconnectHandlers = [];\n    this.peerIds.clear();\n  }\n}\n",
  "/node_modules/@martini/transport-iframe-bridge/index.ts": "/**\n * @martini/transport-iframe-bridge\n *\n * Iframe-based transport for sandboxed multiplayer testing.\n * Enables local multiplayer testing in sandboxed iframes (like IDE dual-view).\n */\n\nexport { IframeBridgeTransport } from './IframeBridgeTransport.ts';\nexport { IframeBridgeRelay } from './IframeBridgeRelay.ts';\nexport type { IframeBridgeConfig, BridgeMessage } from './IframeBridgeTransport.ts';\nexport type { PeerInfo } from './IframeBridgeRelay.ts';\n"
}