{
  "version": 3,
  "sources": ["../src/helpers/SpriteManager.ts", "../src/helpers/InputProfiles.ts", "../src/helpers/InputManager.ts", "../src/helpers/PlayerUIManager.ts", "../src/helpers/CollisionManager.ts", "../src/helpers/PhysicsManager.ts", "../src/PhaserAdapter.ts", "../src/helpers/HUDHelper.ts", "../src/runtime.ts"],
  "sourcesContent": ["/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type Phaser from 'phaser';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Optional: Keys from the initial data object to sync exactly once\n   * Useful for metadata like player roles that should be available on clients.\n   */\n  staticProperties?: (keyof TData & string)[];\n\n  /**\n   * Properties to sync (default: x, y, rotation, alpha)\n   */\n  syncProperties?: string[];\n\n  /**\n   * Sync interval in ms (default: 50ms / 20 FPS)\n   */\n  syncInterval?: number;\n\n  /**\n   * Optional label configuration. When provided, SpriteManager renders labels above sprites.\n   */\n  label?: {\n    getText: (data: TData) => string;\n    offset?: { x?: number; y?: number };\n    style?: Phaser.Types.GameObjects.Text.TextStyle;\n  };\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private spriteData = new Map<string, TData>();\n  private labels = new Map<\n    string,\n    { text: Phaser.GameObjects.Text; offset?: { x?: number; y?: number } }\n  >();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n    this.spriteData.set(key, data);\n    this.createLabel(key, data, sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    if (this.config.staticProperties?.length) {\n      const staticData: Partial<TData> = {};\n      for (const prop of this.config.staticProperties) {\n        if (prop in data) {\n          staticData[prop] = data[prop];\n        }\n      }\n      if (Object.keys(staticData).length > 0) {\n        this.adapter.setSpriteStaticData(key, staticData);\n      }\n    }\n\n    // Track for automatic sync (host only)\n    this.adapter.trackSprite(sprite, key, {\n      properties: this.config.syncProperties || ['x', 'y', 'rotation', 'alpha'],\n      syncInterval: this.config.syncInterval\n    });\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n    const label = this.labels.get(key);\n    if (label) {\n      label.text.destroy();\n      this.labels.delete(key);\n    }\n    this.spriteData.delete(key);\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n    this.updateLabels();\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteNamespace = (this.adapter as any).spriteNamespace || '_sprites';\n    const spriteData = state[spriteNamespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      if (!this.sprites.has(key)) {\n        // Create new sprite\n        const sprite = this.config.onCreate(key, data as TData);\n        this.sprites.set(key, sprite);\n        this.spriteData.set(key, data as TData);\n        this.adapter.registerRemoteSprite(key, sprite);\n        this.createLabel(key, data as TData, sprite);\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data as TData);\n        }\n        this.spriteData.set(key, data as TData);\n      }\n\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n\n  private createLabel(key: string, data: TData, sprite: any): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n\n    const scene = this.adapter.getScene();\n    if (!scene?.add?.text) return;\n\n    const textValue = labelConfig.getText(data);\n    const style = labelConfig.style || { fontSize: '12px', color: '#ffffff' };\n    const label = scene.add.text(sprite.x, sprite.y, textValue, style).setOrigin(0.5);\n    this.labels.set(key, { text: label, offset: labelConfig.offset });\n  }\n\n  private updateLabels(): void {\n    for (const key of this.labels.keys()) {\n      this.updateLabelText(key);\n      this.updateLabelPosition(key);\n    }\n  }\n\n  private updateLabelText(key: string): void {\n    const labelConfig = this.config.label;\n    if (!labelConfig) return;\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const data = this.spriteData.get(key);\n    if (!data) return;\n\n    const next = labelConfig.getText(data);\n    if (labelEntry.text.text !== next) {\n      labelEntry.text.setText(next);\n    }\n  }\n\n  private updateLabelPosition(key: string): void {\n    const labelEntry = this.labels.get(key);\n    if (!labelEntry) return;\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    const offsetX = labelEntry.offset?.x ?? 0;\n    const offsetY = labelEntry.offset?.y ?? -20;\n    labelEntry.text.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n  }\n}\n", "/**\n * Input Profiles - Pre-defined control schemes\n *\n * Eliminates manual key binding boilerplate by providing standard control patterns.\n */\n\nimport type { KeyBindings } from './InputManager.js';\n\nexport interface AggregatedProfileConfig {\n  /** Profile type */\n  type: 'aggregated';\n\n  /** Action name to submit */\n  action: string;\n\n  /** Map of field names to key codes */\n  keys: Record<string, string>;\n\n  /** Continuous or oneshot mode */\n  mode?: 'continuous' | 'oneshot';\n}\n\nexport interface PerKeyProfileConfig {\n  /** Profile type */\n  type: 'per-key';\n\n  /** Key bindings for this profile */\n  bindings: KeyBindings;\n}\n\nexport interface InputProfile {\n  /** Profile name */\n  name: string;\n\n  /** Profile configuration (aggregated or per-key) */\n  config: AggregatedProfileConfig | PerKeyProfileConfig;\n\n  /** Description of the control scheme */\n  description?: string;\n}\n\nexport interface ProfileOptions {\n  /** Override specific keys */\n  overrides?: Partial<KeyBindings>;\n\n  /** Player number (1-based). Changes arrow keys to WASD for player 2 */\n  player?: 1 | 2;\n\n  /** Override action names */\n  action?: string;\n}\n\n/**\n * Built-in input profiles\n */\nexport const BUILT_IN_PROFILES: Record<string, InputProfile> = {\n  platformer: {\n    name: 'platformer',\n    description: 'Side-scrolling platformer controls (Arrow keys + Space for jump)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'Space'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  platformerWASD: {\n    name: 'platformerWASD',\n    description: 'Platformer controls with WASD',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDown: {\n    name: 'topDown',\n    description: '4-directional movement (Arrow keys)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'ArrowUp',\n        down: 'ArrowDown'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDownWASD: {\n    name: 'topDownWASD',\n    description: '4-directional movement (WASD)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W',\n        down: 'S'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  shooter: {\n    name: 'shooter',\n    description: 'Top-down shooter (WASD for move, Space for shoot)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'Space': { action: 'shoot', mode: 'oneshot' },\n      }\n    }\n  },\n\n  twinStick: {\n    name: 'twinStick',\n    description: 'Twin-stick shooter (WASD for move, Arrow keys for aim)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'ArrowLeft': { action: 'aim', input: { x: -1 }, mode: 'continuous' },\n        'ArrowRight': { action: 'aim', input: { x: 1 }, mode: 'continuous' },\n        'ArrowUp': { action: 'aim', input: { y: -1 }, mode: 'continuous' },\n        'ArrowDown': { action: 'aim', input: { y: 1 }, mode: 'continuous' },\n      }\n    }\n  }\n};\n\n/**\n * Custom profile registry\n */\nconst customProfiles = new Map<string, InputProfile>();\n\n/**\n * Register a custom input profile\n *\n * @param name - Profile name\n * @param profile - Profile configuration\n *\n * @example\n * ```ts\n * registerProfile('custom-platformer', {\n *   name: 'custom-platformer',\n *   bindings: {\n *     'A': { action: 'move', input: { left: true }, mode: 'continuous' },\n *     'D': { action: 'move', input: { right: true }, mode: 'continuous' },\n *     'W': { action: 'jump', mode: 'oneshot' },\n *   }\n * });\n * ```\n */\nexport function registerProfile(name: string, profile: InputProfile): void {\n  customProfiles.set(name, profile);\n}\n\n/**\n * Get a profile by name (checks custom profiles first, then built-in)\n *\n * @param name - Profile name\n * @returns Profile or undefined if not found\n */\nexport function getProfile(name: string): InputProfile | undefined {\n  return customProfiles.get(name) || BUILT_IN_PROFILES[name];\n}\n\n/**\n * Apply profile options to a profile config\n *\n * @param profile - Original profile\n * @param options - Profile options\n * @returns Modified profile config\n */\nexport function applyProfileOptions(\n  profile: InputProfile,\n  options?: ProfileOptions\n): AggregatedProfileConfig | PerKeyProfileConfig {\n  if (!options) return profile.config;\n\n  const config = profile.config;\n\n  // For aggregated profiles\n  if (config.type === 'aggregated') {\n    let keys = { ...config.keys };\n\n    // Apply player number (swap arrow keys for WASD)\n    if (options.player === 2) {\n      const keyMap: Record<string, string> = {\n        'ArrowLeft': 'A',\n        'ArrowRight': 'D',\n        'ArrowUp': 'W',\n        'ArrowDown': 'S',\n        'Space': 'Space', // Keep Space unchanged\n      };\n\n      const newKeys: Record<string, string> = {};\n      for (const [field, key] of Object.entries(keys)) {\n        newKeys[field] = keyMap[key] || key;\n      }\n      keys = newKeys;\n    }\n\n    return {\n      type: 'aggregated',\n      action: options.action || config.action,\n      keys,\n      mode: config.mode\n    };\n  }\n\n  // For per-key profiles\n  let bindings = { ...config.bindings };\n\n  // Apply player number (swap arrow keys for WASD)\n  if (options.player === 2) {\n    const keyMap: Record<string, string> = {\n      'ArrowLeft': 'A',\n      'ArrowRight': 'D',\n      'ArrowUp': 'W',\n      'ArrowDown': 'S',\n    };\n\n    const newBindings: KeyBindings = {};\n    for (const [key, binding] of Object.entries(bindings)) {\n      const newKey = keyMap[key] || key;\n      newBindings[newKey] = binding;\n    }\n    bindings = newBindings;\n  }\n\n  // Apply action override\n  if (options.action) {\n    for (const key of Object.keys(bindings)) {\n      const binding = bindings[key];\n      if (typeof binding === 'object') {\n        bindings[key] = { ...binding, action: options.action };\n      }\n    }\n  }\n\n  // Apply key overrides\n  if (options.overrides) {\n    for (const [key, binding] of Object.entries(options.overrides)) {\n      if (binding !== undefined) {\n        bindings[key] = binding;\n      }\n    }\n  }\n\n  return {\n    type: 'per-key',\n    bindings\n  };\n}\n\n/**\n * Merge multiple profiles into one\n *\n * @param profileNames - Array of profile names to merge\n * @returns Merged bindings (only works with per-key profiles)\n *\n * @example\n * ```ts\n * const bindings = mergeProfiles(['shooter', 'twinStick']);\n * // Combines multiple per-key profiles\n * ```\n */\nexport function mergeProfiles(profileNames: string[]): KeyBindings {\n  const merged: KeyBindings = {};\n\n  for (const name of profileNames) {\n    const profile = getProfile(name);\n    if (profile && profile.config.type === 'per-key') {\n      Object.assign(merged, profile.config.bindings);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * List all available profiles\n *\n * @returns Array of profile names\n */\nexport function listProfiles(): string[] {\n  return [\n    ...Object.keys(BUILT_IN_PROFILES),\n    ...Array.from(customProfiles.keys())\n  ];\n}\n", "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini/core';\nimport { getProfile, applyProfileOptions, mergeProfiles as mergeProfileBindings, type ProfileOptions } from './InputProfiles.js';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport interface AggregatedBinding {\n  keyMap: Record<string, string>;\n  state: Record<string, any>;\n  mode: 'continuous' | 'oneshot';\n  targetId?: string;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n  private aggregatedBindings = new Map<string, AggregatedBinding>(); // NEW: Track aggregated state\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n    }\n  }\n\n  /**\n   * Bind multiple keys that aggregate into a single input state\n   * Perfect for platformers, twin-stick shooters, fighting games\n   *\n   * Key codes: Use standard DOM key names (ArrowLeft, ArrowRight, ArrowUp, ArrowDown, Space).\n   * Letter keys (A-Z) are automatically uppercased. Arrow keys and Space are automatically\n   * converted to Phaser's internal format (LEFT, RIGHT, UP, DOWN, SPACE).\n   *\n   * @example\n   * ```ts\n   * // Platformer controls - use ArrowLeft/ArrowRight/Space\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'ArrowLeft',\n   *   right: 'ArrowRight',\n   *   up: 'Space'\n   * });\n   * // Automatically tracks: { left: true/false, right: true/false, up: true/false }\n   *\n   * // Top-down movement - letter keys work as-is\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'A',\n   *   right: 'D',\n   *   up: 'W',\n   *   down: 'S'\n   * });\n   * ```\n   */\n  bindKeysAggregated(\n    action: string,\n    keyMap: Record<string, string>,\n    options?: {\n      initialState?: Record<string, any>;\n      mode?: 'continuous' | 'oneshot';\n      targetId?: string;\n    }\n  ): void {\n    // Build initial state (default to false for each field)\n    const state = options?.initialState ||\n      Object.fromEntries(\n        Object.keys(keyMap).map(field => [field, false])\n      );\n\n    this.aggregatedBindings.set(action, {\n      keyMap,\n      state,\n      mode: options?.mode || 'continuous',\n      targetId: options?.targetId\n    });\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n\n    // Handle aggregated bindings (multi-key state tracking)\n    for (const [action, binding] of this.aggregatedBindings.entries()) {\n      let stateChanged = false;\n\n      // Check each key in the map and update state\n      for (const [field, keyCode] of Object.entries(binding.keyMap)) {\n        // IMPORTANT: Convert user-friendly key names to Phaser's internal key codes\n        // Phaser uses uppercase constants (e.g., 'LEFT' not 'ArrowLeft')\n        // This mapping allows users to use standard DOM key names while Phaser expects its own format\n        // See: https://photonstorm.github.io/phaser3-docs/Phaser.Input.Keyboard.KeyCodes.html\n        let phaserKeyCode = keyCode;\n        const keyCodeMap: Record<string, string> = {\n          'ArrowLeft': 'LEFT',\n          'ArrowRight': 'RIGHT',\n          'ArrowUp': 'UP',\n          'ArrowDown': 'DOWN',\n          'Space': 'SPACE'\n        };\n\n        if (keyCodeMap[keyCode]) {\n          phaserKeyCode = keyCodeMap[keyCode];\n        }\n\n        const keyObj = this.scene.input.keyboard?.addKey(phaserKeyCode, false);\n        if (!keyObj) {\n          console.warn(`[InputManager] Failed to create key object for: ${keyCode} (mapped to ${phaserKeyCode})`);\n          continue;\n        }\n\n        const pressed = keyObj.isDown;\n\n        // Update state if changed\n        if (binding.state[field] !== pressed) {\n          binding.state[field] = pressed;\n          stateChanged = true;\n        }\n      }\n\n      // Submit aggregated state\n      if (binding.mode === 'continuous') {\n        // Submit every frame (spread to avoid mutation)\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      } else if (binding.mode === 'oneshot' && stateChanged) {\n        // Submit only when state changes\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Use a pre-defined input profile\n   *\n   * @param profileName - Name of the profile ('platformer', 'topDown', 'shooter', etc.)\n   * @param options - Optional customization\n   *\n   * @example\n   * ```ts\n   * // Simple usage\n   * inputManager.useProfile('platformer');\n   *\n   * // With player 2 (uses WASD instead of arrows)\n   * inputManager.useProfile('platformer', { player: 2 });\n   *\n   * // With custom action name\n   * inputManager.useProfile('platformer', { action: 'move' });\n   *\n   * // With key overrides\n   * inputManager.useProfile('platformer', {\n   *   overrides: {\n   *     'Space': { action: 'jump', mode: 'oneshot' }\n   *   }\n   * });\n   * ```\n   */\n  useProfile(profileName: string, options?: ProfileOptions): void {\n    const profile = getProfile(profileName);\n\n    if (!profile) {\n      console.warn(`[InputManager] Profile \"${profileName}\" not found. Available profiles:`, [\n        'platformer', 'platformerWASD', 'topDown', 'topDownWASD', 'shooter', 'twinStick'\n      ]);\n      return;\n    }\n\n    const config = applyProfileOptions(profile, options);\n\n    if (config.type === 'aggregated') {\n      // Use aggregated binding for multi-key state tracking\n      this.bindKeysAggregated(config.action, config.keys, {\n        mode: config.mode\n      });\n    } else {\n      // Use per-key binding for separate actions\n      this.bindKeys(config.bindings);\n    }\n  }\n\n  /**\n   * Merge multiple profiles into one\n   *\n   * @param profileNames - Array of profile names\n   *\n   * @example\n   * ```ts\n   * // Combine platformer movement with shooter actions\n   * inputManager.mergeProfiles(['platformer', 'shooter']);\n   * ```\n   */\n  mergeProfiles(profileNames: string[]): void {\n    const merged = mergeProfileBindings(profileNames);\n    this.bindKeys(merged);\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n", "/**\n * PlayerUIManager - Automatic UI synchronization for players\n *\n * Eliminates bugs caused by:\n * - Creating UI before player metadata (side, team, etc.) is synced\n * - Forgetting to update UI when player data changes\n * - Manual loops to create/update/destroy UI elements\n *\n * Features:\n * - Waits for staticProperties before creating UI (no race conditions!)\n * - Auto-repositions UI when metadata changes\n * - Auto-creates UI for late-joining players\n * - Auto-destroys UI when players leave\n *\n * Usage:\n * ```ts\n * const playerUI = adapter.createPlayerUIManager({\n *   score: {\n *     position: (player) => ({\n *       x: player.side === 'left' ? 200 : 600,\n *       y: 80\n *     }),\n *     getText: (player) => String(player.score || 0),\n *     style: { fontSize: '48px', color: '#fff' }\n *   },\n *\n *   health: {\n *     position: (player) => ({ x: player.x, y: player.y - 30 }),\n *     width: 50,\n *     height: 5,\n *     getValue: (player) => player.health / player.maxHealth,\n *     backgroundColor: 0x333333,\n *     foregroundColor: 0x00ff00\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TextUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   * Called when UI is created AND when metadata changes\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Text content function\n   */\n  getText: (player: any, playerId: string) => string;\n\n  /**\n   * Phaser text style\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   * Example: ['side', 'team'] - waits until these are synced\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface BarUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Value function (0-1 range)\n   */\n  getValue: (player: any, playerId: string) => number;\n\n  /**\n   * Bar dimensions\n   */\n  width: number;\n  height: number;\n\n  /**\n   * Colors\n   */\n  backgroundColor: number;\n  foregroundColor: number;\n\n  /**\n   * Bar origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface PlayerUIManagerConfig {\n  /**\n   * UI elements keyed by name\n   * Each element can be text or bar type\n   */\n  [elementName: string]: TextUIConfig | BarUIConfig;\n}\n\ntype UIElement = {\n  type: 'text' | 'bar';\n  config: TextUIConfig | BarUIConfig;\n  gameObject: any; // Phaser.GameObjects.Text | Container with rectangles\n};\n\nexport class PlayerUIManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: PlayerUIManagerConfig;\n  private playerElements: Map<string, Map<string, UIElement>> = new Map(); // playerId -> elementName -> UIElement\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, scene: any, config: PlayerUIManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config;\n\n    // Subscribe to state changes\n    this.unsubscribe = adapter.onChange((state: any) => {\n      this.syncFromState(state);\n    });\n  }\n\n  /**\n   * Get UI element for a specific player\n   */\n  get(playerId: string, elementName: string): any {\n    return this.playerElements.get(playerId)?.get(elementName)?.gameObject;\n  }\n\n  /**\n   * Manually update all UI (also called automatically on state changes)\n   */\n  update(): void {\n    const state = this.adapter.getRuntime().getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Destroy all UI elements\n    for (const [playerId, elements] of this.playerElements.entries()) {\n      for (const [elementName, element] of elements.entries()) {\n        this.destroyElement(element);\n      }\n    }\n    this.playerElements.clear();\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * Sync UI from state\n   */\n  private syncFromState(state: any): void {\n    if (!state.players) return;\n\n    const existingPlayers = new Set(this.playerElements.keys());\n\n    // Create/update UI for each player\n    for (const [playerId, playerData] of Object.entries(state.players) as [string, any][]) {\n      existingPlayers.delete(playerId);\n\n      // Get or create element map for this player\n      let elements = this.playerElements.get(playerId);\n      if (!elements) {\n        elements = new Map();\n        this.playerElements.set(playerId, elements);\n      }\n\n      // Create/update each UI element\n      for (const [elementName, elementConfig] of Object.entries(this.config)) {\n        const existing = elements.get(elementName);\n\n        // Check if required metadata exists\n        const requiredMetadata = (elementConfig as any).requiredMetadata || [];\n        const hasMetadata = requiredMetadata.every((key: string) => key in playerData);\n\n        if (!hasMetadata) {\n          // Metadata not ready yet - skip creation\n          continue;\n        }\n\n        if (!existing) {\n          // Create new UI element\n          const element = this.createElement(elementName, elementConfig, playerId, playerData);\n          if (element) {\n            elements.set(elementName, element);\n          }\n        } else {\n          // Update existing UI element\n          this.updateElement(existing, playerId, playerData);\n        }\n      }\n    }\n\n    // Remove UI for players who left\n    for (const playerId of existingPlayers) {\n      const elements = this.playerElements.get(playerId);\n      if (elements) {\n        for (const element of elements.values()) {\n          this.destroyElement(element);\n        }\n      }\n      this.playerElements.delete(playerId);\n    }\n  }\n\n  /**\n   * Create a UI element\n   */\n  private createElement(\n    elementName: string,\n    config: TextUIConfig | BarUIConfig,\n    playerId: string,\n    playerData: any\n  ): UIElement | null {\n    const pos = config.position(playerData, playerId);\n\n    if (this.isTextConfig(config)) {\n      // Create text element\n      const text = this.scene.add.text(\n        pos.x,\n        pos.y,\n        config.getText(playerData, playerId),\n        config.style || {}\n      );\n\n      if (config.origin !== undefined) {\n        if (typeof config.origin === 'number') {\n          text.setOrigin(config.origin);\n        } else {\n          text.setOrigin(config.origin.x, config.origin.y);\n        }\n      }\n\n      if (config.depth !== undefined) {\n        text.setDepth(config.depth);\n      }\n\n      return {\n        type: 'text',\n        config,\n        gameObject: text\n      };\n    } else {\n      // Create bar element (container with two rectangles)\n      const container = this.scene.add.container(pos.x, pos.y);\n\n      const bg = this.scene.add.rectangle(0, 0, config.width, config.height, config.backgroundColor);\n      const fg = this.scene.add.rectangle(\n        0,\n        0,\n        config.width * config.getValue(playerData, playerId),\n        config.height,\n        config.foregroundColor\n      );\n\n      if (config.origin !== undefined) {\n        const originX = typeof config.origin === 'number' ? config.origin : config.origin.x;\n        const originY = typeof config.origin === 'number' ? config.origin : config.origin.y;\n        bg.setOrigin(originX, originY);\n        fg.setOrigin(originX, originY);\n      }\n\n      container.add([bg, fg]);\n\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n\n      // Store references for updates\n      (container as any)._bg = bg;\n      (container as any)._fg = fg;\n\n      return {\n        type: 'bar',\n        config,\n        gameObject: container\n      };\n    }\n  }\n\n  /**\n   * Update a UI element\n   */\n  private updateElement(element: UIElement, playerId: string, playerData: any): void {\n    const pos = element.config.position(playerData, playerId);\n\n    if (element.type === 'text') {\n      const config = element.config as TextUIConfig;\n      const text = element.gameObject;\n\n      text.setPosition(pos.x, pos.y);\n      text.setText(config.getText(playerData, playerId));\n    } else {\n      const config = element.config as BarUIConfig;\n      const container = element.gameObject;\n      const fg = (container as any)._fg;\n\n      container.setPosition(pos.x, pos.y);\n\n      // Update bar width based on value\n      const value = Math.max(0, Math.min(1, config.getValue(playerData, playerId)));\n      fg.width = config.width * value;\n    }\n  }\n\n  /**\n   * Destroy a UI element\n   */\n  private destroyElement(element: UIElement): void {\n    if (element.gameObject && element.gameObject.destroy) {\n      element.gameObject.destroy();\n    }\n  }\n\n  /**\n   * Type guard for TextUIConfig\n   */\n  private isTextConfig(config: TextUIConfig | BarUIConfig): config is TextUIConfig {\n    return 'getText' in config;\n  }\n}\n", "/**\n * CollisionManager - Declarative collision rule system\n *\n * Eliminates \"forgot to add collider for late-joining player\" bugs by:\n * - Declaring collision rules ONCE\n * - Auto-applying rules to all sprites (early and late-joining)\n * - Supporting sprites, SpriteManagers, and Phaser groups\n *\n * Usage:\n * ```ts\n * const collisionManager = adapter.createCollisionManager();\n *\n * // Register a ball sprite\n * collisionManager.registerSprite('ball', this.ball);\n *\n * // Declare collision rules ONCE\n * collisionManager.addCollision('ball', this.spriteManager);\n * // \u261D\uFE0F Automatically adds colliders for all current AND future paddles!\n *\n * // With custom handler\n * collisionManager.addCollision(this.bulletGroup, this.enemyGroup, {\n *   onCollide: (bullet, enemy) => {\n *     enemy.takeDamage(bullet.damage);\n *     bullet.destroy();\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface CollisionRule {\n  a: string | SpriteManager | any; // Phaser.Physics.Arcade.Group or sprite\n  b: string | SpriteManager | any;\n  handler?: (objA: any, objB: any) => void;\n}\n\nexport interface CollisionManagerConfig {\n  /**\n   * Optional: Global collision handler\n   * Called for all collisions if no specific handler provided\n   */\n  onCollide?: (obj1: any, obj2: any) => void;\n}\n\nexport class CollisionManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: CollisionManagerConfig;\n  private rules: CollisionRule[] = [];\n  private colliders: any[] = []; // Phaser.Physics.Arcade.Collider instances\n  private namedSprites: Map<string, any> = new Map(); // key -> sprite\n  private spriteToColliders: WeakMap<any, Set<any>> = new WeakMap(); // sprite -> Set of colliders\n\n  constructor(adapter: PhaserAdapter, scene: any, config?: CollisionManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config || {};\n  }\n\n  /**\n   * Register a sprite by name (for string-based collision rules)\n   *\n   * @example\n   * ```ts\n   * collisionManager.registerSprite('ball', this.ball);\n   * collisionManager.addCollision('ball', paddleManager);\n   * ```\n   */\n  registerSprite(key: string, sprite: any): void {\n    this.namedSprites.set(key, sprite);\n    this.reapplyRules();\n  }\n\n  /**\n   * Unregister a sprite by name\n   */\n  unregisterSprite(key: string): void {\n    const sprite = this.namedSprites.get(key);\n    if (sprite) {\n      this.removeCollidersForSprite(sprite);\n    }\n    this.namedSprites.delete(key);\n  }\n\n  /**\n   * Add collision between sprites/groups/managers\n   *\n   * Supports:\n   * - String keys (via registerSprite)\n   * - SpriteManager instances (auto-syncs with new sprites)\n   * - Phaser sprites or groups\n   */\n  addCollision(\n    a: string | SpriteManager | any,\n    b: string | SpriteManager | any,\n    options?: {\n      onCollide?: (obj1: any, obj2: any) => void;\n    }\n  ): void {\n    const rule: CollisionRule = {\n      a,\n      b,\n      handler: options?.onCollide\n    };\n\n    this.rules.push(rule);\n\n    // If either side is a SpriteManager, install onAdd hooks\n    if (this.isSpriteManager(a)) {\n      this.hookSpriteManager(a as SpriteManager);\n    }\n    if (this.isSpriteManager(b)) {\n      this.hookSpriteManager(b as SpriteManager);\n    }\n\n    // Apply rule immediately for existing sprites\n    this.applyRule(rule);\n  }\n\n  /**\n   * Remove collision rule\n   */\n  removeCollision(a: string | SpriteManager | any, b: string | SpriteManager | any): void {\n    const ruleIndex = this.rules.findIndex(r =>\n      (r.a === a && r.b === b) || (r.a === b && r.b === a)\n    );\n\n    if (ruleIndex !== -1) {\n      this.rules.splice(ruleIndex, 1);\n      // Note: We don't remove existing colliders, just stop creating new ones\n    }\n  }\n\n  /**\n   * Cleanup all colliders\n   */\n  destroy(): void {\n    for (const collider of this.colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n    }\n    this.colliders.length = 0;\n    this.rules.length = 0;\n    this.namedSprites.clear();\n  }\n\n  /**\n   * Install onAdd hook on a SpriteManager to re-apply rules when sprites are added\n   */\n  private hookSpriteManager(manager: SpriteManager): void {\n    // Check if already hooked\n    if ((manager as any)._collisionManagerHooked) {\n      return;\n    }\n    (manager as any)._collisionManagerHooked = true;\n\n    // Store original config\n    const originalConfig = (manager as any).config;\n    const originalOnAdd = originalConfig.onAdd;\n\n    // Wrap onAdd to re-apply collision rules\n    originalConfig.onAdd = (sprite: any, key: string, data: any, context: any) => {\n      // Call original onAdd if it exists\n      if (originalOnAdd) {\n        originalOnAdd(sprite, key, data, context);\n      }\n\n      // Re-apply all collision rules involving this manager\n      this.reapplyRules();\n    };\n  }\n\n  /**\n   * Apply a single collision rule (create colliders)\n   */\n  private applyRule(rule: CollisionRule): void {\n    const objectsA = this.resolveToObjects(rule.a);\n    const objectsB = this.resolveToObjects(rule.b);\n\n    if (objectsA.length === 0 || objectsB.length === 0) {\n      // One or both sides have no objects yet\n      return;\n    }\n\n    const handler = rule.handler || this.config.onCollide;\n\n    // Create colliders for each combination\n    for (const objA of objectsA) {\n      for (const objB of objectsB) {\n        // Skip if collider already exists\n        if (this.hasCollider(objA, objB)) {\n          continue;\n        }\n\n        // Create the collider\n        const collider = this.scene.physics.add.collider(objA, objB, handler);\n        this.colliders.push(collider);\n\n        // Track colliders per sprite\n        this.trackCollider(objA, collider);\n        this.trackCollider(objB, collider);\n      }\n    }\n  }\n\n  /**\n   * Re-apply all collision rules (called when sprites are added)\n   */\n  private reapplyRules(): void {\n    for (const rule of this.rules) {\n      this.applyRule(rule);\n    }\n  }\n\n  /**\n   * Resolve a rule target to an array of Phaser objects\n   */\n  private resolveToObjects(target: string | SpriteManager | any): any[] {\n    if (typeof target === 'string') {\n      // It's a named sprite\n      const sprite = this.namedSprites.get(target);\n      return sprite ? [sprite] : [];\n    }\n\n    if (this.isSpriteManager(target)) {\n      // It's a SpriteManager - get all sprites\n      const sprites = Array.from((target as SpriteManager).getAll().values());\n      return sprites;\n    }\n\n    // It's a raw Phaser object (sprite or group)\n    return [target];\n  }\n\n  /**\n   * Check if target is a SpriteManager\n   */\n  private isSpriteManager(target: any): boolean {\n    return target && typeof target === 'object' && 'getAll' in target && 'add' in target;\n  }\n\n  /**\n   * Check if a collider already exists between two objects\n   */\n  private hasCollider(objA: any, objB: any): boolean {\n    const collidersA = this.spriteToColliders.get(objA);\n    const collidersB = this.spriteToColliders.get(objB);\n\n    if (!collidersA || !collidersB) {\n      return false;\n    }\n\n    // Check if any collider is shared\n    for (const collider of collidersA) {\n      if (collidersB.has(collider)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Track that a collider belongs to a sprite\n   */\n  private trackCollider(sprite: any, collider: any): void {\n    let colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) {\n      colliders = new Set();\n      this.spriteToColliders.set(sprite, colliders);\n    }\n    colliders.add(collider);\n  }\n\n  /**\n   * Remove all colliders associated with a sprite\n   */\n  private removeCollidersForSprite(sprite: any): void {\n    const colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) return;\n\n    for (const collider of colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n      const index = this.colliders.indexOf(collider);\n      if (index !== -1) {\n        this.colliders.splice(index, 1);\n      }\n    }\n\n    this.spriteToColliders.delete(sprite);\n  }\n}\n", "/**\n * PhysicsManager - Automates physics behavior based on inputs\n *\n * Eliminates manual physics loops by automatically reading inputs from state\n * and applying pre-defined or custom physics behaviors.\n *\n * @example\n * ```ts\n * // In scene.create()\n * this.physicsManager = this.adapter.createPhysicsManager({\n *   spriteManager: this.spriteManager,\n *   inputKey: 'inputs'\n * });\n *\n * this.physicsManager.addBehavior('platformer', {\n *   speed: 200,\n *   jumpPower: 350\n * });\n *\n * // In scene.update()\n * this.physicsManager.update();\n * ```\n */\n\nimport type { GameRuntime } from '@martini/core';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PlatformerBehaviorConfig {\n  speed?: number;\n  jumpPower?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    jump?: string;\n  };\n}\n\nexport interface TopDownBehaviorConfig {\n  speed?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    up?: string;\n    down?: string;\n  };\n}\n\nexport interface CustomBehaviorConfig {\n  apply: (sprite: any, input: any, body: Phaser.Physics.Arcade.Body) => void;\n}\n\nexport type BehaviorConfig = PlatformerBehaviorConfig | TopDownBehaviorConfig | CustomBehaviorConfig;\n\nexport interface PhysicsManagerConfig {\n  /** SpriteManager to get sprites from */\n  spriteManager: SpriteManager;\n\n  /** Key in state to read inputs from (e.g., 'inputs') */\n  inputKey?: string;\n\n  /** Key prefix for sprite keys (defaults to 'player-') */\n  spriteKeyPrefix?: string;\n}\n\nexport class PhysicsManager {\n  private runtime: GameRuntime;\n  private spriteManager: SpriteManager;\n  private inputKey: string;\n  private spriteKeyPrefix: string;\n  private behaviorType: 'platformer' | 'topDown' | 'custom' | null = null;\n  private behaviorConfig: BehaviorConfig | null = null;\n\n  constructor(runtime: GameRuntime, config: PhysicsManagerConfig) {\n    this.runtime = runtime;\n    this.spriteManager = config.spriteManager;\n    this.inputKey = config.inputKey || 'inputs';\n    this.spriteKeyPrefix = config.spriteKeyPrefix || 'player-';\n  }\n\n  /**\n   * Add a physics behavior\n   *\n   * @param type - Behavior type ('platformer', 'topDown', 'custom')\n   * @param config - Behavior configuration\n   */\n  addBehavior(\n    type: 'platformer',\n    config?: PlatformerBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'topDown',\n    config?: TopDownBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'custom',\n    config: CustomBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'platformer' | 'topDown' | 'custom',\n    config?: BehaviorConfig\n  ): void {\n    this.behaviorType = type;\n    this.behaviorConfig = config || {};\n  }\n\n  /**\n   * Update physics for all sprites (call in scene.update())\n   * Only runs on host.\n   */\n  update(): void {\n    // Only host applies physics\n    const transport = this.runtime.getTransport();\n    if (!transport.isHost()) return;\n\n    const state = this.runtime.getState() as any;\n    const inputs = state[this.inputKey];\n    if (!inputs) return;\n\n    // Apply physics to each player based on their input\n    for (const [playerId, playerInput] of Object.entries(inputs)) {\n      const sprite = this.spriteManager.get(`${this.spriteKeyPrefix}${playerId}`);\n      if (!sprite || !sprite.body) continue;\n\n      const body = sprite.body as Phaser.Physics.Arcade.Body;\n\n      if (this.behaviorType === 'platformer') {\n        this.applyPlatformerBehavior(body, playerInput as any, this.behaviorConfig as PlatformerBehaviorConfig);\n      } else if (this.behaviorType === 'topDown') {\n        this.applyTopDownBehavior(body, playerInput as any, this.behaviorConfig as TopDownBehaviorConfig);\n      } else if (this.behaviorType === 'custom' && this.behaviorConfig) {\n        const customConfig = this.behaviorConfig as CustomBehaviorConfig;\n        customConfig.apply(sprite, playerInput, body);\n      }\n    }\n  }\n\n  private applyPlatformerBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: PlatformerBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const jumpPower = config.jumpPower || 350;\n    const keys = config.keys || { left: 'left', right: 'right', jump: 'up' };\n\n    // Horizontal movement\n    if (input[keys.left!]) {\n      body.setVelocityX(-speed);\n    } else if (input[keys.right!]) {\n      body.setVelocityX(speed);\n    } else {\n      body.setVelocityX(0);\n    }\n\n    // Jumping (only if on ground)\n    if (input[keys.jump!] && body.touching.down) {\n      body.setVelocityY(-jumpPower);\n    }\n  }\n\n  private applyTopDownBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: TopDownBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const keys = config.keys || { left: 'left', right: 'right', up: 'up', down: 'down' };\n\n    let vx = 0;\n    let vy = 0;\n\n    if (input[keys.left!]) vx = -speed;\n    if (input[keys.right!]) vx = speed;\n    if (input[keys.up!]) vy = -speed;\n    if (input[keys.down!]) vy = speed;\n\n    body.setVelocity(vx, vy);\n  }\n}\n", "/**\n * PhaserAdapter - Bridge between Phaser and @martini/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\nimport { PlayerUIManager, type PlayerUIManagerConfig } from './helpers/PlayerUIManager.js';\nimport { CollisionManager, type CollisionManagerConfig } from './helpers/CollisionManager.js';\nimport { PhysicsManager, type PhysicsManagerConfig } from './helpers/PhysicsManager.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 50ms / 20 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Interpolate movement on clients for smoothness */\n  interpolate?: boolean;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Enable automatic interpolation for remote sprites (default: true)\n   * When enabled, remote sprites smoothly lerp to target positions\n   */\n  autoInterpolate?: boolean;\n\n  /**\n   * Interpolation lerp factor (default: 0.3)\n   * Lower = smoother but laggier, Higher = snappier but jerkier\n   * Range: 0.1 (very smooth) to 0.5 (very snappy)\n   */\n  lerpFactor?: number;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   autoInterpolate: true,           // optional, defaults to true\n *   lerpFactor: 0.3                  // optional, defaults to 0.3\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<string, { sprite: any; options: SpriteTrackingOptions }> = new Map();\n  private remoteSprites: Map<string, any> = new Map(); // Sprites created for remote players\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly autoInterpolate: boolean;\n  private readonly lerpFactor: number;\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.autoInterpolate = config.autoInterpolate !== false; // default true\n    this.lerpFactor = config.lerpFactor ?? 0.3;\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Backwards-compatible helper - alias for {@link myId}\n   */\n  getMyPlayerId(): string {\n    return this.myId;\n  }\n\n  /**\n   * Get the current player's state object from the runtime\n   *\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  getMyPlayer<TPlayer = any>(playersKey: string = 'players'): TPlayer | undefined {\n    const state = this.runtime.getState() as any;\n    const players = state?.[playersKey];\n    if (!players) return undefined;\n    return players[this.getMyPlayerId()];\n  }\n\n  /**\n   * Subscribe to changes in the current player's state\n   *\n   * @param callback Invoked whenever the local player's record changes\n   * @param playersKey Key in the state where player records are stored (default: 'players')\n   */\n  onMyPlayerChange<TPlayer = any>(\n    callback: (player: TPlayer | undefined) => void,\n    playersKey: string = 'players'\n  ): () => void {\n    let lastValue = this.getMyPlayer<TPlayer>(playersKey);\n    callback(lastValue);\n\n    return this.runtime.onChange((state: any) => {\n      const players = state?.[playersKey];\n      const nextValue = players ? players[this.getMyPlayerId()] : undefined;\n      if (nextValue === lastValue) {\n        return;\n      }\n      lastValue = nextValue;\n      callback(nextValue);\n    });\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Expose the underlying Phaser scene\n   */\n  getScene(): any {\n    return this.scene;\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, { sprite, options });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 50;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // Note: We do NOT immediately sync here to avoid infinite loops\n    // when trackSprite is called inside onChange callbacks.\n    // The interval-based sync will handle the first sync.\n  }\n\n  /**\n   * Stop tracking a sprite\n   */\n  untrackSprite(key: string): void {\n    this.trackedSprites.delete(key);\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[this.spriteNamespace];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, { sprite, options }] of this.trackedSprites.entries()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n      const sprites = state[this.spriteNamespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Set static metadata for a tracked sprite (host only)\n   */\n  setSpriteStaticData(key: string, data: Record<string, any>): void {\n    if (!this.isHost()) return;\n\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n      const sprites = state[this.spriteNamespace];\n      sprites[key] = { ...data, ...sprites[key] };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   */\n  private updateSpritesFromState(state: any): void {\n    const sprites = state[this.spriteNamespace];\n    if (this.isHost() || !sprites) return;\n\n    // Update tracked sprites (sprites that exist on this client)\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const spriteData = sprites[key];\n      if (spriteData) {\n        this.applySpriteData(tracked.sprite, spriteData);\n      }\n    }\n\n    // Update remote sprites (sprites from other players)\n    // Store target positions for interpolation\n    for (const [key, spriteData] of Object.entries(sprites)) {\n      // Skip if this is our own sprite\n      if (this.trackedSprites.has(key)) continue;\n\n      // If we have a remote sprite for this key, store target position\n      const remoteSprite = this.remoteSprites.get(key);\n      if (remoteSprite) {\n        // Store target position for smooth interpolation\n        remoteSprite._targetX = (spriteData as any).x;\n        remoteSprite._targetY = (spriteData as any).y;\n        remoteSprite._targetRotation = (spriteData as any).rotation;\n\n        // First update - snap to position immediately\n        if (remoteSprite._targetX !== undefined && remoteSprite.x === undefined) {\n          remoteSprite.x = remoteSprite._targetX;\n          remoteSprite.y = remoteSprite._targetY;\n          remoteSprite.rotation = remoteSprite._targetRotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any): void {\n    this.remoteSprites.set(key, sprite);\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Note: If autoInterpolate is enabled in config, you don't need to call this manually.\n   */\n  updateInterpolation(): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    for (const [key, sprite] of this.remoteSprites.entries()) {\n      if (sprite._targetX !== undefined) {\n        // Lerp towards target position\n        sprite.x += (sprite._targetX - sprite.x) * this.lerpFactor;\n        sprite.y += (sprite._targetY - sprite.y) * this.lerpFactor;\n\n        if (sprite._targetRotation !== undefined) {\n          sprite.rotation += (sprite._targetRotation - sprite.rotation) * this.lerpFactor;\n        }\n      }\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const sprite = this.remoteSprites.get(key);\n    if (sprite && sprite.destroy) {\n      sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    return new SpriteManager(this, config);\n  }\n\n  /**\n   * Create a PlayerUIManager for automatically managed player HUD elements\n   */\n  createPlayerUIManager(config: PlayerUIManagerConfig): PlayerUIManager {\n    return new PlayerUIManager(this, this.scene, config);\n  }\n\n  /**\n   * Create a CollisionManager for declarative collision rules\n   */\n  createCollisionManager(config?: CollisionManagerConfig): CollisionManager {\n    return new CollisionManager(this, this.scene, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n\n  /**\n   * Create a PhysicsManager for automatic physics behaviors\n   */\n  createPhysicsManager(config: PhysicsManagerConfig): PhysicsManager {\n    return new PhysicsManager(this.runtime, config);\n  }\n}\n", "/**\n * HUD Helper - Unified player HUD/UI for multiplayer games\n *\n * Eliminates the manual HUD boilerplate by automatically creating and managing\n * title, role, and control hint text based on the current player state.\n *\n * @example\n * ```ts\n * import { createPlayerHUD } from '@martini/phaser';\n *\n * // In scene.create()\n * this.hud = createPlayerHUD(this.adapter, this, {\n *   title: 'Fire & Ice - Cooperative Platformer',\n *\n *   roleText: (myPlayer) => {\n *     if (!myPlayer) return 'Spectator';\n *     return myPlayer.role === 'fire' ? 'Fire Player' : 'Ice Player';\n *   },\n *\n *   controlHints: (myPlayer) => {\n *     if (!myPlayer) return '';\n *     return 'Arrow Keys + SPACE to Jump';\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface HUDLayout {\n\t/** Position for title text */\n\ttitle?: { x: number; y: number };\n\t/** Position for role text */\n\trole?: { x: number; y: number };\n\t/** Position for controls text */\n\tcontrols?: { x: number; y: number };\n}\n\nexport interface HUDTextStyle {\n\tfontSize?: string;\n\tcolor?: string;\n\tfontStyle?: string;\n\tbackgroundColor?: string;\n\tpadding?: { x: number; y: number };\n}\n\nexport interface PlayerHUDConfig<TPlayer = any> {\n\t/** Title text (static) */\n\ttitle?: string;\n\t/** Title text style */\n\ttitleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate role text from player data\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @returns Text to display\n\t */\n\troleText?: (myPlayer: TPlayer | undefined) => string;\n\t/** Role text style */\n\troleStyle?: HUDTextStyle;\n\n\t/**\n\t * Generate control hints from player data\n\t * @param myPlayer - Current player data or undefined if spectator\n\t * @returns Text to display\n\t */\n\tcontrolHints?: (myPlayer: TPlayer | undefined) => string;\n\t/** Control hints text style */\n\tcontrolsStyle?: HUDTextStyle;\n\n\t/** Custom layout positions */\n\tlayout?: HUDLayout;\n\n\t/** Key in state where players are stored (default: 'players') */\n\tplayersKey?: string;\n}\n\nexport interface PlayerHUD {\n\t/** Update HUD (automatically called when player changes) */\n\tupdate: () => void;\n\t/** Destroy HUD elements */\n\tdestroy: () => void;\n\t/** Get title text object */\n\tgetTitleText: () => Phaser.GameObjects.Text | null;\n\t/** Get role text object */\n\tgetRoleText: () => Phaser.GameObjects.Text | null;\n\t/** Get controls text object */\n\tgetControlsText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a player HUD with automatic role/control updates\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - HUD configuration\n * @returns PlayerHUD instance\n */\nexport function createPlayerHUD<TPlayer = any>(\n\tadapter: PhaserAdapter,\n\tscene: Phaser.Scene,\n\tconfig: PlayerHUDConfig<TPlayer>\n): PlayerHUD {\n\tconst playersKey = config.playersKey || 'players';\n\n\t// Default layout\n\tconst layout = {\n\t\ttitle: config.layout?.title || { x: 400, y: 20 },\n\t\trole: config.layout?.role || { x: 400, y: 50 },\n\t\tcontrols: config.layout?.controls || { x: 400, y: 75 }\n\t};\n\n\t// Default styles\n\tconst titleStyle = {\n\t\tfontSize: config.titleStyle?.fontSize || '24px',\n\t\tcolor: config.titleStyle?.color || '#000',\n\t\tfontStyle: config.titleStyle?.fontStyle || 'bold',\n\t\tbackgroundColor: config.titleStyle?.backgroundColor,\n\t\tpadding: config.titleStyle?.padding\n\t};\n\n\tconst roleStyle = {\n\t\tfontSize: config.roleStyle?.fontSize || '16px',\n\t\tcolor: config.roleStyle?.color || '#000',\n\t\tfontStyle: config.roleStyle?.fontStyle,\n\t\tbackgroundColor: config.roleStyle?.backgroundColor,\n\t\tpadding: config.roleStyle?.padding\n\t};\n\n\tconst controlsStyle = {\n\t\tfontSize: config.controlsStyle?.fontSize || '14px',\n\t\tcolor: config.controlsStyle?.color || '#333',\n\t\tfontStyle: config.controlsStyle?.fontStyle,\n\t\tbackgroundColor: config.controlsStyle?.backgroundColor,\n\t\tpadding: config.controlsStyle?.padding\n\t};\n\n\t// Create text objects\n\tlet titleText: Phaser.GameObjects.Text | null = null;\n\tlet roleText: Phaser.GameObjects.Text | null = null;\n\tlet controlsText: Phaser.GameObjects.Text | null = null;\n\n\t// Create title (static)\n\tif (config.title) {\n\t\ttitleText = scene.add.text(layout.title.x, layout.title.y, config.title, titleStyle);\n\t\ttitleText.setOrigin(0.5);\n\t}\n\n\t// Create role text (dynamic)\n\tif (config.roleText) {\n\t\troleText = scene.add.text(layout.role.x, layout.role.y, 'Loading...', roleStyle);\n\t\troleText.setOrigin(0.5);\n\t}\n\n\t// Create controls text (dynamic)\n\tif (config.controlHints) {\n\t\tcontrolsText = scene.add.text(layout.controls.x, layout.controls.y, '', controlsStyle);\n\t\tcontrolsText.setOrigin(0.5);\n\t}\n\n\t// Update function\n\tconst update = () => {\n\t\tconst myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n\t\tif (roleText && config.roleText) {\n\t\t\troleText.setText(config.roleText(myPlayer));\n\t\t}\n\n\t\tif (controlsText && config.controlHints) {\n\t\t\tcontrolsText.setText(config.controlHints(myPlayer));\n\t\t}\n\t};\n\n\t// Subscribe to player changes\n\tconst unsubscribe = adapter.onMyPlayerChange<TPlayer>((myPlayer) => {\n\t\tif (roleText && config.roleText) {\n\t\t\troleText.setText(config.roleText(myPlayer));\n\t\t}\n\n\t\tif (controlsText && config.controlHints) {\n\t\t\tcontrolsText.setText(config.controlHints(myPlayer));\n\t\t}\n\t}, playersKey);\n\n\t// Ensure HUD shows correct values immediately\n\tupdate();\n\n\t// Return HUD interface\n\treturn {\n\t\tupdate,\n\t\tdestroy: () => {\n\t\t\tunsubscribe();\n\t\t\ttitleText?.destroy();\n\t\t\troleText?.destroy();\n\t\t\tcontrolsText?.destroy();\n\t\t},\n\t\tgetTitleText: () => titleText,\n\t\tgetRoleText: () => roleText,\n\t\tgetControlsText: () => controlsText\n\t};\n}\n", "/**\n * @martini/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini/core';\nimport { LocalTransport } from '@martini/transport-local';\n// import { TrysteroTransport } from '@martini/transport-trystero'; // Disabled for IDE\nimport { IframeBridgeTransport } from '@martini/transport-iframe-bridge';\nimport type { Transport } from '@martini/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n  };\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): { runtime: GameRuntime<TState>; phaser: Phaser.Game } {\n  // Read platform-injected config\n  const platformConfig = (window as any).__MARTINI_CONFIG__ as MartiniConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __MARTINI_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: [transport.getPlayerId()]\n    }\n  );\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  const phaserGame = new Phaser.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any).__MARTINI_IDE__) {\n    (window as any).__MARTINI_IDE__.registerRuntime(runtime);\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    // case 'trystero':\n    //   return new TrysteroTransport({\n    //     appId: config.appId || 'martini',\n    //     roomId: config.roomId,\n    //     isHost: config.isHost\n    //   });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local' and 'iframe-bridge' are supported in IDE mode.`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
