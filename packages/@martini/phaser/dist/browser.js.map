{
  "version": 3,
  "sources": ["../src/helpers/SpriteManager.ts", "../src/helpers/InputProfiles.ts", "../src/helpers/InputManager.ts", "../src/helpers/PhysicsManager.ts", "../src/helpers/CollisionManager.ts", "../src/helpers/PlayerUIManager.ts", "../src/PhaserAdapter.ts", "../src/helpers/HUDHelper.ts", "../src/runtime.ts"],
  "sourcesContent": ["/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Optional: Enrich sprite data with additional game state\n   * Returns player state that gets merged with sprite sync data (_sprites)\n   *\n   * @deprecated Use staticProperties instead. selectState creates race conditions\n   * because it reads from a different part of state that may not be synced yet.\n   *\n   * @example\n   * ```ts\n   * selectState: (key, runtime) => {\n   *   const playerId = key.replace('player-', '');\n   *   return runtime.getState().players[playerId];\n   * },\n   *\n   * onCreate: (key, data) => {\n   *   // data now includes BOTH sprite sync AND player state!\n   *   const color = data.role === 'fire' ? 0xff3300 : 0x0033ff;\n   *   return this.add.circle(data.x, data.y, 20, color);\n   * }\n   * ```\n   */\n  selectState?: (key: string) => Partial<TData>;\n\n  /**\n   * Static metadata properties (synced ONCE on sprite creation)\n   * Examples: role, name, color, team\n   *\n   * These are NOT re-synced every frame like syncProperties.\n   * Use this for data that doesn't change (or rarely changes) during gameplay.\n   *\n   * @example\n   * ```ts\n   * staticProperties: ['role', 'name', 'team']\n   * ```\n   */\n  staticProperties?: string[];\n\n  /**\n   * Dynamic properties to sync continuously (default: x, y, rotation, alpha)\n   * Examples: x, y, rotation, velocity\n   *\n   * These are synced every frame (or at syncInterval rate).\n   * Use this for physics data that changes frequently.\n   */\n  syncProperties?: string[];\n\n  /**\n   * Sync interval in ms (default: 50ms / 20 FPS)\n   */\n  syncInterval?: number;\n\n  /**\n   * Automatic label configuration\n   * SpriteManager handles creation, positioning, and cleanup\n   *\n   * @example\n   * ```ts\n   * label: {\n   *   getText: (data) => data.name || 'Player',\n   *   offset: { y: -30 },\n   *   style: { fontSize: '12px', color: '#fff' }\n   * }\n   * ```\n   */\n  label?: {\n    /**\n     * Function to generate label text from sprite data\n     */\n    getText: (data: TData) => string;\n\n    /**\n     * Offset from sprite position\n     */\n    offset?: { x?: number; y?: number };\n\n    /**\n     * Phaser text style\n     */\n    style?: Phaser.Types.GameObjects.Text.TextStyle;\n  };\n\n  /**\n   * Called when static metadata changes (e.g., role swap, name change)\n   * Use this to update sprite visuals based on metadata\n   *\n   * @example\n   * ```ts\n   * onMetadataChange: (sprite, oldMeta, newMeta) => {\n   *   if (oldMeta.role !== newMeta.role) {\n   *     const newColor = newMeta.role === 'fire' ? 0xff3300 : 0x0033ff;\n   *     sprite.setFillStyle(newColor);\n   *   }\n   * }\n   * ```\n   */\n  onMetadataChange?: (sprite: any, oldMetadata: Partial<TData>, newMetadata: Partial<TData>) => void;\n\n  /**\n   * Called after sprite is fully created and ready\n   * Fires for BOTH initial sprites and late-joining sprites\n   * Use this for inter-sprite setup (collisions, custom logic, etc.)\n   *\n   * @example\n   * ```ts\n   * onAdd: (sprite, key, data, context) => {\n   *   // Add collision with ball (handles late-joining players!)\n   *   if (this.ball) {\n   *     this.physics.add.collider(sprite, this.ball);\n   *   }\n   * }\n   * ```\n   */\n  onAdd?: (\n    sprite: any,\n    key: string,\n    data: TData,\n    context: {\n      manager: SpriteManager<TData>;\n      allSprites: Map<string, any>;\n    }\n  ) => void;\n\n  /**\n   * Authority mode (default: 'host-authoritative')\n   *\n   * - 'host-authoritative': add() only works on host, clients auto-sync from state\n   *   Use this for player sprites, NPCs, projectiles - anything the host controls\n   *   Prevents double-rendering bugs where clients create duplicate sprites\n   *\n   * - 'shared': add() works on both host and client (legacy behavior)\n   *   Use this if you need to create client-local sprites (UI elements, effects)\n   *\n   * @default 'host-authoritative'\n   *\n   * @example\n   * ```ts\n   * // Default - prevents double-rendering on clients\n   * const playerManager = adapter.createSpriteManager({\n   *   onCreate: (key, data) => this.add.sprite(data.x, data.y, 'player')\n   * });\n   *\n   * // Opt-in to shared mode for client-local sprites\n   * const effectManager = adapter.createSpriteManager({\n   *   authority: 'shared',\n   *   onCreate: (key, data) => this.add.particles(data.x, data.y, 'sparkle')\n   * });\n   * ```\n   */\n  authority?: 'host-authoritative' | 'shared';\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private labels = new Map<string, any>(); // Phaser.GameObjects.Text\n  private metadata = new Map<string, Partial<TData>>(); // Track static metadata for change detection\n  private localSprites = new Set<string>(); // Track sprites created locally (via add())\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n  private scene?: any; // Phaser.Scene (needed for creating labels)\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n\n    // Emit deprecation warning for selectState\n    if (config.selectState && process.env.NODE_ENV !== 'production') {\n      console.warn(\n        '[SpriteManager] DEPRECATION WARNING: selectState is prone to race conditions.\\n' +\n        'Use staticProperties instead to avoid timing bugs.\\n' +\n        'See: https://docs.martini.dev/guides/sprite-sync'\n      );\n    }\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite\n   *\n   * In host-authoritative mode (default):\n   * - HOST: Creates sprite with physics\n   * - CLIENT: No-op (sprites auto-created from state sync)\n   *\n   * In shared mode:\n   * - Both host and client create sprites when add() is called\n   */\n  add(key: string, data: TData): any {\n    const authority = this.config.authority || 'host-authoritative';\n\n    // In host-authoritative mode, clients don't create sprites via add()\n    // They're automatically created by syncFromState() instead\n    if (authority === 'host-authoritative' && !this.adapter.isHost()) {\n      return null; // Silent no-op on client\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Enrich data with additional state if selectState is provided (deprecated)\n    const enrichedData = this.config.selectState\n      ? { ...data, ...this.config.selectState(key) }\n      : data;\n\n    // STEP 1: Write static metadata to _sprites FIRST (before tracking)\n    // This ensures clients receive metadata immediately on sprite creation\n    if (this.config.staticProperties && this.config.staticProperties.length > 0) {\n      const staticData: any = {};\n      for (const prop of this.config.staticProperties) {\n        if (prop in enrichedData) {\n          staticData[prop] = (enrichedData as any)[prop];\n        }\n      }\n\n      // Store metadata for change detection\n      this.metadata.set(key, staticData);\n\n      // Write to _sprites state immediately (one-time)\n      (this.adapter as any).runtime.mutateState((state: any) => {\n        const spriteNamespace = (this.adapter as any).spriteNamespace || '_sprites';\n        if (!state[spriteNamespace]) {\n          state[spriteNamespace] = {};\n        }\n        state[spriteNamespace][key] = staticData;\n      });\n    }\n\n    // STEP 2: Create sprite\n    const sprite = this.config.onCreate(key, enrichedData);\n\n    // Skip if onCreate returned null (waiting for complete data)\n    if (!sprite) {\n      return null;\n    }\n\n    this.sprites.set(key, sprite);\n\n    // Track that we created this sprite locally (important for syncFromState)\n    this.localSprites.add(key);\n\n    // STEP 3: Create label if configured (host only, for consistency)\n    if (this.config.label) {\n      this.createLabel(key, sprite, enrichedData);\n    }\n\n    // STEP 4: Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, enrichedData);\n    }\n\n    // STEP 5: Track for automatic sync of dynamic properties (position, rotation, etc.)\n    this.adapter.trackSprite(sprite, key, {\n      properties: this.config.syncProperties || ['x', 'y', 'rotation', 'alpha'],\n      syncInterval: this.config.syncInterval\n    });\n\n    // STEP 6: Call onAdd lifecycle hook (after sprite is fully ready)\n    if (this.config.onAdd) {\n      this.config.onAdd(sprite, key, enrichedData, {\n        manager: this,\n        allSprites: this.sprites\n      });\n    }\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy label if exists\n    const label = this.labels.get(key);\n    if (label && label.destroy) {\n      label.destroy();\n    }\n    this.labels.delete(key);\n\n    // Remove metadata\n    this.metadata.delete(key);\n\n    // Remove from local sprites tracking\n    this.localSprites.delete(key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n\n    // Update label positions to follow sprites\n    if (this.config.label && this.labels.size > 0) {\n      const offsetX = this.config.label.offset?.x || 0;\n      const offsetY = this.config.label.offset?.y || 0;\n\n      for (const [key, sprite] of this.sprites.entries()) {\n        const label = this.labels.get(key);\n        if (label && sprite) {\n          label.setPosition(sprite.x + offsetX, sprite.y + offsetY);\n        }\n      }\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteNamespace = (this.adapter as any).spriteNamespace || '_sprites';\n    const spriteData = state[spriteNamespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      if (!this.sprites.has(key)) {\n        // NEW SPRITE: Skip if we already created this sprite locally via add()\n        // This prevents double-rendering bugs where clients create duplicate sprites\n        if (this.localSprites.has(key)) {\n          continue; // Don't auto-create sprite we already created locally!\n        }\n        // NEW SPRITE: Enrich data with additional state if selectState is provided (deprecated)\n        const enrichedData = this.config.selectState\n          ? { ...data, ...this.config.selectState(key) }\n          : data;\n\n        // Store initial metadata\n        if (this.config.staticProperties && this.config.staticProperties.length > 0) {\n          const staticData: any = {};\n          for (const prop of this.config.staticProperties) {\n            if (prop in enrichedData) {\n              staticData[prop] = (enrichedData as any)[prop];\n            }\n          }\n          this.metadata.set(key, staticData);\n        }\n\n        // Create new sprite\n        const sprite = this.config.onCreate(key, enrichedData);\n\n        // Skip if onCreate returned null (waiting for complete data)\n        if (!sprite) {\n          return;\n        }\n\n        this.sprites.set(key, sprite);\n        this.adapter.registerRemoteSprite(key, sprite);\n\n        // Create label if configured\n        if (this.config.label) {\n          this.createLabel(key, sprite, enrichedData);\n        }\n\n        // Call onAdd lifecycle hook (after sprite is fully ready)\n        if (this.config.onAdd) {\n          this.config.onAdd(sprite, key, enrichedData, {\n            manager: this,\n            allSprites: this.sprites\n          });\n        }\n      } else {\n        // EXISTING SPRITE: Check for metadata changes\n        const oldMetadata = this.metadata.get(key) || {};\n        const newMetadata: any = {};\n\n        // Extract current metadata from data\n        if (this.config.staticProperties) {\n          for (const prop of this.config.staticProperties) {\n            if (prop in data) {\n              newMetadata[prop] = data[prop];\n            }\n          }\n        }\n\n        // Check if metadata changed\n        const metadataChanged = this.hasMetadataChanged(oldMetadata, newMetadata);\n\n        if (metadataChanged) {\n          // Update stored metadata\n          this.metadata.set(key, newMetadata);\n\n          // Call metadata change handler\n          const sprite = this.sprites.get(key);\n          if (this.config.onMetadataChange && sprite) {\n            this.config.onMetadataChange(sprite, oldMetadata, newMetadata);\n          }\n\n          // Update label text if needed\n          if (this.config.label) {\n            const label = this.labels.get(key);\n            if (label) {\n              const enrichedData = this.config.selectState\n                ? { ...data, ...this.config.selectState(key) }\n                : data;\n              label.setText(this.config.label.getText(enrichedData as TData));\n            }\n          }\n        }\n\n        // Call onUpdate if provided (for other dynamic updates)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          const enrichedData = this.config.selectState\n            ? { ...data, ...this.config.selectState(key) }\n            : data;\n          this.config.onUpdate(sprite, enrichedData);\n        }\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n\n  /**\n   * Helper: Create a label for a sprite\n   */\n  private createLabel(key: string, sprite: any, data: TData): void {\n    if (!this.config.label) return;\n\n    // Get scene from sprite (Phaser sprites have a reference to their scene)\n    const scene = sprite.scene;\n    if (!scene || !scene.add) {\n      console.warn('[SpriteManager] Cannot create label: sprite has no scene');\n      return;\n    }\n\n    const labelText = this.config.label.getText(data);\n    const label = scene.add.text(\n      sprite.x,\n      sprite.y,\n      labelText,\n      this.config.label.style || {}\n    ).setOrigin(0.5);\n\n    this.labels.set(key, label);\n  }\n\n  /**\n   * Helper: Check if metadata has changed\n   */\n  private hasMetadataChanged(oldMeta: Partial<TData>, newMeta: Partial<TData>): boolean {\n    // Check if any static property changed\n    if (!this.config.staticProperties) return false;\n\n    for (const prop of this.config.staticProperties) {\n      if ((oldMeta as any)[prop] !== (newMeta as any)[prop]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n", "/**\n * Input Profiles - Pre-defined control schemes\n *\n * Eliminates manual key binding boilerplate by providing standard control patterns.\n */\n\nimport type { KeyBindings } from './InputManager.js';\n\nexport interface AggregatedProfileConfig {\n  /** Profile type */\n  type: 'aggregated';\n\n  /** Action name to submit */\n  action: string;\n\n  /** Map of field names to key codes */\n  keys: Record<string, string>;\n\n  /** Continuous or oneshot mode */\n  mode?: 'continuous' | 'oneshot';\n}\n\nexport interface PerKeyProfileConfig {\n  /** Profile type */\n  type: 'per-key';\n\n  /** Key bindings for this profile */\n  bindings: KeyBindings;\n}\n\nexport interface InputProfile {\n  /** Profile name */\n  name: string;\n\n  /** Profile configuration (aggregated or per-key) */\n  config: AggregatedProfileConfig | PerKeyProfileConfig;\n\n  /** Description of the control scheme */\n  description?: string;\n}\n\nexport interface ProfileOptions {\n  /** Override specific keys */\n  overrides?: Partial<KeyBindings>;\n\n  /** Player number (1-based). Changes arrow keys to WASD for player 2 */\n  player?: 1 | 2;\n\n  /** Override action names */\n  action?: string;\n}\n\n/**\n * Built-in input profiles\n */\nexport const BUILT_IN_PROFILES: Record<string, InputProfile> = {\n  platformer: {\n    name: 'platformer',\n    description: 'Side-scrolling platformer controls (Arrow keys + Space for jump)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'Space'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  platformerWASD: {\n    name: 'platformerWASD',\n    description: 'Platformer controls with WASD',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDown: {\n    name: 'topDown',\n    description: '4-directional movement (Arrow keys)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'ArrowLeft',\n        right: 'ArrowRight',\n        up: 'ArrowUp',\n        down: 'ArrowDown'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  topDownWASD: {\n    name: 'topDownWASD',\n    description: '4-directional movement (WASD)',\n    config: {\n      type: 'aggregated',\n      action: 'move',\n      keys: {\n        left: 'A',\n        right: 'D',\n        up: 'W',\n        down: 'S'\n      },\n      mode: 'continuous'\n    }\n  },\n\n  shooter: {\n    name: 'shooter',\n    description: 'Top-down shooter (WASD for move, Space for shoot)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'Space': { action: 'shoot', mode: 'oneshot' },\n      }\n    }\n  },\n\n  twinStick: {\n    name: 'twinStick',\n    description: 'Twin-stick shooter (WASD for move, Arrow keys for aim)',\n    config: {\n      type: 'per-key',\n      bindings: {\n        'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n        'A': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n        'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n        'D': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n        'ArrowLeft': { action: 'aim', input: { x: -1 }, mode: 'continuous' },\n        'ArrowRight': { action: 'aim', input: { x: 1 }, mode: 'continuous' },\n        'ArrowUp': { action: 'aim', input: { y: -1 }, mode: 'continuous' },\n        'ArrowDown': { action: 'aim', input: { y: 1 }, mode: 'continuous' },\n      }\n    }\n  }\n};\n\n/**\n * Custom profile registry\n */\nconst customProfiles = new Map<string, InputProfile>();\n\n/**\n * Register a custom input profile\n *\n * @param name - Profile name\n * @param profile - Profile configuration\n *\n * @example\n * ```ts\n * registerProfile('custom-platformer', {\n *   name: 'custom-platformer',\n *   bindings: {\n *     'A': { action: 'move', input: { left: true }, mode: 'continuous' },\n *     'D': { action: 'move', input: { right: true }, mode: 'continuous' },\n *     'W': { action: 'jump', mode: 'oneshot' },\n *   }\n * });\n * ```\n */\nexport function registerProfile(name: string, profile: InputProfile): void {\n  customProfiles.set(name, profile);\n}\n\n/**\n * Get a profile by name (checks custom profiles first, then built-in)\n *\n * @param name - Profile name\n * @returns Profile or undefined if not found\n */\nexport function getProfile(name: string): InputProfile | undefined {\n  return customProfiles.get(name) || BUILT_IN_PROFILES[name];\n}\n\n/**\n * Apply profile options to a profile config\n *\n * @param profile - Original profile\n * @param options - Profile options\n * @returns Modified profile config\n */\nexport function applyProfileOptions(\n  profile: InputProfile,\n  options?: ProfileOptions\n): AggregatedProfileConfig | PerKeyProfileConfig {\n  if (!options) return profile.config;\n\n  const config = profile.config;\n\n  // For aggregated profiles\n  if (config.type === 'aggregated') {\n    let keys = { ...config.keys };\n\n    // Apply player number (swap arrow keys for WASD)\n    if (options.player === 2) {\n      const keyMap: Record<string, string> = {\n        'ArrowLeft': 'A',\n        'ArrowRight': 'D',\n        'ArrowUp': 'W',\n        'ArrowDown': 'S',\n        'Space': 'Space', // Keep Space unchanged\n      };\n\n      const newKeys: Record<string, string> = {};\n      for (const [field, key] of Object.entries(keys)) {\n        newKeys[field] = keyMap[key] || key;\n      }\n      keys = newKeys;\n    }\n\n    return {\n      type: 'aggregated',\n      action: options.action || config.action,\n      keys,\n      mode: config.mode\n    };\n  }\n\n  // For per-key profiles\n  let bindings = { ...config.bindings };\n\n  // Apply player number (swap arrow keys for WASD)\n  if (options.player === 2) {\n    const keyMap: Record<string, string> = {\n      'ArrowLeft': 'A',\n      'ArrowRight': 'D',\n      'ArrowUp': 'W',\n      'ArrowDown': 'S',\n    };\n\n    const newBindings: KeyBindings = {};\n    for (const [key, binding] of Object.entries(bindings)) {\n      const newKey = keyMap[key] || key;\n      newBindings[newKey] = binding;\n    }\n    bindings = newBindings;\n  }\n\n  // Apply action override\n  if (options.action) {\n    for (const key of Object.keys(bindings)) {\n      const binding = bindings[key];\n      if (typeof binding === 'object') {\n        bindings[key] = { ...binding, action: options.action };\n      }\n    }\n  }\n\n  // Apply key overrides\n  if (options.overrides) {\n    for (const [key, binding] of Object.entries(options.overrides)) {\n      if (binding !== undefined) {\n        bindings[key] = binding;\n      }\n    }\n  }\n\n  return {\n    type: 'per-key',\n    bindings\n  };\n}\n\n/**\n * Merge multiple profiles into one\n *\n * @param profileNames - Array of profile names to merge\n * @returns Merged bindings (only works with per-key profiles)\n *\n * @example\n * ```ts\n * const bindings = mergeProfiles(['shooter', 'twinStick']);\n * // Combines multiple per-key profiles\n * ```\n */\nexport function mergeProfiles(profileNames: string[]): KeyBindings {\n  const merged: KeyBindings = {};\n\n  for (const name of profileNames) {\n    const profile = getProfile(name);\n    if (profile && profile.config.type === 'per-key') {\n      Object.assign(merged, profile.config.bindings);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * List all available profiles\n *\n * @returns Array of profile names\n */\nexport function listProfiles(): string[] {\n  return [\n    ...Object.keys(BUILT_IN_PROFILES),\n    ...Array.from(customProfiles.keys())\n  ];\n}\n", "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini/core';\nimport { getProfile, applyProfileOptions, mergeProfiles as mergeProfileBindings, type ProfileOptions } from './InputProfiles.js';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport interface AggregatedBinding {\n  keyMap: Record<string, string>;\n  state: Record<string, any>;\n  mode: 'continuous' | 'oneshot';\n  targetId?: string;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n  private aggregatedBindings = new Map<string, AggregatedBinding>(); // NEW: Track aggregated state\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n    }\n  }\n\n  /**\n   * Bind multiple keys that aggregate into a single input state\n   * Perfect for platformers, twin-stick shooters, fighting games\n   *\n   * Key codes: Use standard DOM key names (ArrowLeft, ArrowRight, ArrowUp, ArrowDown, Space).\n   * Letter keys (A-Z) are automatically uppercased. Arrow keys and Space are automatically\n   * converted to Phaser's internal format (LEFT, RIGHT, UP, DOWN, SPACE).\n   *\n   * @example\n   * ```ts\n   * // Platformer controls - use ArrowLeft/ArrowRight/Space\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'ArrowLeft',\n   *   right: 'ArrowRight',\n   *   up: 'Space'\n   * });\n   * // Automatically tracks: { left: true/false, right: true/false, up: true/false }\n   *\n   * // Top-down movement - letter keys work as-is\n   * inputManager.bindKeysAggregated('move', {\n   *   left: 'A',\n   *   right: 'D',\n   *   up: 'W',\n   *   down: 'S'\n   * });\n   * ```\n   */\n  bindKeysAggregated(\n    action: string,\n    keyMap: Record<string, string>,\n    options?: {\n      initialState?: Record<string, any>;\n      mode?: 'continuous' | 'oneshot';\n      targetId?: string;\n    }\n  ): void {\n    // Build initial state (default to false for each field)\n    const state = options?.initialState ||\n      Object.fromEntries(\n        Object.keys(keyMap).map(field => [field, false])\n      );\n\n    this.aggregatedBindings.set(action, {\n      keyMap,\n      state,\n      mode: options?.mode || 'continuous',\n      targetId: options?.targetId\n    });\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n\n    // Handle aggregated bindings (multi-key state tracking)\n    for (const [action, binding] of this.aggregatedBindings.entries()) {\n      let stateChanged = false;\n\n      // Check each key in the map and update state\n      for (const [field, keyCode] of Object.entries(binding.keyMap)) {\n        // IMPORTANT: Convert user-friendly key names to Phaser's internal key codes\n        // Phaser uses uppercase constants (e.g., 'LEFT' not 'ArrowLeft')\n        // This mapping allows users to use standard DOM key names while Phaser expects its own format\n        // See: https://photonstorm.github.io/phaser3-docs/Phaser.Input.Keyboard.KeyCodes.html\n        let phaserKeyCode = keyCode;\n        const keyCodeMap: Record<string, string> = {\n          'ArrowLeft': 'LEFT',\n          'ArrowRight': 'RIGHT',\n          'ArrowUp': 'UP',\n          'ArrowDown': 'DOWN',\n          'Space': 'SPACE'\n        };\n\n        if (keyCodeMap[keyCode]) {\n          phaserKeyCode = keyCodeMap[keyCode];\n        }\n\n        const keyObj = this.scene.input.keyboard?.addKey(phaserKeyCode, false);\n        if (!keyObj) {\n          console.warn(`[InputManager] Failed to create key object for: ${keyCode} (mapped to ${phaserKeyCode})`);\n          continue;\n        }\n\n        const pressed = keyObj.isDown;\n\n        // Update state if changed\n        if (binding.state[field] !== pressed) {\n          binding.state[field] = pressed;\n          stateChanged = true;\n        }\n      }\n\n      // Submit aggregated state\n      if (binding.mode === 'continuous') {\n        // Submit every frame (spread to avoid mutation)\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      } else if (binding.mode === 'oneshot' && stateChanged) {\n        // Submit only when state changes\n        this.runtime.submitAction(\n          action,\n          { ...binding.state },\n          binding.targetId\n        );\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Use a pre-defined input profile\n   *\n   * @param profileName - Name of the profile ('platformer', 'topDown', 'shooter', etc.)\n   * @param options - Optional customization\n   *\n   * @example\n   * ```ts\n   * // Simple usage\n   * inputManager.useProfile('platformer');\n   *\n   * // With player 2 (uses WASD instead of arrows)\n   * inputManager.useProfile('platformer', { player: 2 });\n   *\n   * // With custom action name\n   * inputManager.useProfile('platformer', { action: 'move' });\n   *\n   * // With key overrides\n   * inputManager.useProfile('platformer', {\n   *   overrides: {\n   *     'Space': { action: 'jump', mode: 'oneshot' }\n   *   }\n   * });\n   * ```\n   */\n  useProfile(profileName: string, options?: ProfileOptions): void {\n    const profile = getProfile(profileName);\n\n    if (!profile) {\n      console.warn(`[InputManager] Profile \"${profileName}\" not found. Available profiles:`, [\n        'platformer', 'platformerWASD', 'topDown', 'topDownWASD', 'shooter', 'twinStick'\n      ]);\n      return;\n    }\n\n    const config = applyProfileOptions(profile, options);\n\n    if (config.type === 'aggregated') {\n      // Use aggregated binding for multi-key state tracking\n      this.bindKeysAggregated(config.action, config.keys, {\n        mode: config.mode\n      });\n    } else {\n      // Use per-key binding for separate actions\n      this.bindKeys(config.bindings);\n    }\n  }\n\n  /**\n   * Merge multiple profiles into one\n   *\n   * @param profileNames - Array of profile names\n   *\n   * @example\n   * ```ts\n   * // Combine platformer movement with shooter actions\n   * inputManager.mergeProfiles(['platformer', 'shooter']);\n   * ```\n   */\n  mergeProfiles(profileNames: string[]): void {\n    const merged = mergeProfileBindings(profileNames);\n    this.bindKeys(merged);\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n", "/**\n * PhysicsManager - Automates physics behavior based on inputs\n *\n * Eliminates manual physics loops by automatically reading inputs from state\n * and applying pre-defined or custom physics behaviors.\n *\n * @example\n * ```ts\n * // In scene.create()\n * this.physicsManager = this.adapter.createPhysicsManager({\n *   spriteManager: this.spriteManager,\n *   inputKey: 'inputs'\n * });\n *\n * this.physicsManager.addBehavior('platformer', {\n *   speed: 200,\n *   jumpPower: 350\n * });\n *\n * // In scene.update()\n * this.physicsManager.update();\n * ```\n */\n\nimport type { GameRuntime } from '@martini/core';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface PlatformerBehaviorConfig {\n  speed?: number;\n  jumpPower?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    jump?: string;\n  };\n}\n\nexport interface TopDownBehaviorConfig {\n  speed?: number;\n  keys?: {\n    left?: string;\n    right?: string;\n    up?: string;\n    down?: string;\n  };\n}\n\nexport interface CustomBehaviorConfig {\n  apply: (sprite: any, input: any, body: Phaser.Physics.Arcade.Body) => void;\n}\n\nexport type BehaviorConfig = PlatformerBehaviorConfig | TopDownBehaviorConfig | CustomBehaviorConfig;\n\nexport interface PhysicsManagerConfig {\n  /** SpriteManager to get sprites from */\n  spriteManager: SpriteManager;\n\n  /** Key in state to read inputs from (e.g., 'inputs') */\n  inputKey?: string;\n\n  /** Key prefix for sprite keys (defaults to 'player-') */\n  spriteKeyPrefix?: string;\n}\n\nexport class PhysicsManager {\n  private runtime: GameRuntime;\n  private spriteManager: SpriteManager;\n  private inputKey: string;\n  private spriteKeyPrefix: string;\n  private behaviorType: 'platformer' | 'topDown' | 'custom' | null = null;\n  private behaviorConfig: BehaviorConfig | null = null;\n\n  constructor(runtime: GameRuntime, config: PhysicsManagerConfig) {\n    this.runtime = runtime;\n    this.spriteManager = config.spriteManager;\n    this.inputKey = config.inputKey || 'inputs';\n    this.spriteKeyPrefix = config.spriteKeyPrefix || 'player-';\n  }\n\n  /**\n   * Add a physics behavior\n   *\n   * @param type - Behavior type ('platformer', 'topDown', 'custom')\n   * @param config - Behavior configuration\n   */\n  addBehavior(\n    type: 'platformer',\n    config?: PlatformerBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'topDown',\n    config?: TopDownBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'custom',\n    config: CustomBehaviorConfig\n  ): void;\n  addBehavior(\n    type: 'platformer' | 'topDown' | 'custom',\n    config?: BehaviorConfig\n  ): void {\n    this.behaviorType = type;\n    this.behaviorConfig = config || {};\n  }\n\n  /**\n   * Update physics for all sprites (call in scene.update())\n   * Only runs on host.\n   */\n  update(): void {\n    // Only host applies physics\n    const transport = this.runtime.getTransport();\n    if (!transport.isHost()) return;\n\n    const state = this.runtime.getState() as any;\n    const inputs = state[this.inputKey];\n    if (!inputs) return;\n\n    // Apply physics to each player based on their input\n    for (const [playerId, playerInput] of Object.entries(inputs)) {\n      const sprite = this.spriteManager.get(`${this.spriteKeyPrefix}${playerId}`);\n      if (!sprite || !sprite.body) continue;\n\n      const body = sprite.body as Phaser.Physics.Arcade.Body;\n\n      if (this.behaviorType === 'platformer') {\n        this.applyPlatformerBehavior(body, playerInput as any, this.behaviorConfig as PlatformerBehaviorConfig);\n      } else if (this.behaviorType === 'topDown') {\n        this.applyTopDownBehavior(body, playerInput as any, this.behaviorConfig as TopDownBehaviorConfig);\n      } else if (this.behaviorType === 'custom' && this.behaviorConfig) {\n        const customConfig = this.behaviorConfig as CustomBehaviorConfig;\n        customConfig.apply(sprite, playerInput, body);\n      }\n    }\n  }\n\n  private applyPlatformerBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: PlatformerBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const jumpPower = config.jumpPower || 350;\n    const keys = config.keys || { left: 'left', right: 'right', jump: 'up' };\n\n    // Horizontal movement\n    if (input[keys.left!]) {\n      body.setVelocityX(-speed);\n    } else if (input[keys.right!]) {\n      body.setVelocityX(speed);\n    } else {\n      body.setVelocityX(0);\n    }\n\n    // Jumping (only if on ground)\n    if (input[keys.jump!] && body.touching.down) {\n      body.setVelocityY(-jumpPower);\n    }\n  }\n\n  private applyTopDownBehavior(\n    body: Phaser.Physics.Arcade.Body,\n    input: any,\n    config: TopDownBehaviorConfig\n  ): void {\n    const speed = config.speed || 200;\n    const keys = config.keys || { left: 'left', right: 'right', up: 'up', down: 'down' };\n\n    let vx = 0;\n    let vy = 0;\n\n    if (input[keys.left!]) vx = -speed;\n    if (input[keys.right!]) vx = speed;\n    if (input[keys.up!]) vy = -speed;\n    if (input[keys.down!]) vy = speed;\n\n    body.setVelocity(vx, vy);\n  }\n}\n", "/**\n * CollisionManager - Declarative collision rule system\n *\n * Eliminates \"forgot to add collider for late-joining player\" bugs by:\n * - Declaring collision rules ONCE\n * - Auto-applying rules to all sprites (early and late-joining)\n * - Supporting sprites, SpriteManagers, and Phaser groups\n *\n * Usage:\n * ```ts\n * const collisionManager = adapter.createCollisionManager();\n *\n * // Register a ball sprite\n * collisionManager.registerSprite('ball', this.ball);\n *\n * // Declare collision rules ONCE\n * collisionManager.addCollision('ball', this.spriteManager);\n * // \u261D\uFE0F Automatically adds colliders for all current AND future paddles!\n *\n * // With custom handler\n * collisionManager.addCollision(this.bulletGroup, this.enemyGroup, {\n *   onCollide: (bullet, enemy) => {\n *     enemy.takeDamage(bullet.damage);\n *     bullet.destroy();\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { SpriteManager } from './SpriteManager.js';\n\nexport interface CollisionRule {\n  a: string | SpriteManager | any; // Phaser.Physics.Arcade.Group or sprite\n  b: string | SpriteManager | any;\n  handler?: (objA: any, objB: any) => void;\n}\n\nexport interface CollisionManagerConfig {\n  /**\n   * Optional: Global collision handler\n   * Called for all collisions if no specific handler provided\n   */\n  onCollide?: (obj1: any, obj2: any) => void;\n}\n\nexport class CollisionManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: CollisionManagerConfig;\n  private rules: CollisionRule[] = [];\n  private colliders: any[] = []; // Phaser.Physics.Arcade.Collider instances\n  private namedSprites: Map<string, any> = new Map(); // key -> sprite\n  private spriteToColliders: WeakMap<any, Set<any>> = new WeakMap(); // sprite -> Set of colliders\n\n  constructor(adapter: PhaserAdapter, scene: any, config?: CollisionManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config || {};\n  }\n\n  /**\n   * Register a sprite by name (for string-based collision rules)\n   *\n   * @example\n   * ```ts\n   * collisionManager.registerSprite('ball', this.ball);\n   * collisionManager.addCollision('ball', paddleManager);\n   * ```\n   */\n  registerSprite(key: string, sprite: any): void {\n    this.namedSprites.set(key, sprite);\n    this.reapplyRules();\n  }\n\n  /**\n   * Unregister a sprite by name\n   */\n  unregisterSprite(key: string): void {\n    const sprite = this.namedSprites.get(key);\n    if (sprite) {\n      this.removeCollidersForSprite(sprite);\n    }\n    this.namedSprites.delete(key);\n  }\n\n  /**\n   * Add collision between sprites/groups/managers\n   *\n   * Supports:\n   * - String keys (via registerSprite)\n   * - SpriteManager instances (auto-syncs with new sprites)\n   * - Phaser sprites or groups\n   */\n  addCollision(\n    a: string | SpriteManager | any,\n    b: string | SpriteManager | any,\n    options?: {\n      onCollide?: (obj1: any, obj2: any) => void;\n    }\n  ): void {\n    const rule: CollisionRule = {\n      a,\n      b,\n      handler: options?.onCollide\n    };\n\n    this.rules.push(rule);\n\n    // If either side is a SpriteManager, install onAdd hooks\n    if (this.isSpriteManager(a)) {\n      this.hookSpriteManager(a as SpriteManager);\n    }\n    if (this.isSpriteManager(b)) {\n      this.hookSpriteManager(b as SpriteManager);\n    }\n\n    // Apply rule immediately for existing sprites\n    this.applyRule(rule);\n  }\n\n  /**\n   * Remove collision rule\n   */\n  removeCollision(a: string | SpriteManager | any, b: string | SpriteManager | any): void {\n    const ruleIndex = this.rules.findIndex(r =>\n      (r.a === a && r.b === b) || (r.a === b && r.b === a)\n    );\n\n    if (ruleIndex !== -1) {\n      this.rules.splice(ruleIndex, 1);\n      // Note: We don't remove existing colliders, just stop creating new ones\n    }\n  }\n\n  /**\n   * Cleanup all colliders\n   */\n  destroy(): void {\n    for (const collider of this.colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n    }\n    this.colliders.length = 0;\n    this.rules.length = 0;\n    this.namedSprites.clear();\n  }\n\n  /**\n   * Install onAdd hook on a SpriteManager to re-apply rules when sprites are added\n   */\n  private hookSpriteManager(manager: SpriteManager): void {\n    // Check if already hooked\n    if ((manager as any)._collisionManagerHooked) {\n      return;\n    }\n    (manager as any)._collisionManagerHooked = true;\n\n    // Store original config\n    const originalConfig = (manager as any).config;\n    const originalOnAdd = originalConfig.onAdd;\n\n    // Wrap onAdd to re-apply collision rules\n    originalConfig.onAdd = (sprite: any, key: string, data: any, context: any) => {\n      // Call original onAdd if it exists\n      if (originalOnAdd) {\n        originalOnAdd(sprite, key, data, context);\n      }\n\n      // Re-apply all collision rules involving this manager\n      this.reapplyRules();\n    };\n  }\n\n  /**\n   * Apply a single collision rule (create colliders)\n   */\n  private applyRule(rule: CollisionRule): void {\n    const objectsA = this.resolveToObjects(rule.a);\n    const objectsB = this.resolveToObjects(rule.b);\n\n    if (objectsA.length === 0 || objectsB.length === 0) {\n      // One or both sides have no objects yet\n      return;\n    }\n\n    const handler = rule.handler || this.config.onCollide;\n\n    // Create colliders for each combination\n    for (const objA of objectsA) {\n      for (const objB of objectsB) {\n        // Skip if collider already exists\n        if (this.hasCollider(objA, objB)) {\n          continue;\n        }\n\n        // Create the collider\n        const collider = this.scene.physics.add.collider(objA, objB, handler);\n        this.colliders.push(collider);\n\n        // Track colliders per sprite\n        this.trackCollider(objA, collider);\n        this.trackCollider(objB, collider);\n      }\n    }\n  }\n\n  /**\n   * Re-apply all collision rules (called when sprites are added)\n   */\n  private reapplyRules(): void {\n    for (const rule of this.rules) {\n      this.applyRule(rule);\n    }\n  }\n\n  /**\n   * Resolve a rule target to an array of Phaser objects\n   */\n  private resolveToObjects(target: string | SpriteManager | any): any[] {\n    if (typeof target === 'string') {\n      // It's a named sprite\n      const sprite = this.namedSprites.get(target);\n      return sprite ? [sprite] : [];\n    }\n\n    if (this.isSpriteManager(target)) {\n      // It's a SpriteManager - get all sprites\n      const sprites = Array.from((target as SpriteManager).getAll().values());\n      return sprites;\n    }\n\n    // It's a raw Phaser object (sprite or group)\n    return [target];\n  }\n\n  /**\n   * Check if target is a SpriteManager\n   */\n  private isSpriteManager(target: any): boolean {\n    return target && typeof target === 'object' && 'getAll' in target && 'add' in target;\n  }\n\n  /**\n   * Check if a collider already exists between two objects\n   */\n  private hasCollider(objA: any, objB: any): boolean {\n    const collidersA = this.spriteToColliders.get(objA);\n    const collidersB = this.spriteToColliders.get(objB);\n\n    if (!collidersA || !collidersB) {\n      return false;\n    }\n\n    // Check if any collider is shared\n    for (const collider of collidersA) {\n      if (collidersB.has(collider)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Track that a collider belongs to a sprite\n   */\n  private trackCollider(sprite: any, collider: any): void {\n    let colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) {\n      colliders = new Set();\n      this.spriteToColliders.set(sprite, colliders);\n    }\n    colliders.add(collider);\n  }\n\n  /**\n   * Remove all colliders associated with a sprite\n   */\n  private removeCollidersForSprite(sprite: any): void {\n    const colliders = this.spriteToColliders.get(sprite);\n    if (!colliders) return;\n\n    for (const collider of colliders) {\n      if (collider && collider.destroy) {\n        collider.destroy();\n      }\n      const index = this.colliders.indexOf(collider);\n      if (index !== -1) {\n        this.colliders.splice(index, 1);\n      }\n    }\n\n    this.spriteToColliders.delete(sprite);\n  }\n}\n", "/**\n * PlayerUIManager - Automatic UI synchronization for players\n *\n * Eliminates bugs caused by:\n * - Creating UI before player metadata (side, team, etc.) is synced\n * - Forgetting to update UI when player data changes\n * - Manual loops to create/update/destroy UI elements\n *\n * Features:\n * - Waits for staticProperties before creating UI (no race conditions!)\n * - Auto-repositions UI when metadata changes\n * - Auto-creates UI for late-joining players\n * - Auto-destroys UI when players leave\n *\n * Usage:\n * ```ts\n * const playerUI = adapter.createPlayerUIManager({\n *   score: {\n *     position: (player) => ({\n *       x: player.side === 'left' ? 200 : 600,\n *       y: 80\n *     }),\n *     getText: (player) => String(player.score || 0),\n *     style: { fontSize: '48px', color: '#fff' }\n *   },\n *\n *   health: {\n *     position: (player) => ({ x: player.x, y: player.y - 30 }),\n *     width: 50,\n *     height: 5,\n *     getValue: (player) => player.health / player.maxHealth,\n *     backgroundColor: 0x333333,\n *     foregroundColor: 0x00ff00\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface TextUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   * Called when UI is created AND when metadata changes\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Text content function\n   */\n  getText: (player: any, playerId: string) => string;\n\n  /**\n   * Phaser text style\n   */\n  style?: Phaser.Types.GameObjects.Text.TextStyle;\n\n  /**\n   * Text origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   * Example: ['side', 'team'] - waits until these are synced\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface BarUIConfig {\n  /**\n   * Position function - receives FULL player data (including staticProperties!)\n   */\n  position: (player: any, playerId: string) => { x: number; y: number };\n\n  /**\n   * Value function (0-1 range)\n   */\n  getValue: (player: any, playerId: string) => number;\n\n  /**\n   * Bar dimensions\n   */\n  width: number;\n  height: number;\n\n  /**\n   * Colors\n   */\n  backgroundColor: number;\n  foregroundColor: number;\n\n  /**\n   * Bar origin (default: 0.5 for centered)\n   */\n  origin?: number | { x: number; y: number };\n\n  /**\n   * Z-depth for layering\n   */\n  depth?: number;\n\n  /**\n   * Required static properties that must exist before creating this UI\n   */\n  requiredMetadata?: string[];\n}\n\nexport interface PlayerUIManagerConfig {\n  /**\n   * UI elements keyed by name\n   * Each element can be text or bar type\n   */\n  [elementName: string]: TextUIConfig | BarUIConfig;\n}\n\ntype UIElement = {\n  type: 'text' | 'bar';\n  config: TextUIConfig | BarUIConfig;\n  gameObject: any; // Phaser.GameObjects.Text | Container with rectangles\n};\n\nexport class PlayerUIManager {\n  private adapter: PhaserAdapter;\n  private scene: any; // Phaser.Scene\n  private config: PlayerUIManagerConfig;\n  private playerElements: Map<string, Map<string, UIElement>> = new Map(); // playerId -> elementName -> UIElement\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, scene: any, config: PlayerUIManagerConfig) {\n    this.adapter = adapter;\n    this.scene = scene;\n    this.config = config;\n\n    // Subscribe to state changes\n    this.unsubscribe = adapter.onChange((state: any) => {\n      this.syncFromState(state);\n    });\n  }\n\n  /**\n   * Get UI element for a specific player\n   */\n  get(playerId: string, elementName: string): any {\n    return this.playerElements.get(playerId)?.get(elementName)?.gameObject;\n  }\n\n  /**\n   * Manually update all UI (also called automatically on state changes)\n   */\n  update(): void {\n    const state = this.adapter.getRuntime().getState();\n    this.syncFromState(state);\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Destroy all UI elements\n    for (const [playerId, elements] of this.playerElements.entries()) {\n      for (const [elementName, element] of elements.entries()) {\n        this.destroyElement(element);\n      }\n    }\n    this.playerElements.clear();\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * Sync UI from state\n   */\n  private syncFromState(state: any): void {\n    if (!state.players) return;\n\n    const existingPlayers = new Set(this.playerElements.keys());\n\n    // Create/update UI for each player\n    for (const [playerId, playerData] of Object.entries(state.players) as [string, any][]) {\n      existingPlayers.delete(playerId);\n\n      // Get or create element map for this player\n      let elements = this.playerElements.get(playerId);\n      if (!elements) {\n        elements = new Map();\n        this.playerElements.set(playerId, elements);\n      }\n\n      // Create/update each UI element\n      for (const [elementName, elementConfig] of Object.entries(this.config)) {\n        const existing = elements.get(elementName);\n\n        // Check if required metadata exists\n        const requiredMetadata = (elementConfig as any).requiredMetadata || [];\n        const hasMetadata = requiredMetadata.every((key: string) => key in playerData);\n\n        if (!hasMetadata) {\n          // Metadata not ready yet - skip creation\n          continue;\n        }\n\n        if (!existing) {\n          // Create new UI element\n          const element = this.createElement(elementName, elementConfig, playerId, playerData);\n          if (element) {\n            elements.set(elementName, element);\n          }\n        } else {\n          // Update existing UI element\n          this.updateElement(existing, playerId, playerData);\n        }\n      }\n    }\n\n    // Remove UI for players who left\n    for (const playerId of existingPlayers) {\n      const elements = this.playerElements.get(playerId);\n      if (elements) {\n        for (const element of elements.values()) {\n          this.destroyElement(element);\n        }\n      }\n      this.playerElements.delete(playerId);\n    }\n  }\n\n  /**\n   * Create a UI element\n   */\n  private createElement(\n    elementName: string,\n    config: TextUIConfig | BarUIConfig,\n    playerId: string,\n    playerData: any\n  ): UIElement | null {\n    const pos = config.position(playerData, playerId);\n\n    if (this.isTextConfig(config)) {\n      // Create text element\n      const text = this.scene.add.text(\n        pos.x,\n        pos.y,\n        config.getText(playerData, playerId),\n        config.style || {}\n      );\n\n      if (config.origin !== undefined) {\n        if (typeof config.origin === 'number') {\n          text.setOrigin(config.origin);\n        } else {\n          text.setOrigin(config.origin.x, config.origin.y);\n        }\n      }\n\n      if (config.depth !== undefined) {\n        text.setDepth(config.depth);\n      }\n\n      return {\n        type: 'text',\n        config,\n        gameObject: text\n      };\n    } else {\n      // Create bar element (container with two rectangles)\n      const container = this.scene.add.container(pos.x, pos.y);\n\n      const bg = this.scene.add.rectangle(0, 0, config.width, config.height, config.backgroundColor);\n      const fg = this.scene.add.rectangle(\n        0,\n        0,\n        config.width * config.getValue(playerData, playerId),\n        config.height,\n        config.foregroundColor\n      );\n\n      if (config.origin !== undefined) {\n        const originX = typeof config.origin === 'number' ? config.origin : config.origin.x;\n        const originY = typeof config.origin === 'number' ? config.origin : config.origin.y;\n        bg.setOrigin(originX, originY);\n        fg.setOrigin(originX, originY);\n      }\n\n      container.add([bg, fg]);\n\n      if (config.depth !== undefined) {\n        container.setDepth(config.depth);\n      }\n\n      // Store references for updates\n      (container as any)._bg = bg;\n      (container as any)._fg = fg;\n\n      return {\n        type: 'bar',\n        config,\n        gameObject: container\n      };\n    }\n  }\n\n  /**\n   * Update a UI element\n   */\n  private updateElement(element: UIElement, playerId: string, playerData: any): void {\n    const pos = element.config.position(playerData, playerId);\n\n    if (element.type === 'text') {\n      const config = element.config as TextUIConfig;\n      const text = element.gameObject;\n\n      text.setPosition(pos.x, pos.y);\n      text.setText(config.getText(playerData, playerId));\n    } else {\n      const config = element.config as BarUIConfig;\n      const container = element.gameObject;\n      const fg = (container as any)._fg;\n\n      container.setPosition(pos.x, pos.y);\n\n      // Update bar width based on value\n      const value = Math.max(0, Math.min(1, config.getValue(playerData, playerId)));\n      fg.width = config.width * value;\n    }\n  }\n\n  /**\n   * Destroy a UI element\n   */\n  private destroyElement(element: UIElement): void {\n    if (element.gameObject && element.gameObject.destroy) {\n      element.gameObject.destroy();\n    }\n  }\n\n  /**\n   * Type guard for TextUIConfig\n   */\n  private isTextConfig(config: TextUIConfig | BarUIConfig): config is TextUIConfig {\n    return 'getText' in config;\n  }\n}\n", "/**\n * PhaserAdapter - Bridge between Phaser and @martini/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\nimport { PhysicsManager, type PhysicsManagerConfig } from './helpers/PhysicsManager.js';\nimport { CollisionManager, type CollisionManagerConfig } from './helpers/CollisionManager.js';\nimport { PlayerUIManager, type PlayerUIManagerConfig } from './helpers/PlayerUIManager.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 50ms / 20 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Interpolate movement on clients for smoothness */\n  interpolate?: boolean;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Enable automatic interpolation for remote sprites (default: true)\n   * When enabled, remote sprites smoothly lerp to target positions\n   */\n  autoInterpolate?: boolean;\n\n  /**\n   * Interpolation lerp factor (default: 0.3)\n   * Lower = smoother but laggier, Higher = snappier but jerkier\n   * Range: 0.1 (very smooth) to 0.5 (very snappy)\n   */\n  lerpFactor?: number;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   autoInterpolate: true,           // optional, defaults to true\n *   lerpFactor: 0.3                  // optional, defaults to 0.3\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<string, { sprite: any; options: SpriteTrackingOptions }> = new Map();\n  private remoteSprites: Map<string, any> = new Map(); // Sprites created for remote players\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly autoInterpolate: boolean;\n  private readonly lerpFactor: number;\n\n  // My Player tracking\n  private myPlayerCache: any = undefined;\n  private myPlayerCallbacks = new Set<(player: any) => void>();\n  private myPlayerUnsubscribe?: () => void;\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.autoInterpolate = config.autoInterpolate !== false; // default true\n    this.lerpFactor = config.lerpFactor ?? 0.3;\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Subscribe to state changes to detect player updates\n    this.myPlayerUnsubscribe = this.runtime.onChange(() => {\n      // Only check if we have active subscribers\n      if (this.myPlayerCallbacks.size > 0) {\n        this.checkMyPlayerChanges();\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get the current player's ID\n   *\n   * @returns The unique player ID for this client\n   *\n   * @example\n   * ```ts\n   * const myId = adapter.getMyPlayerId();\n   * adapter.trackSprite(playerSprite, `player-${myId}`);\n   * ```\n   */\n  getMyPlayerId(): string {\n    return this.runtime.getMyPlayerId();\n  }\n\n  /**\n   * Get my player ID\n   * @deprecated Use getMyPlayerId() instead for consistency with other getter methods\n   */\n  get myId(): string {\n    return this.runtime.getMyPlayerId();\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, { sprite, options });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 50;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // Note: We do NOT immediately sync here to avoid infinite loops\n    // when trackSprite is called inside onChange callbacks.\n    // The interval-based sync will handle the first sync.\n  }\n\n  /**\n   * Stop tracking a sprite\n   */\n  untrackSprite(key: string): void {\n    this.trackedSprites.delete(key);\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[this.spriteNamespace];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, { sprite, options }] of this.trackedSprites.entries()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n      const sprites = state[this.spriteNamespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   */\n  private updateSpritesFromState(state: any): void {\n    const sprites = state[this.spriteNamespace];\n    if (this.isHost() || !sprites) return;\n\n    // Update tracked sprites (sprites that exist on this client)\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const spriteData = sprites[key];\n      if (spriteData) {\n        this.applySpriteData(tracked.sprite, spriteData);\n      }\n    }\n\n    // Update remote sprites (sprites from other players)\n    // Store target positions for interpolation\n    for (const [key, spriteData] of Object.entries(sprites)) {\n      // Skip if this is our own sprite\n      if (this.trackedSprites.has(key)) continue;\n\n      // If we have a remote sprite for this key, store target position\n      const remoteSprite = this.remoteSprites.get(key);\n      if (remoteSprite) {\n        // Store target position for smooth interpolation\n        remoteSprite._targetX = (spriteData as any).x;\n        remoteSprite._targetY = (spriteData as any).y;\n        remoteSprite._targetRotation = (spriteData as any).rotation;\n\n        // First update - snap to position immediately\n        if (remoteSprite._targetX !== undefined && remoteSprite.x === undefined) {\n          remoteSprite.x = remoteSprite._targetX;\n          remoteSprite.y = remoteSprite._targetY;\n          remoteSprite.rotation = remoteSprite._targetRotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any): void {\n    this.remoteSprites.set(key, sprite);\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Note: If autoInterpolate is enabled in config, you don't need to call this manually.\n   */\n  updateInterpolation(): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    for (const [key, sprite] of this.remoteSprites.entries()) {\n      // Skip null sprites (can happen if onCreate returns null)\n      if (!sprite) continue;\n\n      if (sprite._targetX !== undefined) {\n        // Lerp towards target position\n        sprite.x += (sprite._targetX - sprite.x) * this.lerpFactor;\n        sprite.y += (sprite._targetY - sprite.y) * this.lerpFactor;\n\n        if (sprite._targetRotation !== undefined) {\n          sprite.rotation += (sprite._targetRotation - sprite.rotation) * this.lerpFactor;\n        }\n      }\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const sprite = this.remoteSprites.get(key);\n    if (sprite && sprite.destroy) {\n      sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    return new SpriteManager(this, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n\n  /**\n   * Create a PhysicsManager for automatic physics behavior\n   *\n   * @example\n   * ```ts\n   * const physicsManager = adapter.createPhysicsManager({\n   *   spriteManager: this.spriteManager,\n   *   inputKey: 'inputs'\n   * });\n   *\n   * physicsManager.addBehavior('platformer', {\n   *   speed: 200,\n   *   jumpPower: 350\n   * });\n   *\n   * // In update loop (host only)\n   * physicsManager.update();\n   * ```\n   */\n  createPhysicsManager(config: PhysicsManagerConfig): PhysicsManager {\n    return new PhysicsManager(this.runtime, config);\n  }\n\n  /**\n   * Create a CollisionManager for declarative collision rules\n   *\n   * @example\n   * ```ts\n   * const collisionManager = adapter.createCollisionManager();\n   *\n   * // Declare collision rules ONCE - they auto-apply to late-joining players!\n   * collisionManager.addCollision('ball', 'paddles');\n   *\n   * // With custom handler\n   * collisionManager.addCollision('bullets', 'enemies', {\n   *   onCollide: (bullet, enemy) => {\n   *     enemy.takeDamage(bullet.damage);\n   *     bullet.destroy();\n   *   }\n   * });\n   * ```\n   */\n  createCollisionManager(config?: CollisionManagerConfig): CollisionManager {\n    return new CollisionManager(this, this.scene, config);\n  }\n\n  /**\n   * Create a PlayerUIManager for automatic player UI synchronization\n   *\n   * @example\n   * ```ts\n   * const playerUI = adapter.createPlayerUIManager({\n   *   score: {\n   *     position: (player) => ({\n   *       x: player.side === 'left' ? 200 : 600,\n   *       y: 80\n   *     }),\n   *     getText: (player) => String(player.score || 0),\n   *     style: { fontSize: '48px', color: '#fff' },\n   *     requiredMetadata: ['side'] // Wait for 'side' before creating\n   *   },\n   *\n   *   health: {\n   *     position: (player) => ({ x: player.x, y: player.y - 30 }),\n   *     width: 50,\n   *     height: 5,\n   *     getValue: (player) => player.health / player.maxHealth,\n   *     backgroundColor: 0x333333,\n   *     foregroundColor: 0x00ff00\n   *   }\n   * });\n   * ```\n   */\n  createPlayerUIManager(config: PlayerUIManagerConfig): PlayerUIManager {\n    return new PlayerUIManager(this, this.scene, config);\n  }\n\n  /**\n   * Get current player data (cached, updates automatically)\n   *\n   * Returns the player object for the current client from state.\n   * The result is cached and only updated when the player data actually changes,\n   * making it safe to call in update() loops without performance concerns.\n   *\n   * @param playersKey - Key in state where players are stored (default: 'players')\n   * @returns Current player data or undefined if not found\n   *\n   * @example\n   * ```ts\n   * // In scene.update()\n   * const myPlayer = this.adapter.getMyPlayer();\n   * if (myPlayer) {\n   *   // Use player data (role, name, stats, etc.)\n   *   const role = myPlayer.role;\n   * }\n   * ```\n   */\n  getMyPlayer<TPlayer = any>(playersKey: string = 'players'): TPlayer | undefined {\n    const myId = this.runtime.getTransport().getPlayerId();\n    const state = this.runtime.getState() as any;\n    return state[playersKey]?.[myId];\n  }\n\n  /**\n   * Internal: Check if player data changed and notify callbacks\n   */\n  private checkMyPlayerChanges(playersKey: string = 'players'): void {\n    const myId = this.runtime.getTransport().getPlayerId();\n    const state = this.runtime.getState() as any;\n    const myPlayer = state[playersKey]?.[myId];\n\n    // Check if player data changed (reference comparison)\n    if (myPlayer !== this.myPlayerCache) {\n      this.myPlayerCache = myPlayer;\n\n      // Notify all subscribers\n      for (const callback of this.myPlayerCallbacks) {\n        callback(myPlayer);\n      }\n    }\n  }\n\n  /**\n   * Subscribe to current player changes (reactive pattern)\n   *\n   * The callback is called immediately with the current player state,\n   * then called again whenever the player data changes.\n   *\n   * @param callback - Called when player data changes\n   * @param playersKey - Key in state where players are stored (default: 'players')\n   * @returns Unsubscribe function\n   *\n   * @example\n   * ```ts\n   * // In scene.create()\n   * this.adapter.onMyPlayerChange((myPlayer) => {\n   *   if (myPlayer && this.roleText) {\n   *     const role = myPlayer.role === 'fire' ? 'Fire Player' : 'Ice Player';\n   *     this.roleText.setText(`You are: ${role}`);\n   *   }\n   * });\n   * ```\n   */\n  onMyPlayerChange<TPlayer = any>(\n    callback: (player: TPlayer | undefined) => void,\n    playersKey: string = 'players'\n  ): () => void {\n    this.myPlayerCallbacks.add(callback);\n\n    // Initial call with current player state\n    const myPlayer = this.getMyPlayer<TPlayer>(playersKey);\n    callback(myPlayer);\n\n    // Return unsubscribe function\n    return () => {\n      this.myPlayerCallbacks.delete(callback);\n    };\n  }\n}\n", "/**\n * HUD Helper - Unified player HUD/UI for multiplayer games\n *\n * Eliminates the manual HUD boilerplate by automatically creating and managing\n * title, role, and control hint text based on the current player state.\n *\n * @example\n * ```ts\n * import { createPlayerHUD } from '@martini/phaser';\n *\n * // In scene.create()\n * this.hud = createPlayerHUD(this.adapter, this, {\n *   title: 'Fire & Ice - Cooperative Platformer',\n *\n *   roleText: (myPlayer) => {\n *     if (!myPlayer) return 'Spectator';\n *     return myPlayer.role === 'fire' ? 'Fire Player' : 'Ice Player';\n *   },\n *\n *   controlHints: (myPlayer) => {\n *     if (!myPlayer) return '';\n *     return 'Arrow Keys + SPACE to Jump';\n *   }\n * });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface HUDLayout {\n  /** Position for title text */\n  title?: { x: number; y: number };\n\n  /** Position for role text */\n  role?: { x: number; y: number };\n\n  /** Position for controls text */\n  controls?: { x: number; y: number };\n}\n\nexport interface HUDTextStyle {\n  fontSize?: string;\n  color?: string;\n  fontStyle?: string;\n  backgroundColor?: string;\n  padding?: { x: number; y: number };\n}\n\nexport interface PlayerHUDConfig<TPlayer = any> {\n  /** Title text (static) */\n  title?: string;\n\n  /** Title text style */\n  titleStyle?: HUDTextStyle;\n\n  /**\n   * Generate role text from player data\n   * @param myPlayer - Current player data or undefined if spectator\n   * @returns Text to display\n   */\n  roleText?: (myPlayer: TPlayer | undefined) => string;\n\n  /** Role text style */\n  roleStyle?: HUDTextStyle;\n\n  /**\n   * Generate control hints from player data\n   * @param myPlayer - Current player data or undefined if spectator\n   * @returns Text to display\n   */\n  controlHints?: (myPlayer: TPlayer | undefined) => string;\n\n  /** Control hints text style */\n  controlsStyle?: HUDTextStyle;\n\n  /** Custom layout positions */\n  layout?: HUDLayout;\n\n  /** Key in state where players are stored (default: 'players') */\n  playersKey?: string;\n}\n\nexport interface PlayerHUD {\n  /** Update HUD (automatically called when player changes) */\n  update: () => void;\n\n  /** Destroy HUD elements */\n  destroy: () => void;\n\n  /** Get title text object */\n  getTitleText: () => Phaser.GameObjects.Text | null;\n\n  /** Get role text object */\n  getRoleText: () => Phaser.GameObjects.Text | null;\n\n  /** Get controls text object */\n  getControlsText: () => Phaser.GameObjects.Text | null;\n}\n\n/**\n * Create a player HUD with automatic role/control updates\n *\n * @param adapter - PhaserAdapter instance\n * @param scene - Phaser scene\n * @param config - HUD configuration\n * @returns PlayerHUD instance\n */\nexport function createPlayerHUD<TPlayer = any>(\n  adapter: PhaserAdapter,\n  scene: Phaser.Scene,\n  config: PlayerHUDConfig<TPlayer>\n): PlayerHUD {\n  const playersKey = config.playersKey || 'players';\n\n  // Default layout\n  const layout: Required<HUDLayout> = {\n    title: config.layout?.title || { x: 400, y: 20 },\n    role: config.layout?.role || { x: 400, y: 50 },\n    controls: config.layout?.controls || { x: 400, y: 75 }\n  };\n\n  // Default styles\n  const titleStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n    fontSize: config.titleStyle?.fontSize || '24px',\n    color: config.titleStyle?.color || '#000',\n    fontStyle: config.titleStyle?.fontStyle || 'bold',\n    backgroundColor: config.titleStyle?.backgroundColor,\n    padding: config.titleStyle?.padding\n  };\n\n  const roleStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n    fontSize: config.roleStyle?.fontSize || '16px',\n    color: config.roleStyle?.color || '#000',\n    fontStyle: config.roleStyle?.fontStyle,\n    backgroundColor: config.roleStyle?.backgroundColor,\n    padding: config.roleStyle?.padding\n  };\n\n  const controlsStyle: Phaser.Types.GameObjects.Text.TextStyle = {\n    fontSize: config.controlsStyle?.fontSize || '14px',\n    color: config.controlsStyle?.color || '#333',\n    fontStyle: config.controlsStyle?.fontStyle,\n    backgroundColor: config.controlsStyle?.backgroundColor,\n    padding: config.controlsStyle?.padding\n  };\n\n  // Create text objects\n  let titleText: Phaser.GameObjects.Text | null = null;\n  let roleText: Phaser.GameObjects.Text | null = null;\n  let controlsText: Phaser.GameObjects.Text | null = null;\n\n  // Create title (static)\n  if (config.title) {\n    titleText = scene.add.text(layout.title.x, layout.title.y, config.title, titleStyle);\n    titleText.setOrigin(0.5);\n  }\n\n  // Create role text (dynamic)\n  if (config.roleText) {\n    roleText = scene.add.text(layout.role.x, layout.role.y, 'Loading...', roleStyle);\n    roleText.setOrigin(0.5);\n  }\n\n  // Create controls text (dynamic)\n  if (config.controlHints) {\n    controlsText = scene.add.text(layout.controls.x, layout.controls.y, '', controlsStyle);\n    controlsText.setOrigin(0.5);\n  }\n\n  // Update function\n  const update = () => {\n    const myPlayer = adapter.getMyPlayer<TPlayer>(playersKey);\n\n    if (roleText && config.roleText) {\n      roleText.setText(config.roleText(myPlayer));\n    }\n\n    if (controlsText && config.controlHints) {\n      controlsText.setText(config.controlHints(myPlayer));\n    }\n  };\n\n  // Subscribe to player changes\n  const unsubscribe = adapter.onMyPlayerChange<TPlayer>((myPlayer) => {\n    if (roleText && config.roleText) {\n      roleText.setText(config.roleText(myPlayer));\n    }\n\n    if (controlsText && config.controlHints) {\n      controlsText.setText(config.controlHints(myPlayer));\n    }\n  }, playersKey);\n\n  // Return HUD interface\n  return {\n    update,\n    destroy: () => {\n      unsubscribe();\n      titleText?.destroy();\n      roleText?.destroy();\n      controlsText?.destroy();\n    },\n    getTitleText: () => titleText,\n    getRoleText: () => roleText,\n    getControlsText: () => controlsText\n  };\n}\n", "/**\n * @martini/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini/core';\nimport { LocalTransport } from '@martini/transport-local';\n// import { TrysteroTransport } from '@martini/transport-trystero'; // Disabled for IDE\nimport { IframeBridgeTransport } from '@martini/transport-iframe-bridge';\nimport type { Transport } from '@martini/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n  };\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): { runtime: GameRuntime<TState>; phaser: Phaser.Game } {\n  // Read platform-injected config\n  const platformConfig = (window as any).__MARTINI_CONFIG__ as MartiniConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __MARTINI_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: [transport.getPlayerId()]\n    }\n  );\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  const phaserGame = new Phaser.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any).__MARTINI_IDE__) {\n    (window as any).__MARTINI_IDE__.registerRuntime(runtime);\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    // case 'trystero':\n    //   return new TrysteroTransport({\n    //     appId: config.appId || 'martini',\n    //     roomId: config.roomId,\n    //     isHost: config.isHost\n    //   });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local' and 'iframe-bridge' are supported in IDE mode.`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
