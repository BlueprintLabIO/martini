{
  "version": 3,
  "sources": ["../src/helpers/SpriteManager.ts", "../src/helpers/InputManager.ts", "../src/PhaserAdapter.ts", "../src/runtime.ts"],
  "sourcesContent": ["/**\n * SpriteManager - Automatic sprite synchronization helper\n *\n * Handles all the complexity of host/client sprite management:\n * - Host: Creates sprites, enables physics, tracks for sync\n * - Client: Creates visual sprites, registers for interpolation\n * - Automatic cleanup when sprites are removed\n *\n * Usage:\n * ```ts\n * const spriteManager = adapter.createSpriteManager({\n *   onCreate: (key, data) => {\n *     const sprite = this.add.sprite(data.x, data.y, 'player');\n *     if (this.adapter.isHost()) {\n *       this.physics.add.existing(sprite);\n *     }\n *     return sprite;\n *   }\n * });\n *\n * // Add sprites (works on both host and client)\n * spriteManager.add('player-1', { x: 100, y: 100 });\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\n\nexport interface SpriteData {\n  x: number;\n  y: number;\n  [key: string]: any; // Allow custom properties\n}\n\nexport interface SpriteManagerConfig<TData extends SpriteData = SpriteData> {\n  /**\n   * Factory function to create a sprite\n   * Called on both host and client\n   *\n   * @example\n   * ```ts\n   * onCreate: (key, data) => {\n   *   return this.add.sprite(data.x, data.y, 'player');\n   * }\n   * ```\n   */\n  onCreate: (key: string, data: TData) => any;\n\n  /**\n   * Optional: Setup physics (HOST ONLY - automatic)\n   * Use this to add physics, colliders, and other host-authoritative logic\n   * Framework automatically ensures this ONLY runs on host\n   *\n   * @example\n   * ```ts\n   * onCreatePhysics: (sprite, key, data) => {\n   *   this.physics.add.existing(sprite);\n   *   sprite.body.setCollideWorldBounds(true);\n   *   sprite.body.setBounce(0.2);\n   *   this.physics.add.collider(sprite, this.platforms);\n   * }\n   * ```\n   */\n  onCreatePhysics?: (sprite: any, key: string, data: TData) => void;\n\n  /**\n   * Optional: Update sprite properties when data changes (client only)\n   * Useful for syncing non-position properties like color, scale, etc.\n   */\n  onUpdate?: (sprite: any, data: TData) => void;\n\n  /**\n   * Optional: Cleanup when sprite is removed\n   */\n  onDestroy?: (sprite: any, key: string) => void;\n\n  /**\n   * Properties to sync (default: x, y, rotation, alpha)\n   */\n  syncProperties?: string[];\n\n  /**\n   * Sync interval in ms (default: 50ms / 20 FPS)\n   */\n  syncInterval?: number;\n}\n\nexport class SpriteManager<TData extends SpriteData = SpriteData> {\n  private sprites = new Map<string, any>();\n  private config: SpriteManagerConfig<TData>;\n  private adapter: PhaserAdapter;\n  private unsubscribe?: () => void;\n\n  constructor(adapter: PhaserAdapter, config: SpriteManagerConfig<TData>) {\n    this.adapter = adapter;\n    this.config = config;\n\n    // If client, listen for sprite data from state\n    if (!adapter.isHost()) {\n      this.unsubscribe = adapter.onChange((state: any) => {\n        this.syncFromState(state);\n      });\n    }\n  }\n\n  /**\n   * Add a sprite (call this on HOST only)\n   * The sprite will automatically sync to clients\n   */\n  add(key: string, data: TData): any {\n    if (!this.adapter.isHost()) {\n      console.warn('[SpriteManager] add() should only be called on host. Use state sync on clients.');\n      return null;\n    }\n\n    // Don't recreate if already exists\n    if (this.sprites.has(key)) {\n      return this.sprites.get(key);\n    }\n\n    // Create sprite\n    const sprite = this.config.onCreate(key, data);\n    this.sprites.set(key, sprite);\n\n    // Setup physics (HOST ONLY - automatic)\n    if (this.config.onCreatePhysics) {\n      this.config.onCreatePhysics(sprite, key, data);\n    }\n\n    // Track for automatic sync (host only)\n    this.adapter.trackSprite(sprite, key, {\n      properties: this.config.syncProperties || ['x', 'y', 'rotation', 'alpha'],\n      syncInterval: this.config.syncInterval\n    });\n\n    return sprite;\n  }\n\n  /**\n   * Remove a sprite\n   */\n  remove(key: string): void {\n    const sprite = this.sprites.get(key);\n    if (!sprite) return;\n\n    // Cleanup callback\n    this.config.onDestroy?.(sprite, key);\n\n    // Destroy sprite\n    if (sprite.destroy) {\n      sprite.destroy();\n    }\n\n    // Stop tracking\n    if (this.adapter.isHost()) {\n      this.adapter.untrackSprite(key);\n    } else {\n      this.adapter.unregisterRemoteSprite(key);\n    }\n\n    this.sprites.delete(key);\n  }\n\n  /**\n   * Get a sprite by key\n   */\n  get(key: string): any {\n    return this.sprites.get(key);\n  }\n\n  /**\n   * Get all sprites\n   */\n  getAll(): Map<string, any> {\n    return this.sprites;\n  }\n\n  /**\n   * Update loop (call this in scene.update() for smooth interpolation on clients)\n   */\n  update(): void {\n    if (!this.adapter.isHost()) {\n      this.adapter.updateInterpolation();\n    }\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    // Remove all sprites\n    for (const key of this.sprites.keys()) {\n      this.remove(key);\n    }\n\n    // Unsubscribe from state changes\n    this.unsubscribe?.();\n  }\n\n  /**\n   * CLIENT ONLY: Sync sprites from state\n   */\n  private syncFromState(state: any): void {\n    const spriteNamespace = (this.adapter as any).spriteNamespace || '_sprites';\n    const spriteData = state[spriteNamespace];\n\n    if (!spriteData) return;\n\n    // Create/update sprites based on state\n    for (const [key, data] of Object.entries(spriteData) as [string, any][]) {\n      if (!this.sprites.has(key)) {\n        // Create new sprite\n        const sprite = this.config.onCreate(key, data);\n        this.sprites.set(key, sprite);\n        this.adapter.registerRemoteSprite(key, sprite);\n      } else {\n        // Update existing sprite (optional)\n        if (this.config.onUpdate) {\n          const sprite = this.sprites.get(key);\n          this.config.onUpdate(sprite, data);\n        }\n      }\n    }\n\n    // Remove sprites that no longer exist in state\n    for (const key of this.sprites.keys()) {\n      if (!(key in spriteData)) {\n        this.remove(key);\n      }\n    }\n  }\n}\n", "/**\n * InputManager - Simplified input handling for multiplayer games\n *\n * Automatically maps keyboard/pointer input to game actions.\n * Handles debouncing, continuous vs one-shot inputs, and more.\n *\n * Usage:\n * ```ts\n * const input = adapter.createInputManager();\n *\n * // Map keys to actions\n * input.bindKeys({\n *   'ArrowLeft': { action: 'move', input: { x: -1 } },\n *   'ArrowRight': { action: 'move', input: { x: 1 } },\n *   'Space': 'jump' // Shorthand for action with no input\n * });\n *\n * // Or use Phaser cursor keys\n * input.bindCursors(this.input.keyboard.createCursorKeys(), {\n *   left: { action: 'move', input: { x: -1 } },\n *   right: { action: 'move', input: { x: 1 } },\n *   up: 'jump'\n * });\n *\n * // Call in update loop\n * input.update();\n * ```\n */\n\nimport type { PhaserAdapter } from '../PhaserAdapter.js';\nimport type { GameRuntime } from '@martini/core';\n\nexport interface ActionBinding {\n  /** Action name to submit */\n  action: string;\n\n  /** Input data to send with action */\n  input?: any;\n\n  /** Continuous (fires every frame while held) or one-shot (fires once on press) */\n  mode?: 'continuous' | 'oneshot';\n\n  /** Target player ID (defaults to self) */\n  targetId?: string;\n}\n\nexport type KeyBinding = ActionBinding | string; // string is shorthand for { action: string }\n\nexport interface KeyBindings {\n  [key: string]: KeyBinding;\n}\n\nexport interface CursorBindings {\n  left?: KeyBinding;\n  right?: KeyBinding;\n  up?: KeyBinding;\n  down?: KeyBinding;\n  space?: KeyBinding;\n  shift?: KeyBinding;\n}\n\nexport class InputManager {\n  private runtime: GameRuntime;\n  private scene: any; // Phaser.Scene\n  private keyBindings = new Map<string, ActionBinding>();\n  private cursorBindings?: CursorBindings;\n  private cursors?: any; // Phaser.Types.Input.Keyboard.CursorKeys\n  private pressedKeys = new Set<string>(); // Track one-shot keys\n\n  constructor(adapter: PhaserAdapter, scene: any) {\n    this.runtime = adapter.getRuntime();\n    this.scene = scene;\n  }\n\n  /**\n   * Bind keyboard keys to actions\n   *\n   * @example\n   * ```ts\n   * input.bindKeys({\n   *   'W': { action: 'move', input: { y: -1 }, mode: 'continuous' },\n   *   'S': { action: 'move', input: { y: 1 }, mode: 'continuous' },\n   *   'Space': { action: 'jump', mode: 'oneshot' },\n   *   'E': 'interact' // Shorthand\n   * });\n   * ```\n   */\n  bindKeys(bindings: KeyBindings): void {\n    console.log('[InputManager] bindKeys called with:', bindings);\n    for (const [key, binding] of Object.entries(bindings)) {\n      const normalized = this.normalizeBinding(binding);\n      this.keyBindings.set(key.toUpperCase(), normalized);\n      console.log(`[InputManager] Registered key: ${key.toUpperCase()}`, normalized);\n    }\n  }\n\n  /**\n   * Bind Phaser cursor keys to actions\n   *\n   * @example\n   * ```ts\n   * const cursors = this.input.keyboard.createCursorKeys();\n   * input.bindCursors(cursors, {\n   *   left: { action: 'move', input: { x: -1 } },\n   *   right: { action: 'move', input: { x: 1 } },\n   *   up: 'jump'\n   * });\n   * ```\n   */\n  bindCursors(cursors: any, bindings: CursorBindings): void {\n    this.cursors = cursors;\n    this.cursorBindings = bindings;\n  }\n\n  /**\n   * Update input (call this in scene.update())\n   */\n  update(): void {\n    // Debug: Check if keyboard is available\n    if (!this.scene.input?.keyboard) {\n      console.warn('[InputManager] No keyboard input available! Phaser keyboard may not be initialized.');\n      return;\n    }\n\n    // Handle regular key bindings\n    for (const [key, binding] of this.keyBindings.entries()) {\n      const keyObj = this.scene.input.keyboard?.addKey(key, false);\n      if (!keyObj) {\n        console.warn(`[InputManager] Failed to create key object for: ${key}`);\n        continue;\n      }\n\n      if (binding.mode === 'oneshot') {\n        // One-shot: fire once when pressed\n        if (keyObj.isDown && !this.pressedKeys.has(key)) {\n          console.log(`[InputManager] Key pressed (oneshot): ${key}`, binding);\n          this.submitBinding(binding);\n          this.pressedKeys.add(key);\n        } else if (keyObj.isUp) {\n          this.pressedKeys.delete(key);\n        }\n      } else {\n        // Continuous: fire every frame while held\n        if (keyObj.isDown) {\n          console.log(`[InputManager] Key held (continuous): ${key}`, binding);\n          this.submitBinding(binding);\n        }\n      }\n    }\n\n    // Handle cursor bindings\n    if (this.cursors && this.cursorBindings) {\n      const mappings: [any, KeyBinding | undefined][] = [\n        [this.cursors.left, this.cursorBindings.left],\n        [this.cursors.right, this.cursorBindings.right],\n        [this.cursors.up, this.cursorBindings.up],\n        [this.cursors.down, this.cursorBindings.down],\n        [this.cursors.space, this.cursorBindings.space],\n        [this.cursors.shift, this.cursorBindings.shift]\n      ];\n\n      for (const [keyObj, binding] of mappings) {\n        if (!keyObj || !binding) continue;\n\n        const normalized = this.normalizeBinding(binding);\n        const keyName = `cursor_${normalized.action}`;\n\n        if (normalized.mode === 'oneshot') {\n          if (keyObj.isDown && !this.pressedKeys.has(keyName)) {\n            console.log(`[InputManager] Cursor pressed (oneshot):`, normalized);\n            this.submitBinding(normalized);\n            this.pressedKeys.add(keyName);\n          } else if (keyObj.isUp) {\n            this.pressedKeys.delete(keyName);\n          }\n        } else {\n          if (keyObj.isDown) {\n            console.log(`[InputManager] Cursor held (continuous):`, normalized);\n            this.submitBinding(normalized);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Manually submit an action (useful for pointer/touch input)\n   */\n  submitAction(action: string, input?: any, targetId?: string): void {\n    this.runtime.submitAction(action, input, targetId);\n  }\n\n  /**\n   * Clear all bindings\n   */\n  clear(): void {\n    this.keyBindings.clear();\n    this.cursorBindings = undefined;\n    this.cursors = undefined;\n    this.pressedKeys.clear();\n  }\n\n  /**\n   * Get runtime for advanced usage\n   */\n  getRuntime(): GameRuntime {\n    return this.runtime;\n  }\n\n  // Private helpers\n\n  private normalizeBinding(binding: KeyBinding): ActionBinding {\n    if (typeof binding === 'string') {\n      return { action: binding, mode: 'oneshot' };\n    }\n    return {\n      ...binding,\n      mode: binding.mode || 'oneshot'\n    };\n  }\n\n  private submitBinding(binding: ActionBinding): void {\n    console.log(`[InputManager] submitAction('${binding.action}', ${JSON.stringify(binding.input)}, ${binding.targetId || 'self'})`);\n    this.runtime.submitAction(binding.action, binding.input, binding.targetId);\n  }\n}\n", "/**\n * PhaserAdapter - Bridge between Phaser and @martini/core\n *\n * v2: Fully automatic sprite syncing. Host runs physics, clients mirror.\n * User never has to think about networking - it just works.\n */\n\nimport type { GameRuntime } from '@martini/core';\nimport { SpriteManager, type SpriteManagerConfig } from './helpers/SpriteManager.js';\nimport { InputManager } from './helpers/InputManager.js';\n\nexport interface SpriteTrackingOptions {\n  /** Sync interval in ms (default: 50ms / 20 FPS) */\n  syncInterval?: number;\n\n  /** Properties to sync (default: x, y, rotation, alpha) */\n  properties?: string[];\n\n  /** Interpolate movement on clients for smoothness */\n  interpolate?: boolean;\n}\n\nexport interface PhaserAdapterConfig {\n  /**\n   * State namespace for sprite data (default: '_sprites')\n   * Allows using a custom property name instead of magic _sprites\n   */\n  spriteNamespace?: string;\n\n  /**\n   * Enable automatic interpolation for remote sprites (default: true)\n   * When enabled, remote sprites smoothly lerp to target positions\n   */\n  autoInterpolate?: boolean;\n\n  /**\n   * Interpolation lerp factor (default: 0.3)\n   * Lower = smoother but laggier, Higher = snappier but jerkier\n   * Range: 0.1 (very smooth) to 0.5 (very snappy)\n   */\n  lerpFactor?: number;\n}\n\n/**\n * Phaser Adapter - Auto-syncs sprites via GameRuntime\n *\n * Usage:\n * ```ts\n * const adapter = new PhaserAdapter(runtime, scene, {\n *   spriteNamespace: 'gameSprites', // optional, defaults to '_sprites'\n *   autoInterpolate: true,           // optional, defaults to true\n *   lerpFactor: 0.3                  // optional, defaults to 0.3\n * });\n * adapter.trackSprite(playerSprite, `player-${playerId}`);\n * // That's it! Sprite automatically syncs across network\n * ```\n */\nexport class PhaserAdapter<TState = any> {\n  private trackedSprites: Map<string, { sprite: any; options: SpriteTrackingOptions }> = new Map();\n  private remoteSprites: Map<string, any> = new Map(); // Sprites created for remote players\n  private syncIntervalId: any = null;\n  private readonly spriteNamespace: string;\n  private readonly autoInterpolate: boolean;\n  private readonly lerpFactor: number;\n\n  constructor(\n    private runtime: GameRuntime<TState>,\n    private scene: any, // Phaser.Scene\n    config: PhaserAdapterConfig = {}\n  ) {\n    this.spriteNamespace = config.spriteNamespace || '_sprites';\n    this.autoInterpolate = config.autoInterpolate !== false; // default true\n    this.lerpFactor = config.lerpFactor ?? 0.3;\n\n    // Ensure state has sprites object\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n    });\n\n    // Listen for state changes to update sprites (clients only)\n    this.runtime.onChange((state: TState) => {\n      if (!this.isHost()) {\n        this.updateSpritesFromState(state);\n      }\n    });\n  }\n\n  /**\n   * Get my player ID\n   */\n  get myId(): string {\n    return this.runtime.getTransport().getPlayerId();\n  }\n\n  /**\n   * Check if this peer is the host\n   */\n  isHost(): boolean {\n    return this.runtime.getTransport().isHost();\n  }\n\n  /**\n   * Track a sprite - automatically syncs position/rotation/etc\n   *\n   * @param sprite Phaser sprite to track\n   * @param key Unique key for this sprite (e.g., `player-${playerId}`)\n   * @param options Tracking options\n   *\n   * @example\n   * ```ts\n   * const player = this.physics.add.sprite(100, 100, 'player');\n   * adapter.trackSprite(player, `player-${adapter.myId}`);\n   * ```\n   */\n  trackSprite(sprite: any, key: string, options: SpriteTrackingOptions = {}): void {\n    this.trackedSprites.set(key, { sprite, options });\n\n    // Start sync loop if not already running (host only)\n    if (this.isHost() && !this.syncIntervalId) {\n      const interval = options.syncInterval || 50;\n      this.syncIntervalId = setInterval(() => this.syncAllSprites(), interval);\n    }\n\n    // Note: We do NOT immediately sync here to avoid infinite loops\n    // when trackSprite is called inside onChange callbacks.\n    // The interval-based sync will handle the first sync.\n  }\n\n  /**\n   * Stop tracking a sprite\n   */\n  untrackSprite(key: string): void {\n    this.trackedSprites.delete(key);\n\n    // Remove from state\n    this.runtime.mutateState((state: any) => {\n      const sprites = state[this.spriteNamespace];\n      if (sprites && sprites[key]) {\n        delete sprites[key];\n      }\n    });\n\n    // Stop sync loop if no more sprites\n    if (this.trackedSprites.size === 0 && this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n      this.syncIntervalId = null;\n    }\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcast(eventName: string, payload: any): void {\n    this.runtime.broadcastEvent(eventName, payload);\n  }\n\n  /**\n   * Listen for custom events\n   */\n  on(eventName: string, callback: (senderId: string, payload: any) => void): () => void {\n    return this.runtime.onEvent(eventName, (senderId, _eventName, payload) => {\n      callback(senderId, payload);\n    });\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.trackedSprites.clear();\n    this.remoteSprites.clear();\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  /**\n   * Sync all tracked sprites to state (host only)\n   */\n  private syncAllSprites(): void {\n    if (!this.isHost()) return;\n\n    for (const [key, { sprite, options }] of this.trackedSprites.entries()) {\n      this.syncSpriteToState(key, sprite, options);\n    }\n  }\n\n  /**\n   * Sync a single sprite to state\n   */\n  private syncSpriteToState(key: string, sprite: any, options: SpriteTrackingOptions): void {\n    const properties = options.properties || ['x', 'y', 'rotation', 'alpha'];\n    const updates: any = {};\n\n    for (const prop of properties) {\n      if (prop in sprite) {\n        updates[prop] = sprite[prop];\n      }\n    }\n\n    // Directly mutate state (host only)\n    this.runtime.mutateState((state: any) => {\n      if (!state[this.spriteNamespace]) {\n        state[this.spriteNamespace] = {};\n      }\n      const sprites = state[this.spriteNamespace];\n      sprites[key] = { ...sprites[key], ...updates };\n    });\n  }\n\n  /**\n   * Update sprites from state (clients only)\n   */\n  private updateSpritesFromState(state: any): void {\n    const sprites = state[this.spriteNamespace];\n    if (this.isHost() || !sprites) return;\n\n    // Update tracked sprites (sprites that exist on this client)\n    for (const [key, tracked] of this.trackedSprites.entries()) {\n      const spriteData = sprites[key];\n      if (spriteData) {\n        this.applySpriteData(tracked.sprite, spriteData);\n      }\n    }\n\n    // Update remote sprites (sprites from other players)\n    // Store target positions for interpolation\n    for (const [key, spriteData] of Object.entries(sprites)) {\n      // Skip if this is our own sprite\n      if (this.trackedSprites.has(key)) continue;\n\n      // If we have a remote sprite for this key, store target position\n      const remoteSprite = this.remoteSprites.get(key);\n      if (remoteSprite) {\n        // Store target position for smooth interpolation\n        remoteSprite._targetX = (spriteData as any).x;\n        remoteSprite._targetY = (spriteData as any).y;\n        remoteSprite._targetRotation = (spriteData as any).rotation;\n\n        // First update - snap to position immediately\n        if (remoteSprite._targetX !== undefined && remoteSprite.x === undefined) {\n          remoteSprite.x = remoteSprite._targetX;\n          remoteSprite.y = remoteSprite._targetY;\n          remoteSprite.rotation = remoteSprite._targetRotation || 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply sprite data to a sprite\n   */\n  private applySpriteData(sprite: any, data: any): void {\n    if ('x' in data) sprite.x = data.x;\n    if ('y' in data) sprite.y = data.y;\n    if ('rotation' in data) sprite.rotation = data.rotation;\n    if ('alpha' in data) sprite.alpha = data.alpha;\n    if ('scaleX' in data) sprite.scaleX = data.scaleX;\n    if ('scaleY' in data) sprite.scaleY = data.scaleY;\n    if ('visible' in data) sprite.visible = data.visible;\n  }\n\n  /**\n   * Register a remote sprite (for tracking sprites from other players)\n   *\n   * @param key - Unique identifier for this sprite\n   * @param sprite - The Phaser sprite to register\n   *\n   * @example\n   * ```ts\n   * adapter.onChange((state) => {\n   *   const sprites = state._sprites || state.gameSprites; // depends on config\n   *   for (const [key, data] of Object.entries(sprites)) {\n   *     if (!this.sprites[key] && key !== `player-${adapter.myId}`) {\n   *       const sprite = this.add.sprite(data.x, data.y, 'player');\n   *       adapter.registerRemoteSprite(key, sprite);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  registerRemoteSprite(key: string, sprite: any): void {\n    this.remoteSprites.set(key, sprite);\n  }\n\n  /**\n   * Call this in your Phaser update() loop to smoothly interpolate remote sprites\n   * This should be called every frame (60 FPS) for smooth movement\n   *\n   * Note: If autoInterpolate is enabled in config, you don't need to call this manually.\n   */\n  updateInterpolation(): void {\n    if (this.isHost()) return; // Only clients interpolate\n\n    for (const [key, sprite] of this.remoteSprites.entries()) {\n      if (sprite._targetX !== undefined) {\n        // Lerp towards target position\n        sprite.x += (sprite._targetX - sprite.x) * this.lerpFactor;\n        sprite.y += (sprite._targetY - sprite.y) * this.lerpFactor;\n\n        if (sprite._targetRotation !== undefined) {\n          sprite.rotation += (sprite._targetRotation - sprite.rotation) * this.lerpFactor;\n        }\n      }\n    }\n  }\n\n  /**\n   * Unregister a remote sprite\n   */\n  unregisterRemoteSprite(key: string): void {\n    const sprite = this.remoteSprites.get(key);\n    if (sprite && sprite.destroy) {\n      sprite.destroy();\n    }\n    this.remoteSprites.delete(key);\n  }\n\n  /**\n   * Listen for state changes (convenience wrapper)\n   */\n  onChange(callback: (state: TState) => void): () => void {\n    return this.runtime.onChange(callback);\n  }\n\n  /**\n   * Get the current game state (typed)\n   */\n  getState(): TState {\n    return this.runtime.getState();\n  }\n\n  /**\n   * Get the runtime (for advanced usage)\n   */\n  getRuntime(): GameRuntime<TState> {\n    return this.runtime;\n  }\n\n  // ============================================================================\n  // Helper Factories\n  // ============================================================================\n\n  /**\n   * Create a SpriteManager for automatic sprite synchronization\n   *\n   * @example\n   * ```ts\n   * const spriteManager = adapter.createSpriteManager({\n   *   onCreate: (key, data) => {\n   *     const sprite = this.add.sprite(data.x, data.y, 'player');\n   *     if (adapter.isHost()) {\n   *       this.physics.add.existing(sprite);\n   *     }\n   *     return sprite;\n   *   }\n   * });\n   *\n   * // Host: Add sprites\n   * spriteManager.add('player-1', { x: 100, y: 100 });\n   *\n   * // Update loop: Enable interpolation\n   * spriteManager.update();\n   * ```\n   */\n  createSpriteManager<TData extends { x: number; y: number; [key: string]: any }>(\n    config: SpriteManagerConfig<TData>\n  ): SpriteManager<TData> {\n    return new SpriteManager(this, config);\n  }\n\n  /**\n   * Create an InputManager for simplified input handling\n   *\n   * @example\n   * ```ts\n   * const input = adapter.createInputManager();\n   *\n   * input.bindKeys({\n   *   'ArrowLeft': { action: 'move', input: { x: -1 }, mode: 'continuous' },\n   *   'ArrowRight': { action: 'move', input: { x: 1 }, mode: 'continuous' },\n   *   'Space': 'jump'\n   * });\n   *\n   * // In update loop\n   * input.update();\n   * ```\n   */\n  createInputManager(): InputManager {\n    return new InputManager(this, this.scene);\n  }\n}\n", "/**\n * @martini/phaser/runtime\n *\n * High-level runtime initialization for Phaser games.\n * Abstracts away transport selection and configuration.\n */\n\nimport { GameRuntime, type GameDefinition } from '@martini/core';\nimport { LocalTransport } from '@martini/transport-local';\n// import { TrysteroTransport } from '@martini/transport-trystero'; // Disabled for IDE\nimport { IframeBridgeTransport } from '@martini/transport-iframe-bridge';\nimport type { Transport } from '@martini/core';\nimport Phaser from 'phaser';\n\n/**\n * Platform-injected configuration (set by IDE, demos, production runtime)\n */\nexport interface MartiniConfig {\n  transport: {\n    type: 'local' | 'iframe-bridge' | 'trystero';\n    roomId: string;\n    isHost: boolean;\n    appId?: string; // For Trystero\n  };\n}\n\n/**\n * User-provided game configuration\n */\nexport interface GameConfig<TState = any> {\n  /** Game definition (logic, actions, setup) */\n  game: GameDefinition<TState>;\n\n  /** Scene factory function that receives the runtime */\n  scene: (runtime: GameRuntime<TState>) => typeof Phaser.Scene | Phaser.Types.Scenes.CreateSceneFromObjectConfig;\n\n  /** Phaser engine configuration */\n  phaserConfig?: Partial<Phaser.Types.Core.GameConfig>;\n}\n\n/**\n * Initialize a multiplayer Phaser game.\n *\n * This is the main entry point for user code. It handles:\n * - Reading platform configuration (transport type, room ID, etc.)\n * - Creating the appropriate transport\n * - Setting up the GameRuntime\n * - Creating the Phaser game instance\n *\n * User code never needs to know about transports!\n *\n * @example\n * ```typescript\n * import { initializeGame } from '@martini/phaser';\n * import { game } from './game';\n * import { createScene } from './scene';\n *\n * initializeGame({\n *   game,\n *   scene: createScene,\n *   phaserConfig: {\n *     width: 800,\n *     height: 600,\n *     backgroundColor: '#1a1a2e'\n *   }\n * });\n * ```\n */\nexport function initializeGame<TState = any>(\n  config: GameConfig<TState>\n): { runtime: GameRuntime<TState>; phaser: Phaser.Game } {\n  // Read platform-injected config\n  const platformConfig = (window as any).__MARTINI_CONFIG__ as MartiniConfig | undefined;\n\n  if (!platformConfig) {\n    throw new Error(\n      'Missing __MARTINI_CONFIG__. The platform must inject this before running user code.'\n    );\n  }\n\n  // Create transport based on platform config\n  const transport = createTransport(platformConfig.transport);\n\n  // Create runtime with own player ID (peers discovered via onPeerJoin)\n  const runtime = new GameRuntime(\n    config.game,\n    transport,\n    {\n      isHost: platformConfig.transport.isHost,\n      playerIds: [transport.getPlayerId()]\n    }\n  );\n\n  // Create Phaser game with user's scene and config\n  // Default scale configuration ensures canvas fits container properly\n  const defaultScale = {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n    width: config.phaserConfig?.width || 800,\n    height: config.phaserConfig?.height || 600\n  };\n\n  const phaserConfig: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    parent: 'game',\n    scale: defaultScale,\n    ...config.phaserConfig,\n    scene: config.scene(runtime)\n  };\n\n  const phaserGame = new Phaser.Game(phaserConfig);\n\n  // Register runtime with IDE sandbox (if present)\n  if (typeof window !== 'undefined' && (window as any).__MARTINI_IDE__) {\n    (window as any).__MARTINI_IDE__.registerRuntime(runtime);\n  }\n\n  return { runtime, phaser: phaserGame };\n}\n\n/**\n * Create transport from platform configuration\n * @internal\n */\nfunction createTransport(config: MartiniConfig['transport']): Transport {\n  switch (config.type) {\n    case 'iframe-bridge':\n      return new IframeBridgeTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    case 'local':\n      return new LocalTransport({\n        roomId: config.roomId,\n        isHost: config.isHost\n      });\n\n    // case 'trystero':\n    //   return new TrysteroTransport({\n    //     appId: config.appId || 'martini',\n    //     roomId: config.roomId,\n    //     isHost: config.isHost\n    //   });\n\n    default:\n      throw new Error(`Unknown transport type: ${(config as any).type}. Only 'local' and 'iframe-bridge' are supported in IDE mode.`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
