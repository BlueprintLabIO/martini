{
  "version": 3,
  "sources": ["../src/defineGame.ts", "../src/sync.ts", "../src/SeededRandom.ts", "../src/GameRuntime.ts", "../src/Logger.ts", "../src/PlayerManager.ts", "../src/helpers.ts"],
  "sourcesContent": ["/**\n * High-level API for defining multiplayer games (v2)\n *\n * Host-authoritative: the host runs the game, others mirror the state.\n */\n\nimport type { SeededRandom } from './SeededRandom.js';\n\n/**\n * Setup context - provides initial player list and deterministic random\n */\nexport interface SetupContext {\n  /** Initial player IDs */\n  playerIds: string[];\n\n  /** Deterministic random number generator (seeded, same across all clients) */\n  random: SeededRandom;\n}\n\n/**\n * Action context - provides information about who submitted the action\n *\n * \u26A0\uFE0F **IMPORTANT:** Use `targetId` (not `playerId`) for state mutations!\n *\n * @example Correct usage:\n * ```ts\n * actions: {\n *   move: {\n *     apply: (state, context, input) => {\n *       // \u2705 CORRECT: Use targetId to identify which player to affect\n *       state.players[context.targetId].x += input.dx;\n *     }\n *   }\n * }\n * ```\n *\n * @example Incorrect usage:\n * ```ts\n * actions: {\n *   move: {\n *     apply: (state, context, input) => {\n *       // \u274C WRONG: playerId is who pressed the key, not who to affect\n *       state.players[context.playerId].x += input.dx;\n *     }\n *   }\n * }\n * ```\n *\n * @example When they differ:\n * ```ts\n * // Player A controls Player B's character:\n * runtime.submitAction('move', { dx: 10 }, 'player-B'); // targetId = 'player-B'\n *\n * // In the action:\n * apply: (state, context, input) => {\n *   console.log(context.playerId);  // 'player-A' (who submitted)\n *   console.log(context.targetId);  // 'player-B' (who to affect)\n * }\n * ```\n */\nexport interface ActionContext {\n  /**\n   * ID of the player who called submitAction()\n   *\n   * \u26A0\uFE0F **Rarely needed in actions!** Most actions should use `targetId` instead.\n   *\n   * Use this for:\n   * - Logging who triggered an action\n   * - Checking permissions (e.g., \"can this player do this action?\")\n   * - Recording action history\n   *\n   * Do NOT use this for:\n   * - Modifying player state (use `targetId` instead)\n   * - Storing input data (use `targetId` instead)\n   */\n  playerId: string;\n\n  /**\n   * ID of the player who should be affected by this action\n   *\n   * \u2705 **Use this for state mutations!**\n   *\n   * Defaults to `playerId` when no targetId is specified in submitAction().\n   *\n   * @example\n   * ```ts\n   * // Store input for the affected player\n   * state.inputs[context.targetId] = input;\n   *\n   * // Update the affected player's position\n   * state.players[context.targetId].x = input.x;\n   * ```\n   */\n  targetId: string;\n\n  /** Whether this action is being applied on the host */\n  isHost: boolean;\n\n  /** Deterministic random number generator (seeded per action) */\n  random: SeededRandom;\n}\n\n/**\n * Action definition with typed state and input\n */\nexport interface ActionDefinition<TState = any, TInput = any> {\n  /** Input validation schema (optional) */\n  input?: any;\n\n  /** Apply function - modifies state directly */\n  apply: (state: TState, context: ActionContext, input: TInput) => void;\n}\n\n/**\n * Game definition with typed state\n */\nexport interface GameDefinition<TState = any> {\n  /** Initial state factory */\n  setup?: (context: SetupContext) => TState;\n\n  /** Actions - only way to modify state (optional - sprite syncing is automatic) */\n  actions?: Record<string, ActionDefinition<TState, any>>;\n\n  /** Called when a player joins mid-game */\n  onPlayerJoin?: (state: TState, playerId: string) => void;\n\n  /** Called when a player leaves */\n  onPlayerLeave?: (state: TState, playerId: string) => void;\n}\n\n/**\n * Define a multiplayer game with full TypeScript type safety\n *\n * @example\n * ```ts\n * interface GameState {\n *   players: Record<string, { x: number; y: number; score: number }>;\n * }\n *\n * const game = defineGame<GameState>({\n *   setup: ({ playerIds, random }) => ({\n *     players: Object.fromEntries(\n *       playerIds.map(id => [id, {\n *         x: random.range(0, 800),  // \u2705 Deterministic!\n *         y: random.range(0, 600),\n *         score: 0\n *       }])\n *     )\n *   }),\n *\n *   actions: {\n *     move: {\n *       input: { x: 'number', y: 'number' },\n *       apply(state, context, input) {\n *         // \u2705 Full type safety - autocomplete works!\n *         state.players[context.targetId].x = input.x;\n *         state.players[context.targetId].y = input.y;\n *       }\n *     }\n *   }\n * });\n * ```\n */\nexport function defineGame<TState = any>(\n  definition: GameDefinition<TState>\n): GameDefinition<TState> {\n  // Basic validation\n  if (!definition.actions) {\n    definition.actions = {};\n  }\n\n  // Validate actions if they exist\n  for (const [name, action] of Object.entries(definition.actions)) {\n    if (typeof action.apply !== 'function') {\n      throw new Error(`Action \"${name}\" must have an apply function`);\n    }\n  }\n\n  return definition;\n}\n", "/**\n * State synchronization using diffs/patches\n * Kept from v1 because it's efficient and engine-agnostic\n */\n\nexport interface Patch {\n  op: 'replace' | 'add' | 'remove';\n  path: string[];\n  value?: any;\n}\n\n/**\n * Generate a minimal diff between two states\n */\nexport function generateDiff(oldState: any, newState: any): Patch[] {\n  const patches: Patch[] = [];\n\n  function diff(oldVal: any, newVal: any, path: string[] = []) {\n    // Type change or primitive difference\n    if (typeof oldVal !== typeof newVal || oldVal === null || newVal === null) {\n      if (oldVal !== newVal) {\n        patches.push({ op: 'replace', path, value: newVal });\n      }\n      return;\n    }\n\n    // Array handling\n    if (Array.isArray(newVal)) {\n      if (!Array.isArray(oldVal) || oldVal.length !== newVal.length) {\n        patches.push({ op: 'replace', path, value: newVal });\n        return;\n      }\n\n      for (let i = 0; i < newVal.length; i++) {\n        diff(oldVal[i], newVal[i], [...path, String(i)]);\n      }\n      return;\n    }\n\n    // Object handling\n    if (typeof newVal === 'object') {\n      const oldKeys = Object.keys(oldVal || {});\n      const newKeys = Object.keys(newVal || {});\n\n      // Check removed keys\n      for (const key of oldKeys) {\n        if (!(key in newVal)) {\n          patches.push({ op: 'remove', path: [...path, key] });\n        }\n      }\n\n      // Check added/changed keys\n      for (const key of newKeys) {\n        if (!(key in oldVal)) {\n          patches.push({ op: 'add', path: [...path, key], value: newVal[key] });\n        } else {\n          diff(oldVal[key], newVal[key], [...path, key]);\n        }\n      }\n      return;\n    }\n\n    // Primitive comparison\n    if (oldVal !== newVal) {\n      patches.push({ op: 'replace', path, value: newVal });\n    }\n  }\n\n  diff(oldState, newState);\n  return patches;\n}\n\n/**\n * Apply a patch to state (mutates state)\n */\nexport function applyPatch(state: any, patch: Patch): void {\n  const { op, path, value } = patch;\n\n  if (path.length === 0) {\n    throw new Error('Cannot patch root - path must have at least one element');\n  }\n\n  // Navigate to parent\n  let current = state;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (!(key in current)) {\n      current[key] = {};\n    }\n    current = current[key];\n  }\n\n  const finalKey = path[path.length - 1];\n\n  switch (op) {\n    case 'add':\n    case 'replace':\n      current[finalKey] = value;\n      break;\n\n    case 'remove':\n      if (Array.isArray(current)) {\n        current.splice(Number(finalKey), 1);\n      } else {\n        delete current[finalKey];\n      }\n      break;\n  }\n}\n\n/**\n * Deep clone an object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as any;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n\n  const cloned: any = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n", "/**\n * SeededRandom - Deterministic Pseudo-Random Number Generator\n *\n * Provides a deterministic PRNG that produces the same sequence of\n * random numbers given the same seed. This ensures all clients in a\n * multiplayer game generate identical random values during setup and gameplay.\n *\n * Uses a simple Linear Congruential Generator (LCG) algorithm which is\n * fast, deterministic, and sufficient for game randomness (not cryptography).\n *\n * @example\n * ```typescript\n * const rng = new SeededRandom(12345);\n *\n * // Generate random numbers\n * rng.next();              // 0.0 to 1.0\n * rng.range(10, 20);       // 10 to 19 (integer)\n * rng.float(0, 100);       // 0.0 to 100.0 (float)\n * rng.choice(['a', 'b']);  // Random element\n * rng.shuffle([1, 2, 3]);  // Shuffled array\n * rng.boolean(0.7);        // 70% chance of true\n * ```\n */\n\nexport class SeededRandom {\n  private state: number;\n\n  // LCG parameters (from Numerical Recipes)\n  private readonly m = 0x80000000; // 2^31\n  private readonly a = 1103515245;\n  private readonly c = 12345;\n\n  /**\n   * Creates a new SeededRandom instance\n   *\n   * @param seed - Initial seed value (any integer)\n   */\n  constructor(seed: number) {\n    // Ensure seed is a positive integer\n    this.state = Math.abs(Math.floor(seed)) % this.m;\n    if (this.state === 0) this.state = 1;\n  }\n\n  /**\n   * Generate next random number in sequence\n   *\n   * @returns Random float in range [0, 1)\n   */\n  next(): number {\n    this.state = (this.a * this.state + this.c) % this.m;\n    return this.state / this.m;\n  }\n\n  /**\n   * Generate random integer in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random integer in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.range(0, 10);   // 0-9\n   * rng.range(10, 20);  // 10-19\n   * rng.range(-5, 5);   // -5 to 4\n   * ```\n   */\n  range(min: number, max: number): number {\n    if (min === max) return min;\n    return Math.floor(this.next() * (max - min)) + min;\n  }\n\n  /**\n   * Generate random float in range [min, max)\n   *\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random float in [min, max)\n   *\n   * @example\n   * ```typescript\n   * rng.float(0, 1);      // 0.0 to 0.999...\n   * rng.float(0, 100);    // 0.0 to 99.999...\n   * rng.float(-1, 1);     // -1.0 to 0.999...\n   * ```\n   */\n  float(min: number, max: number): number {\n    return this.next() * (max - min) + min;\n  }\n\n  /**\n   * Choose random element from array\n   *\n   * @param array - Array to choose from\n   * @returns Random element from array\n   * @throws Error if array is empty\n   *\n   * @example\n   * ```typescript\n   * rng.choice(['red', 'blue', 'green']);\n   * rng.choice([1, 2, 3, 4, 5]);\n   * ```\n   */\n  choice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    return array[this.range(0, array.length)];\n  }\n\n  /**\n   * Shuffle array (Fisher-Yates algorithm)\n   * Returns a new shuffled array without modifying the original\n   *\n   * @param array - Array to shuffle\n   * @returns New shuffled array\n   *\n   * @example\n   * ```typescript\n   * const cards = ['A', 'K', 'Q', 'J'];\n   * const shuffled = rng.shuffle(cards);\n   * // cards is unchanged, shuffled is randomized\n   * ```\n   */\n  shuffle<T>(array: T[]): T[] {\n    if (array.length <= 1) return [...array];\n\n    const result = [...array];\n\n    // Fisher-Yates shuffle\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = this.range(0, i + 1);\n      [result[i], result[j]] = [result[j], result[i]];\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate random boolean with optional probability\n   *\n   * @param probability - Probability of returning true (0.0 to 1.0, default 0.5)\n   * @returns true or false based on probability\n   *\n   * @example\n   * ```typescript\n   * rng.boolean();      // 50% chance of true\n   * rng.boolean(0.7);   // 70% chance of true\n   * rng.boolean(1.0);   // Always true\n   * rng.boolean(0.0);   // Always false\n   * ```\n   */\n  boolean(probability = 0.5): boolean {\n    return this.next() < probability;\n  }\n}\n", "/**\n * GameRuntime - Host-authoritative game state manager\n *\n * v2: Simplified, no determinism, no prediction, no rollback.\n * The host runs the game, clients mirror the state.\n */\n\nimport type { GameDefinition } from './defineGame.js';\nimport type { Transport, WireMessage, RuntimeConfig } from './transport.js';\nimport { generateDiff, applyPatch, deepClone, type Patch } from './sync.js';\nimport { SeededRandom } from './SeededRandom.js';\n\ntype StateChangeCallback<TState> = (state: TState) => void;\ntype EventCallback = (senderId: string, eventName: string, payload: any) => void;\n\n/**\n * Extended runtime configuration with strict mode\n */\nexport interface GameRuntimeConfig extends RuntimeConfig {\n  /** Throw errors instead of warnings (recommended for development) */\n  strict?: boolean;\n\n  /**\n   * Validate that all playerIds are initialized in setup()\n   * Throws an error if strictPlayerInit is true, warns otherwise\n   * @default false\n   */\n  strictPlayerInit?: boolean;\n\n  /**\n   * Key in state where players are stored (for validation)\n   * @default 'players'\n   */\n  playersKey?: string;\n}\n\nexport class GameRuntime<TState = any> {\n  private state: TState = {} as TState;\n  private previousState: TState = {} as TState;\n  private _isHost: boolean;\n  private syncIntervalId: any = null;\n  private unsubscribes: Array<() => void> = [];\n  private strict: boolean;\n  private actionCounter: number = 100000; // For seeding action random (start high to avoid LCG collisions)\n\n  private stateChangeCallbacks: StateChangeCallback<TState>[] = [];\n  private eventCallbacks: Map<string, EventCallback[]> = new Map();\n\n  constructor(\n    private gameDef: GameDefinition<TState>,\n    private transport: Transport,\n    private config: GameRuntimeConfig\n  ) {\n    this._isHost = config.isHost;\n    this.strict = config.strict ?? false;\n\n    // Initialize state\n    const initialPlayerIds = config.playerIds || [];\n    if (gameDef.setup) {\n      // Create deterministic random for setup (same seed for all clients)\n      const setupRandom = new SeededRandom(12345);\n      this.state = gameDef.setup({ playerIds: initialPlayerIds, random: setupRandom });\n    }\n    this.previousState = deepClone(this.state);\n\n    // Validate player initialization (dev mode)\n    if (process.env.NODE_ENV !== 'production' && initialPlayerIds.length > 0) {\n      this.validatePlayerInitialization(initialPlayerIds);\n    }\n\n    // Setup transport listeners\n    this.setupTransport();\n\n    // Start sync loop if host\n    if (this._isHost) {\n      const syncInterval = config.syncInterval || 50; // 20 FPS default\n      this.syncIntervalId = setInterval(() => this.syncState(), syncInterval);\n    }\n  }\n\n  /**\n   * Get current state (read-only, typed)\n   */\n  getState(): TState {\n    return this.state;\n  }\n\n  /**\n   * Check if this runtime is the host\n   */\n  isHost(): boolean {\n    return this._isHost;\n  }\n\n  /**\n   * Get the current player's ID\n   *\n   * @returns The unique player ID for this client\n   *\n   * @example\n   * ```ts\n   * const myId = runtime.getMyPlayerId();\n   * console.log('My player ID:', myId);\n   * ```\n   */\n  getMyPlayerId(): string {\n    return this.transport.getPlayerId();\n  }\n\n  /**\n   * Get transport (for adapters to check isHost, getPlayerId, etc)\n   * @internal\n   */\n  getTransport(): Transport {\n    return this.transport;\n  }\n\n  /**\n   * Directly mutate state (for adapters only - bypasses actions)\n   * Only the host should call this\n   * @internal\n   */\n  mutateState(mutator: (state: TState) => void): void {\n    if (!this._isHost) {\n      this.handleError('mutateState called on non-host - ignoring');\n      return;\n    }\n    mutator(this.state);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Execute an action (validates input, applies to state, broadcasts)\n   * @param actionName - Name of the action to execute\n   * @param input - Action payload/input data\n   * @param targetId - Optional target player ID (defaults to caller's ID)\n   */\n  submitAction(actionName: string, input: any, targetId?: string): void {\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined in game');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      const suggestion = this.findClosestMatch(actionName, availableActions);\n\n      let errorMsg = `Action \"${actionName}\" not found.`;\n\n      if (availableActions.length > 0) {\n        errorMsg += `\\n\\nAvailable actions: ${availableActions.join(', ')}`;\n        if (suggestion) {\n          errorMsg += `\\n\\nDid you mean \"${suggestion}\"?`;\n        }\n      } else {\n        errorMsg += '\\n\\nNo actions are defined in your game.';\n      }\n\n      this.handleError(errorMsg);\n      return;\n    }\n\n    const playerId = this.transport.getPlayerId();\n\n    // Create deterministic random for this action\n    const actionSeed = this.actionCounter++;\n    const actionRandom = new SeededRandom(actionSeed);\n\n    const context = {\n      playerId,                          // Who called submitAction\n      targetId: targetId || playerId,    // Who is affected (defaults to caller)\n      isHost: this._isHost,\n      random: actionRandom\n    };\n\n    // If we're the host, apply immediately\n    if (this._isHost) {\n      action.apply(this.state, context, input);\n      this.notifyStateChange();\n    }\n\n    // Broadcast action to all peers (include actionSeed for determinism)\n    this.transport.send({\n      type: 'action',\n      payload: { actionName, input, context, actionSeed },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Broadcast a custom event\n   */\n  broadcastEvent(eventName: string, payload: any): void {\n    const playerId = this.transport.getPlayerId();\n    this.transport.send({\n      type: 'event',\n      payload: { eventName, payload },\n      senderId: playerId\n    });\n  }\n\n  /**\n   * Listen for custom events\n   */\n  onEvent(eventName: string, callback: EventCallback): () => void {\n    if (!this.eventCallbacks.has(eventName)) {\n      this.eventCallbacks.set(eventName, []);\n    }\n    this.eventCallbacks.get(eventName)!.push(callback);\n\n    return () => {\n      const callbacks = this.eventCallbacks.get(eventName);\n      if (callbacks) {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Listen for state changes (typed)\n   */\n  onChange(callback: StateChangeCallback<TState>): () => void {\n    this.stateChangeCallbacks.push(callback);\n    return () => {\n      const index = this.stateChangeCallbacks.indexOf(callback);\n      if (index !== -1) this.stateChangeCallbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    if (this.syncIntervalId) {\n      clearInterval(this.syncIntervalId);\n    }\n    this.unsubscribes.forEach(unsub => unsub());\n    this.unsubscribes = [];\n  }\n\n  // ============================================================================\n  // Private methods\n  // ============================================================================\n\n  private setupTransport(): void {\n    // Listen for incoming messages\n    this.unsubscribes.push(\n      this.transport.onMessage((msg, senderId) => {\n        this.handleMessage(msg, senderId);\n      })\n    );\n\n    // Listen for peer join\n    this.unsubscribes.push(\n      this.transport.onPeerJoin((peerId) => {\n        if (this.gameDef.onPlayerJoin) {\n          this.gameDef.onPlayerJoin(this.state, peerId);\n        }\n\n        // If we're the host, send full state to new peer\n        if (this._isHost) {\n          this.transport.send({\n            type: 'state_sync',\n            payload: { fullState: this.state }\n          }, peerId);\n        }\n      })\n    );\n\n    // Listen for peer leave\n    this.unsubscribes.push(\n      this.transport.onPeerLeave((peerId) => {\n        if (this.gameDef.onPlayerLeave) {\n          this.gameDef.onPlayerLeave(this.state, peerId);\n        }\n      })\n    );\n  }\n\n  private handleMessage(msg: WireMessage, senderId: string): void {\n    switch (msg.type) {\n      case 'state_sync':\n        // Only clients should receive state syncs\n        if (!this._isHost) {\n          this.handleStateSync(msg.payload);\n        }\n        break;\n\n      case 'action':\n        // Only host processes actions from clients\n        if (this._isHost && senderId !== this.transport.getPlayerId()) {\n          this.handleActionFromClient(msg.payload);\n        }\n        break;\n\n      case 'event':\n        this.handleEvent(senderId, msg.payload);\n        break;\n    }\n  }\n\n  private handleStateSync(payload: any): void {\n    if (payload.fullState) {\n      // Full state replacement\n      this.state = payload.fullState;\n      this.notifyStateChange();\n    } else if (payload.patches) {\n      // Apply patches\n      for (const patch of payload.patches) {\n        applyPatch(this.state, patch);\n      }\n      this.notifyStateChange();\n    }\n  }\n\n  private handleActionFromClient(payload: any): void {\n    const { actionName, input, context, actionSeed } = payload;\n\n    if (!this.gameDef.actions) {\n      this.handleError('No actions defined');\n      return;\n    }\n\n    const action = this.gameDef.actions[actionName];\n    if (!action) {\n      const availableActions = Object.keys(this.gameDef.actions);\n      this.handleError(\n        `Unknown action from client: ${actionName}. Available: ${availableActions.join(', ')}`\n      );\n      return;\n    }\n\n    // Recreate the same random from the actionSeed for determinism\n    const contextWithRandom = {\n      ...context,\n      random: new SeededRandom(actionSeed)\n    };\n\n    // Apply action to state with context\n    action.apply(this.state, contextWithRandom, input);\n    this.notifyStateChange();\n  }\n\n  private handleEvent(senderId: string, payload: any): void {\n    const { eventName, payload: eventPayload } = payload;\n    const callbacks = this.eventCallbacks.get(eventName) || [];\n\n    for (const callback of callbacks) {\n      callback(senderId, eventName, eventPayload);\n    }\n  }\n\n  private syncState(): void {\n    if (!this._isHost) return;\n\n    // Generate diff\n    const patches = generateDiff(this.previousState, this.state);\n\n    if (patches.length > 0) {\n      // Broadcast patches to all clients\n      this.transport.send({\n        type: 'state_sync',\n        payload: { patches }\n      });\n\n      // Update previous state\n      this.previousState = deepClone(this.state);\n    }\n  }\n\n  private notifyStateChange(): void {\n    for (const callback of this.stateChangeCallbacks) {\n      callback(this.state);\n    }\n  }\n\n  /**\n   * Handle errors with strict mode support\n   */\n  private handleError(message: string): void {\n    if (this.strict) {\n      throw new Error(`[Martini] ${message}`);\n    } else {\n      console.warn(`[Martini] ${message}`);\n    }\n  }\n\n  /**\n   * Find closest string match (for typo suggestions)\n   */\n  private findClosestMatch(input: string, options: string[]): string | null {\n    if (options.length === 0) return null;\n\n    let minDistance = Infinity;\n    let closest: string | null = null;\n\n    for (const option of options) {\n      const distance = this.levenshteinDistance(input.toLowerCase(), option.toLowerCase());\n      if (distance < minDistance && distance <= 3) { // Max 3 character difference\n        minDistance = distance;\n        closest = option;\n      }\n    }\n\n    return closest;\n  }\n\n  /**\n   * Calculate Levenshtein distance for typo detection\n   */\n  private levenshteinDistance(str1: string, str2: string): number {\n    const m = str1.length;\n    const n = str2.length;\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (str1[i - 1] === str2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = Math.min(\n            dp[i - 1][j] + 1,    // deletion\n            dp[i][j - 1] + 1,    // insertion\n            dp[i - 1][j - 1] + 1 // substitution\n          );\n        }\n      }\n    }\n\n    return dp[m][n];\n  }\n\n  /**\n   * Validate that all playerIds are initialized in state.players\n   * Emits warning or throws error based on configuration\n   */\n  private validatePlayerInitialization(playerIds: string[]): void {\n    const playersKey = this.config.playersKey || 'players';\n    const players = (this.state as any)[playersKey];\n\n    // Check if players key exists\n    if (!players || typeof players !== 'object') {\n      const message = [\n        `\u26A0\uFE0F  Player initialization issue detected:`,\n        ``,\n        `Expected state.${playersKey} to be an object, but got: ${typeof players}`,\n        ``,\n        `Fix: Initialize players in setup():`,\n        `  setup: ({ playerIds }) => ({`,\n        `    ${playersKey}: Object.fromEntries(`,\n        `      playerIds.map(id => [id, { x: 100, y: 100 }])`,\n        `    )`,\n        `  })`\n      ].join('\\n');\n\n      if (this.config.strictPlayerInit) {\n        throw new Error(message);\n      } else {\n        console.warn(message);\n      }\n      return;\n    }\n\n    // Check if all playerIds are initialized\n    const missingPlayers = playerIds.filter(id => !(id in players));\n\n    if (missingPlayers.length > 0) {\n      const message = [\n        `\u26A0\uFE0F  Player initialization issue detected:`,\n        ``,\n        `Expected ${playerIds.length} players, but ${missingPlayers.length} missing from state.${playersKey}`,\n        `Missing player IDs: ${missingPlayers.join(', ')}`,\n        ``,\n        `Fix: Initialize all players in setup():`,\n        `  setup: ({ playerIds }) => ({`,\n        `    ${playersKey}: Object.fromEntries(`,\n        `      playerIds.map((id, index) => [id, {`,\n        `        x: index * 100,`,\n        `        y: 100,`,\n        `        score: 0`,\n        `      }])`,\n        `    )`,\n        `  })`,\n        ``,\n        `Or use the createPlayers helper:`,\n        `  import { createPlayers } from '@martini/core';`,\n        ``,\n        `  setup: ({ playerIds }) => ({`,\n        `    ${playersKey}: createPlayers(playerIds, (id, index) => ({`,\n        `      x: index * 100, y: 100, score: 0`,\n        `    }))`,\n        `  })`\n      ].join('\\n');\n\n      if (this.config.strictPlayerInit) {\n        throw new Error(message);\n      } else {\n        console.warn(message);\n      }\n    }\n  }\n}\n", "/**\n * Logger - Unity-inspired logging system for Martini\n *\n * Provides structured logging with channels, levels, assertions, and DevTools integration.\n * Inspired by Unity's Debug class and browser console API.\n */\n\nexport type LogLevel = 'log' | 'warn' | 'error';\n\nexport interface LogEntry {\n\tlevel: LogLevel;\n\tchannel: string;\n\tmessage: string;\n\tdata: any[];\n\ttimestamp: number;\n\tcontext?: Record<string, any>;\n\tstack?: string;\n}\n\nexport type LogListener = (entry: LogEntry) => void;\n\nexport class Logger {\n\tprivate channelName: string;\n\tprivate listeners: LogListener[] = [];\n\tprivate enabled: boolean = true;\n\tprivate minLevel: LogLevel = 'log';\n\tprivate context?: Record<string, any>;\n\tprivate parentContext?: Record<string, any>;\n\tprivate includeStack: boolean = false;\n\tprivate timers: Map<string, number> = new Map();\n\n\tprivate static readonly LEVEL_PRIORITY: Record<LogLevel, number> = {\n\t\tlog: 0,\n\t\twarn: 1,\n\t\terror: 2\n\t};\n\n\tconstructor(channel: string = '', parentContext?: Record<string, any>) {\n\t\tthis.channelName = channel;\n\t\tthis.parentContext = parentContext;\n\t}\n\n\t/**\n\t * Log an informational message\n\t */\n\tlog(message: string, ...data: any[]): void {\n\t\tthis.writeLog('log', message, data);\n\t}\n\n\t/**\n\t * Log a warning message\n\t */\n\twarn(message: string, ...data: any[]): void {\n\t\tthis.writeLog('warn', message, data);\n\t}\n\n\t/**\n\t * Log an error message\n\t */\n\terror(message: string, ...data: any[]): void {\n\t\tthis.writeLog('error', message, data);\n\t}\n\n\t/**\n\t * Create a collapsible group in the console\n\t */\n\tgroup(label: string): void {\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(label);\n\t\t\tconsole.group(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * End the current group\n\t */\n\tgroupEnd(): void {\n\t\tif (this.enabled) {\n\t\t\tconsole.groupEnd();\n\t\t}\n\t}\n\n\t/**\n\t * Assert a condition, log error if false\n\t */\n\tassert(condition: boolean, message?: string): void {\n\t\tif (!condition) {\n\t\t\tconst assertMessage = message ? `Assertion failed: ${message}` : 'Assertion failed';\n\t\t\tthis.writeLog('error', assertMessage, []);\n\t\t}\n\t}\n\n\t/**\n\t * Start a performance timer\n\t */\n\ttime(label: string): void {\n\t\tthis.timers.set(label, performance.now());\n\t}\n\n\t/**\n\t * End a performance timer and log the duration\n\t */\n\ttimeEnd(label: string): void {\n\t\tconst startTime = this.timers.get(label);\n\n\t\tif (startTime === undefined) {\n\t\t\tthis.warn(`Timer \"${label}\" does not exist`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst duration = performance.now() - startTime;\n\t\tthis.timers.delete(label);\n\n\t\tif (this.enabled) {\n\t\t\tconst formatted = this.formatMessage(`${label}: ${duration.toFixed(2)}ms`);\n\t\t\tconsole.log(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * Create a child logger with a nested channel name\n\t */\n\tchannel(name: string): Logger {\n\t\tconst childChannel = this.channelName ? `${this.channelName}:${name}` : name;\n\t\tconst mergedContext = this.getMergedContext();\n\t\tconst child = new Logger(childChannel, mergedContext);\n\t\tchild.enabled = this.enabled;\n\t\tchild.minLevel = this.minLevel;\n\t\tchild.includeStack = this.includeStack;\n\t\treturn child;\n\t}\n\n\t/**\n\t * Register a listener for log entries (used by DevTools)\n\t */\n\tonLog(listener: LogListener): () => void {\n\t\tthis.listeners.push(listener);\n\n\t\t// Return unsubscribe function\n\t\treturn () => {\n\t\t\tconst index = this.listeners.indexOf(listener);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.listeners.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Enable or disable console output\n\t * Note: Listeners are still notified when disabled (for DevTools)\n\t */\n\tsetEnabled(enabled: boolean): void {\n\t\tthis.enabled = enabled;\n\t}\n\n\t/**\n\t * Set minimum log level (filters out lower priority logs)\n\t */\n\tsetMinLevel(level: LogLevel): void {\n\t\tthis.minLevel = level;\n\t}\n\n\t/**\n\t * Attach context data to all log entries\n\t */\n\tsetContext(context: Record<string, any> | undefined): void {\n\t\tthis.context = context;\n\t}\n\n\t/**\n\t * Include stack traces in all log entries\n\t */\n\tsetIncludeStack(include: boolean): void {\n\t\tthis.includeStack = include;\n\t}\n\n\t/**\n\t * Internal: Write a log entry\n\t */\n\tprivate writeLog(level: LogLevel, message: string, data: any[]): void {\n\t\t// Check if this level should be logged\n\t\tif (!this.shouldLog(level)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entry: LogEntry = {\n\t\t\tlevel,\n\t\t\tchannel: this.channelName,\n\t\t\tmessage,\n\t\t\tdata,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontext: this.getMergedContext()\n\t\t};\n\n\t\t// Add stack trace if needed\n\t\tif (this.includeStack || level === 'error') {\n\t\t\tentry.stack = this.captureStack();\n\t\t}\n\n\t\t// Notify listeners (even if console is disabled)\n\t\tthis.notifyListeners(entry);\n\n\t\t// Write to console if enabled\n\t\tif (this.enabled) {\n\t\t\tthis.writeToConsole(level, message, data);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a log level should be output\n\t */\n\tprivate shouldLog(level: LogLevel): boolean {\n\t\tconst levelPriority = Logger.LEVEL_PRIORITY[level];\n\t\tconst minPriority = Logger.LEVEL_PRIORITY[this.minLevel];\n\t\treturn levelPriority >= minPriority;\n\t}\n\n\t/**\n\t * Format message with channel prefix\n\t */\n\tprivate formatMessage(message: string): string {\n\t\tif (this.channelName) {\n\t\t\treturn `[${this.channelName}] ${message}`;\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Write to browser console\n\t */\n\tprivate writeToConsole(level: LogLevel, message: string, data: any[]): void {\n\t\tconst formatted = this.formatMessage(message);\n\n\t\tswitch (level) {\n\t\t\tcase 'log':\n\t\t\t\tconsole.log(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'warn':\n\t\t\t\tconsole.warn(formatted, ...data);\n\t\t\t\tbreak;\n\t\t\tcase 'error':\n\t\t\t\tconsole.error(formatted, ...data);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Notify all listeners\n\t */\n\tprivate notifyListeners(entry: LogEntry): void {\n\t\tfor (const listener of this.listeners) {\n\t\t\ttry {\n\t\t\t\tlistener(entry);\n\t\t\t} catch (err) {\n\t\t\t\t// Don't let listener errors break logging\n\t\t\t\tconsole.error('Error in log listener:', err);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Merge parent and local context\n\t */\n\tprivate getMergedContext(): Record<string, any> | undefined {\n\t\tif (!this.parentContext && !this.context) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\t...this.parentContext,\n\t\t\t...this.context\n\t\t};\n\t}\n\n\t/**\n\t * Capture current stack trace\n\t */\n\tprivate captureStack(): string {\n\t\tconst error = new Error();\n\t\tif (error.stack) {\n\t\t\t// Remove the first few lines (Error constructor, this function, writeLog)\n\t\t\tconst lines = error.stack.split('\\n');\n\t\t\treturn lines.slice(3).join('\\n');\n\t\t}\n\t\treturn '';\n\t}\n}\n\n/**\n * Default logger instance\n */\nexport const logger = new Logger('Martini');\n", "/**\n * PlayerManager - Unified player lifecycle management\n *\n * Prevents bugs by ensuring both initial players (in setup) and\n * late-joining players use the same factory logic.\n *\n * @example\n * ```ts\n * const playerManager = createPlayerManager({\n *   roles: ['fire', 'ice'],\n *   factory: (playerId, index) => ({\n *     x: index === 0 ? 200 : 600,\n *     y: 400,\n *     role: index === 0 ? 'fire' : 'ice',\n *   })\n * });\n *\n * export const game = defineGame({\n *   setup: ({ playerIds }) => ({\n *     players: playerManager.initialize(playerIds),\n *     inputs: {}\n *   }),\n *\n *   onPlayerJoin: (state, playerId) => {\n *     playerManager.handleJoin(state.players, playerId);\n *   },\n *\n *   onPlayerLeave: (state, playerId) => {\n *     playerManager.handleLeave(state.players, playerId);\n *   }\n * });\n * ```\n */\n\nimport type { GameDefinition, SetupContext } from './defineGame.js';\n\nexport interface PlayerFactory<TPlayer = any> {\n  /**\n   * Creates a player's initial state\n   *\n   * @param playerId - Unique player identifier\n   * @param index - Player index (0 for first player, 1 for second, etc.)\n   * @returns Player state object\n   */\n  (playerId: string, index: number): TPlayer;\n}\n\nexport interface PlayerManagerConfig<TPlayer = any> {\n  /**\n   * Factory function to create player state\n   */\n  factory: PlayerFactory<TPlayer>;\n\n  /**\n   * Optional: Role names for type-safe role assignment\n   * If provided, ensures roles are assigned in order\n   */\n  roles?: readonly string[];\n\n  /**\n   * Optional: Spawn points for each player index\n   * If provided, automatically sets x/y coordinates\n   */\n  spawnPoints?: Array<{ x: number; y: number; [key: string]: any }>;\n}\n\nexport interface PlayerManager<TPlayer = any> {\n  /**\n   * Initialize all players for setup()\n   *\n   * @param playerIds - Array of player IDs from setup context\n   * @returns Record of player ID to player state\n   */\n  initialize(playerIds: string[]): Record<string, TPlayer>;\n\n  /**\n   * Handle a player joining mid-game\n   *\n   * @param players - Current players record from state\n   * @param playerId - ID of joining player\n   */\n  handleJoin(players: Record<string, TPlayer>, playerId: string): void;\n\n  /**\n   * Handle a player leaving\n   *\n   * @param players - Current players record from state\n   * @param playerId - ID of leaving player\n   */\n  handleLeave(players: Record<string, TPlayer>, playerId: string): void;\n\n  /**\n   * Get the configuration for a specific player index\n   * Useful for determining roles, spawn points, etc.\n   *\n   * @param index - Player index\n   */\n  getConfig(index: number): { role?: string; spawn?: { x: number; y: number } };\n\n  /**\n   * Create game definition handlers (setup, onPlayerJoin, onPlayerLeave)\n   *\n   * @returns Partial game definition with lifecycle handlers\n   *\n   * @example\n   * ```ts\n   * export const game = defineGame({\n   *   ...playerManager.createHandlers(),\n   *   actions: { ... }\n   * });\n   * ```\n   */\n  createHandlers<TState extends { players: Record<string, TPlayer> }>(): Pick<\n    GameDefinition<TState>,\n    'setup' | 'onPlayerJoin' | 'onPlayerLeave'\n  >;\n}\n\n/**\n * Create a PlayerManager instance\n *\n * @param config - Configuration for player management\n * @returns PlayerManager instance\n */\nexport function createPlayerManager<TPlayer = any>(\n  config: PlayerManagerConfig<TPlayer>\n): PlayerManager<TPlayer> {\n  const { factory, roles, spawnPoints } = config;\n\n  // Track current player count for role/spawn assignment\n  let playerCount = 0;\n\n  const createPlayer = (playerId: string, index: number): TPlayer => {\n    let player = factory(playerId, index);\n\n    // Auto-assign spawn point if provided\n    if (spawnPoints && spawnPoints[index]) {\n      player = { ...player, ...spawnPoints[index] };\n    }\n\n    // Auto-assign role if roles are defined\n    if (roles && roles[index]) {\n      player = { ...player, role: roles[index] } as TPlayer;\n    }\n\n    return player;\n  };\n\n  return {\n    initialize(playerIds: string[]): Record<string, TPlayer> {\n      playerCount = playerIds.length;\n      return Object.fromEntries(\n        playerIds.map((id, index) => [id, createPlayer(id, index)])\n      );\n    },\n\n    handleJoin(players: Record<string, TPlayer>, playerId: string): void {\n      const currentCount = Object.keys(players).length;\n      players[playerId] = createPlayer(playerId, currentCount);\n      playerCount = currentCount + 1;\n    },\n\n    handleLeave(players: Record<string, TPlayer>, playerId: string): void {\n      delete players[playerId];\n      playerCount = Object.keys(players).length;\n    },\n\n    getConfig(index: number) {\n      return {\n        role: roles?.[index],\n        spawn: spawnPoints?.[index]\n      };\n    },\n\n    createHandlers<TState extends { players: Record<string, TPlayer> }>() {\n      const manager = this;\n      return {\n        setup: ({ playerIds }: SetupContext) => {\n          return {\n            players: manager.initialize(playerIds)\n          } as TState;\n        },\n\n        onPlayerJoin: (state: TState, playerId: string) => {\n          manager.handleJoin(state.players, playerId);\n        },\n\n        onPlayerLeave: (state: TState, playerId: string) => {\n          manager.handleLeave(state.players, playerId);\n        }\n      };\n    }\n  };\n}\n", "/**\n * SDK Helper Functions\n *\n * Utilities to reduce boilerplate and prevent common mistakes\n */\n\nimport type { ActionDefinition, ActionContext } from './defineGame.js';\n\n/**\n * Create a players record from player IDs\n *\n * Type-safe helper that ensures all players are initialized.\n *\n * @param playerIds - Array of player IDs\n * @param factory - Function to create each player's state\n * @returns Record mapping player IDs to player state\n *\n * @example\n * ```ts\n * setup: ({ playerIds }) => ({\n *   players: createPlayers(playerIds, (id, index) => ({\n *     x: index * 100,\n *     y: 400,\n *     score: 0\n *   }))\n * })\n * ```\n */\nexport function createPlayers<TPlayer>(\n  playerIds: string[],\n  factory: (playerId: string, index: number) => TPlayer\n): Record<string, TPlayer> {\n  return Object.fromEntries(playerIds.map((id, index) => [id, factory(id, index)]));\n}\n\n/**\n * Create a standard input action\n *\n * Returns an action definition that stores input in state[stateKey][context.targetId]\n *\n * @param stateKey - Key in state where inputs are stored (default: 'inputs')\n * @param options - Optional validation and callbacks\n * @returns Action definition\n *\n * @example\n * ```ts\n * actions: {\n *   move: createInputAction('inputs'),\n *\n *   shoot: createInputAction('inputs', {\n *     validate: (input) => input.angle !== undefined,\n *     onApply: (state, context, input) => {\n *       state.players[context.targetId].lastShot = Date.now();\n *     }\n *   })\n * }\n * ```\n */\nexport function createInputAction<TState = any, TInput = any>(\n  stateKey: string = 'inputs',\n  options?: {\n    /**\n     * Validate input before storing\n     * Return false to reject the input\n     */\n    validate?: (input: TInput) => boolean;\n\n    /**\n     * Called after input is stored\n     * Use for side effects or additional state updates\n     */\n    onApply?: (state: TState, context: ActionContext, input: TInput) => void;\n  }\n): ActionDefinition<TState, TInput> {\n  return {\n    apply: (state: TState, context: ActionContext, input: TInput) => {\n      // Validate input if validator provided\n      if (options?.validate && !options.validate(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`[${stateKey}] Invalid input rejected:`, input);\n        }\n        return;\n      }\n\n      // Initialize inputs object if needed\n      if (!(state as any)[stateKey]) {\n        (state as any)[stateKey] = {};\n      }\n\n      // Store input using targetId (NOT playerId!)\n      (state as any)[stateKey][context.targetId] = input;\n\n      // Call optional callback\n      options?.onApply?.(state, context, input);\n    }\n  };\n}\n\n/**\n * Create a host-only tick action\n *\n * Wraps game loop logic to only run on the host.\n * Useful for physics, AI, collision detection, etc.\n *\n * @param tickFn - Function to run each tick (host only)\n * @returns Action definition that only runs on host\n *\n * @example\n * ```ts\n * actions: {\n *   tick: createTickAction((state, delta, context) => {\n *     // This only runs on the host\n *     updatePhysics(state, delta);\n *     checkCollisions(state);\n *   })\n * }\n * ```\n */\nexport function createTickAction<TState = any, TInput = { delta: number }>(\n  tickFn: (state: TState, delta: number, context: ActionContext) => void\n): ActionDefinition<TState, TInput> {\n  return {\n    apply: (state: TState, context: ActionContext, input: TInput) => {\n      // Only run on host\n      if (!context.isHost) return;\n\n      const delta = (input as any).delta || 0;\n      tickFn(state, delta, context);\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
