# Phase 1: SDK Foundation

**Duration**: 3 days
**Goal**: Make Martini SDK available in web app and create TypeScript project templates

---

## Overview

This phase establishes the foundation by:
1. Making the Martini browser bundle available in the web app
2. Creating TypeScript-only project templates
3. Updating the bundle API to compile TypeScript
4. Wiring Martini SDK into the sandbox runtime

---

## Tasks

### Task 1.1: Copy Browser Bundle (30 min)

**Objective**: Make `martini-multiplayer.browser.js` available to sandbox runtime

#### Step 1: Add postbuild script
```json
// packages/@martini/phaser/package.json
{
  "scripts": {
    "build": "tsc && pnpm build:browser",
    "build:browser": "esbuild browser.ts --bundle --format=iife --global-name=MartiniMultiplayer --outfile=dist/martini-multiplayer.browser.js",
    "postbuild": "cp dist/martini-multiplayer.browser.js ../../apps/web/static/"
  }
}
```

#### Step 2: Rebuild and verify
```bash
cd packages/@martini/phaser
pnpm build
ls -la ../../apps/web/static/martini-multiplayer.browser.js # Should exist
```

#### Step 3: Load in sandbox runtime
```html
<!-- apps/web/static/sandbox-runtime.html -->
<head>
  <!-- ... existing CSP ... -->
</head>
<body>
  <div id="game"></div>

  <!-- Load dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="/martini-multiplayer.browser.js"></script>

  <!-- Runtime script below -->
</body>
```

**Validation**: Open browser console, type `MartiniMultiplayer` → should see object with `defineGame`, `GameRuntime`, etc.

---

### Task 1.2: Create TypeScript Templates (2 hours)

**Objective**: Provide starter templates for new TypeScript projects

#### Step 1: Create template file
```typescript
// apps/web/src/lib/server/templates/martini-typescript-starter.ts

export const martiniTypeScriptStarter = [
  {
    path: '/src/game.ts',
    content: `/**
 * Game Logic - Pure state management
 *
 * This file defines your game rules and state using Martini SDK.
 * No Phaser code here - just pure TypeScript!
 */

import { defineGame } from '@martini/phaser';

export const myGame = defineGame({
  // Initial state setup
  setup: ({ playerIds }) => ({
    players: Object.fromEntries(
      playerIds.map((id, index) => [
        id,
        {
          x: 200 + index * 400,
          y: 300,
          score: 0,
          velocity: { x: 0, y: 0 }
        }
      ])
    ),
    // Store player inputs (updated every frame)
    inputs: {} as Record<string, { left: boolean; right: boolean; up: boolean }>
  }),

  // Actions - How state changes
  actions: {
    // Update player input
    input: {
      apply: (state, context, input) => {
        state.inputs[context.targetId] = input;
      }
    },

    // Increment score
    addScore: {
      apply: (state, context, points: number) => {
        const player = state.players[context.targetId];
        if (player) {
          player.score += points;
        }
      }
    }
  },

  // Player join/leave handlers
  onPlayerJoin: (state, playerId) => {
    const existingCount = Object.keys(state.players).length;
    state.players[playerId] = {
      x: 200 + existingCount * 400,
      y: 300,
      score: 0,
      velocity: { x: 0, y: 0 }
    };
  },

  onPlayerLeave: (state, playerId) => {
    delete state.players[playerId];
    delete state.inputs[playerId];
  }
});
`
  },
  {
    path: '/src/scene.ts',
    content: `/**
 * Phaser Scene - Rendering and input
 *
 * This file handles all Phaser-specific rendering logic.
 * It reads from game state and submits actions.
 */

import Phaser from 'phaser';
import { PhaserAdapter } from '@martini/phaser';
import type { GameRuntime } from '@martini/phaser';

export function createGameScene(runtime: GameRuntime) {
  return class GameScene extends Phaser.Scene {
    adapter!: PhaserAdapter;
    sprites: Map<string, Phaser.GameObjects.Sprite> = new Map();

    create() {
      // Initialize Phaser adapter
      this.adapter = new PhaserAdapter(runtime, this);

      // Background
      this.add.rectangle(400, 300, 800, 600, 0x87ceeb);

      // Platform
      const platform = this.add.rectangle(400, 550, 600, 20, 0x8b4513);
      this.physics.add.existing(platform, true);

      // UI
      this.add.text(10, 10, 'Use Arrow Keys to Move', {
        fontSize: '16px',
        color: '#000000'
      });

      // Listen for state changes to create/update sprites
      this.adapter.onChange((state) => {
        for (const [playerId, player] of Object.entries(state.players)) {
          if (!this.sprites.has(playerId)) {
            // Create sprite
            const color = playerId === this.adapter.myId ? 0x00ff00 : 0xff0000;
            const sprite = this.add.circle(player.x, player.y, 20, color);
            this.physics.add.existing(sprite);
            (sprite.body as Phaser.Physics.Arcade.Body).setCollideWorldBounds(true);
            this.physics.add.collider(sprite, platform);

            this.sprites.set(playerId, sprite);

            // Track my sprite for auto-sync
            if (playerId === this.adapter.myId) {
              this.adapter.trackSprite(sprite, \`player-\${playerId}\`);
            } else {
              // Register remote sprite for interpolation
              this.adapter.registerRemoteSprite(\`player-\${playerId}\`, sprite);
            }
          }
        }
      });
    }

    update() {
      // Smooth interpolation for remote players
      this.adapter.updateInterpolation();

      // Input handling
      const cursors = this.input.keyboard!.createCursorKeys();
      const mySprite = this.sprites.get(this.adapter.myId);

      if (mySprite) {
        // Apply physics
        const body = mySprite.body as Phaser.Physics.Arcade.Body;
        body.setVelocityX(0);

        if (cursors.left.isDown) {
          body.setVelocityX(-200);
        } else if (cursors.right.isDown) {
          body.setVelocityX(200);
        }

        if (cursors.up.isDown && body.touching.down) {
          body.setVelocityY(-400);
        }

        // Send input state to other players
        this.adapter.submitAction('input', {
          left: cursors.left.isDown,
          right: cursors.right.isDown,
          up: cursors.up.isDown
        });
      }
    }
  };
}
`
  },
  {
    path: '/src/main.ts',
    content: `/**
 * Entry Point - Auto-wired by Martini
 *
 * This file is auto-generated and should rarely need editing.
 * It wires up the runtime, transport, and Phaser game.
 */

import Phaser from 'phaser';
import { GameRuntime, TrysteroTransport } from '@martini/phaser';
import { myGame } from './game';
import { createGameScene } from './scene';

// Get multiplayer config from URL params
// (Auto-injected by sandbox runtime)
const roomId = (window as any).__ROOM_ID__ || 'default-room';
const isHost = (window as any).__IS_HOST__ || false;

// Create P2P transport
const transport = new TrysteroTransport({
  roomId,
  isHost,
  appId: 'martini-game',
  strategy: 'mqtt' // Use 'supabase' for production
});

// Create game runtime
const runtime = new GameRuntime(myGame, transport, { isHost });

// Expose for HMR
if ((window as any).__HMR__) {
  (window as any).__HMR__.runtime = runtime;
}

// Create Phaser game
const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  parent: 'game',
  backgroundColor: '#87ceeb',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { x: 0, y: 400 },
      debug: false
    }
  },
  scene: createGameScene(runtime)
});

// Notify parent that game is ready
if (window.parent !== window) {
  window.parent.postMessage({ type: 'READY' }, '*');
}
`
  },
  {
    path: '/tsconfig.json',
    content: `{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "types": ["phaser"]
  },
  "include": ["src/**/*"]
}
`
  }
];
```

#### Step 2: Update project creation API
```typescript
// apps/web/src/routes/api/projects/+server.ts

import { martiniTypeScriptStarter } from '$lib/server/templates/martini-typescript-starter';

export const POST: RequestHandler = async ({ request, locals }) => {
  // ... existing auth checks ...

  const { name, template } = await request.json();

  // Default to TypeScript template
  const files = template === 'martini-typescript'
    ? martiniTypeScriptStarter
    : martiniTypeScriptStarter; // Always TypeScript now!

  // ... rest of project creation logic ...
};
```

**Validation**: Create new project → should have 4 files (game.ts, scene.ts, main.ts, tsconfig.json)

---

### Task 1.3: Update Bundle API for TypeScript (2 hours)

**Objective**: Compile TypeScript files to JavaScript in bundle API

#### Step 1: Update bundle endpoint
```typescript
// apps/web/src/routes/api/projects/[id]/bundle/+server.ts

import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { db } from '$lib/server/db';
import { files } from '$lib/server/db/schema';
import { eq } from 'drizzle-orm';
import * as esbuild from 'esbuild';

export const POST: RequestHandler = async ({ params, locals }) => {
  const session = await locals.safeGetSession();
  if (!session) {
    throw error(401, 'Unauthorized');
  }

  const projectId = params.id;

  // Fetch all files
  const projectFiles = await db
    .select()
    .from(files)
    .where(eq(files.projectId, projectId));

  // Filter for TypeScript/JavaScript files in /src/
  const sourceFiles = projectFiles.filter(
    (f) => (f.path.endsWith('.ts') || f.path.endsWith('.js')) && f.path.startsWith('/src/')
  );

  if (sourceFiles.length === 0) {
    return json({ error: 'No source files found in /src/' }, { status: 400 });
  }

  // Find entry point
  const entryFile = sourceFiles.find((f) => f.path === '/src/main.ts');

  if (!entryFile) {
    return json({ error: 'Entry point /src/main.ts not found' }, { status: 400 });
  }

  try {
    // Create virtual file system for esbuild
    const fileMap = new Map<string, string>();
    sourceFiles.forEach((file) => {
      // Remove leading slash for esbuild
      const path = file.path.startsWith('/') ? file.path.slice(1) : file.path;
      fileMap.set(path, file.content);
    });

    // esbuild plugin to resolve virtual files
    const virtualPlugin: esbuild.Plugin = {
      name: 'virtual-files',
      setup(build) {
        // Resolve imports
        build.onResolve({ filter: /.*/ }, (args) => {
          // Handle relative imports
          if (args.path.startsWith('./') || args.path.startsWith('../')) {
            const importerDir = args.importer.split('/').slice(0, -1);
            const pathParts = args.path.split('/');
            const resolvedParts = [...importerDir];

            for (const part of pathParts) {
              if (part === '..') {
                resolvedParts.pop();
              } else if (part === '.') {
                continue;
              } else {
                resolvedParts.push(part);
              }
            }

            let resolved = resolvedParts.join('/');

            // Try .ts extension if no extension
            if (!resolved.endsWith('.ts') && !resolved.endsWith('.js')) {
              resolved += '.ts';
            }

            return { path: resolved, namespace: 'virtual' };
          }

          // Handle absolute imports (from /src/)
          const normalizedPath = args.path.startsWith('/') ? args.path.slice(1) : args.path;
          return { path: normalizedPath, namespace: 'virtual' };
        });

        // Load file contents
        build.onLoad({ filter: /.*/, namespace: 'virtual' }, (args) => {
          const content = fileMap.get(args.path);

          if (!content) {
            return {
              errors: [{ text: `File not found: ${args.path}` }]
            };
          }

          return {
            contents: content,
            loader: args.path.endsWith('.ts') ? 'ts' : 'js'
          };
        });
      }
    };

    // Bundle with esbuild (supports TypeScript out of the box!)
    const result = await esbuild.build({
      stdin: {
        contents: entryFile.content,
        sourcefile: 'src/main.ts',
        loader: 'ts'
      },
      bundle: true,
      format: 'iife',
      platform: 'browser',
      target: 'es2020',
      write: false,
      plugins: [virtualPlugin],
      minify: false,
      sourcemap: 'inline', // Enable source maps for error mapping
      external: ['phaser', '@martini/phaser', '@martini/core'], // Externals loaded via CDN
      globalName: '__UserCode__'
    });

    const bundledCode = result.outputFiles[0].text;

    return json({
      success: true,
      code: bundledCode
    });
  } catch (err) {
    console.error('Bundling error:', err);

    return json(
      {
        error: 'Failed to bundle code',
        details: err instanceof Error ? err.message : String(err)
      },
      { status: 500 }
    );
  }
};
```

**Validation**: Save TypeScript file → click "Run" → should compile without errors

---

### Task 1.4: Wire Martini SDK in Sandbox Runtime (3 hours)

**Objective**: Execute bundled user code with Martini SDK in isolated iframe

#### Step 1: Update sandbox runtime
```html
<!-- apps/web/static/sandbox-runtime.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!-- Content Security Policy -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'none';
    script-src 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
    style-src 'unsafe-inline';
    img-src 'self' data: blob: https://*.supabase.co;
    media-src 'self' data: blob: https://*.supabase.co;
    connect-src https://*.supabase.co wss://*.supabase.co https://mqtt.trystero.cloud;
    worker-src blob:;
  ">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    #game {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <div id="game"></div>

  <!-- Load dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="/martini-multiplayer.browser.js"></script>

  <!-- Sandbox Runtime -->
  <script>
    /**
     * Martini SDK Runtime
     *
     * Executes user TypeScript (compiled to JS) in sandbox.
     * Provides isolation, HMR, and automatic Martini SDK wiring.
     */

    let currentGame = null;
    let currentRuntime = null;

    // HMR support - exposed globally
    window.__HMR__ = {
      runtime: null,
      savedState: null
    };

    // Security: Block dangerous APIs (defense in depth)
    delete window.localStorage;
    delete window.sessionStorage;
    delete window.indexedDB;
    delete window.open;

    // Allow fetch ONLY for multiplayer services
    const originalFetch = window.fetch;
    window.fetch = (url, ...args) => {
      const urlStr = url.toString();
      if (
        urlStr.includes('supabase.co') ||
        urlStr.includes('trystero.cloud') ||
        urlStr.includes('mqtt')
      ) {
        return originalFetch(url, ...args);
      }
      throw new Error('fetch() blocked by sandbox - only multiplayer services allowed');
    };

    // Watchdog - prevent infinite loops
    setInterval(() => {
      parent.postMessage({ type: 'HEARTBEAT' }, '*');
    }, 1000);

    /**
     * Load and execute user code
     */
    async function loadUserCode(code, roomId, isHost) {
      try {
        console.log('[Sandbox] Loading user code...');

        // Save state if HMR
        if (window.__HMR__.runtime) {
          window.__HMR__.savedState = window.__HMR__.runtime.getState();
          console.log('[Sandbox] HMR: State saved');
        }

        // Destroy existing game
        if (currentGame) {
          currentGame.destroy(true);
          currentGame = null;
          console.log('[Sandbox] Previous game destroyed');
        }

        // Inject multiplayer config as globals
        window.__ROOM_ID__ = roomId;
        window.__IS_HOST__ = isHost;

        // Execute user code (IIFE bundle)
        // User code exports are captured in __UserCode__ global
        eval(code);

        console.log('[Sandbox] User code executed successfully');

        // HMR: Restore state
        if (window.__HMR__.savedState && window.__HMR__.runtime) {
          console.log('[Sandbox] HMR: Restoring state...');
          window.__HMR__.runtime.mutateState((state) => {
            Object.assign(state, window.__HMR__.savedState);
          });
          window.__HMR__.savedState = null;
        }

        // Notify parent
        parent.postMessage({ type: 'READY' }, '*');

      } catch (error) {
        console.error('[Sandbox] Error loading user code:', error);
        reportError(error);
      }
    }

    /**
     * Error reporting
     */
    function reportError(error) {
      parent.postMessage({
        type: 'ERROR',
        payload: {
          message: error.message,
          stack: error.stack,
          line: error.lineNumber,
          column: error.columnNumber
        }
      }, '*');
    }

    // Global error handlers
    window.addEventListener('error', (event) => {
      reportError(event.error || { message: event.message });
      event.preventDefault();
    });

    window.addEventListener('unhandledrejection', (event) => {
      reportError(event.reason || { message: 'Unhandled promise rejection' });
      event.preventDefault();
    });

    /**
     * Message handling from parent
     */
    window.addEventListener('message', (event) => {
      if (!event.data || !event.data.type) return;

      const { type, payload } = event.data;

      switch (type) {
        case 'LOAD_CODE':
          const { code, roomId = 'default-room', isHost = false } = payload;
          loadUserCode(code, roomId, isHost);
          break;

        case 'CAPTURE_SCREENSHOT':
          const canvas = document.querySelector('canvas');
          if (canvas) {
            try {
              const dataUrl = canvas.toDataURL('image/png');
              parent.postMessage({
                type: 'SCREENSHOT_CAPTURED',
                payload: {
                  image: dataUrl,
                  width: canvas.width,
                  height: canvas.height,
                  timestamp: Date.now()
                }
              }, '*');
            } catch (error) {
              parent.postMessage({
                type: 'SCREENSHOT_ERROR',
                payload: { error: error.message }
              }, '*');
            }
          } else {
            parent.postMessage({
              type: 'SCREENSHOT_ERROR',
              payload: { error: 'Canvas not found - game may not be loaded' }
            }, '*');
          }
          break;
      }
    });

    console.log('[Sandbox] Runtime initialized, waiting for user code...');
  </script>
</body>
</html>
```

**Validation**:
1. Create TypeScript project
2. Click "Run Game"
3. Open browser console → should see Phaser game rendering
4. Check iframe console → should see Martini SDK logs

---

## Testing Checklist

- [ ] Browser bundle exists at `/static/martini-multiplayer.browser.js`
- [ ] New project creates 4 TypeScript files
- [ ] Bundle API compiles `.ts` to `.js` successfully
- [ ] Sandbox loads and executes bundled code
- [ ] `MartiniMultiplayer` global is accessible in sandbox
- [ ] Phaser game renders in iframe
- [ ] No console errors in parent or iframe
- [ ] Multiplayer transport initializes (check network tab)

---

## Common Issues

### Issue: esbuild can't find files
**Solution**: Check virtual file system paths (remove leading `/`)

### Issue: "defineGame is not defined"
**Solution**: Verify browser bundle is loaded before user code

### Issue: CSP blocks scripts
**Solution**: Update CSP header to allow `'unsafe-eval'` for esbuild bundles

### Issue: Import statements fail
**Solution**: Ensure esbuild `format: 'iife'` and externals are configured

---

## Next Steps

Proceed to [Phase 2: Editor Experience](3.editor-experience.md)
