# Phase 3: Hot Module Replacement

**Duration**: 2 days
**Goal**: Preserve game state across code reloads for instant feedback

---

## Overview

True HMR allows developers to change code and see updates instantly without losing:
- Player positions
- Scores and game state
- Sprite configurations
- Connection state (multiplayer)

This dramatically improves developer experience by eliminating the "edit â†’ save â†’ reload â†’ click through menus â†’ test" cycle.

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Parent Window (Editor)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  User saves file â†’ Bundle API â†’ Send to iframe         â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼ postMessage({ type: 'LOAD_CODE' })
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Sandbox Iframe                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. Save current state                                 â”‚
â”‚     - runtime.getState() â†’ { players, sprites, ... }   â”‚
â”‚     - Phaser sprite positions                          â”‚
â”‚                                                         â”‚
â”‚  2. Destroy Phaser game                                â”‚
â”‚     - game.destroy(true)                               â”‚
â”‚                                                         â”‚
â”‚  3. Execute new code                                   â”‚
â”‚     - eval(newCode)                                    â”‚
â”‚     - Recreate runtime + transport                     â”‚
â”‚                                                         â”‚
â”‚  4. Restore state                                      â”‚
â”‚     - runtime.mutateState(savedState)                  â”‚
â”‚     - Recreate sprites at saved positions              â”‚
â”‚                                                         â”‚
â”‚  5. Notify parent: READY                               â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Tasks

### Task 3.1: State Serialization API (3 hours)

**Objective**: Extract and restore game state reliably

#### Step 1: Define serializable state shape
```typescript
// In sandbox-runtime.html

interface SerializableState {
  // Core game state from runtime
  gameState: any; // From runtime.getState()

  // Phaser-specific state (not in Martini state)
  sprites: Array<{
    key: string;
    x: number;
    y: number;
    texture: string;
    velocityX?: number;
    velocityY?: number;
  }>;

  // Multiplayer state
  transport: {
    roomId: string;
    isHost: boolean;
    connectedPeers: string[];
  };

  // Timestamp for debugging
  capturedAt: number;
}
```

#### Step 2: Implement state capture
```typescript
// In sandbox-runtime.html

/**
 * Capture current game state for HMR
 */
function captureState(): SerializableState | null {
  if (!window.__HMR__.runtime) {
    return null;
  }

  const runtime = window.__HMR__.runtime;
  const adapter = window.__HMR__.adapter;

  // Capture core state from runtime
  const gameState = JSON.parse(JSON.stringify(runtime.getState()));

  // Capture sprite states
  const sprites: any[] = [];
  if (adapter && adapter.trackedSprites) {
    for (const [key, { sprite }] of adapter.trackedSprites.entries()) {
      sprites.push({
        key,
        x: sprite.x,
        y: sprite.y,
        texture: sprite.texture?.key || 'default',
        velocityX: sprite.body?.velocity?.x,
        velocityY: sprite.body?.velocity?.y,
        scaleX: sprite.scaleX,
        scaleY: sprite.scaleY,
        rotation: sprite.rotation,
        alpha: sprite.alpha
      });
    }
  }

  // Capture transport state
  const transport = runtime.getTransport();
  const transportState = {
    roomId: window.__ROOM_ID__ || 'default',
    isHost: window.__IS_HOST__ || false,
    connectedPeers: transport.getPeerIds ? transport.getPeerIds() : []
  };

  return {
    gameState,
    sprites,
    transport: transportState,
    capturedAt: Date.now()
  };
}
```

#### Step 3: Implement state restoration
```typescript
/**
 * Restore game state after HMR
 */
function restoreState(savedState: SerializableState) {
  if (!window.__HMR__.runtime || !savedState) {
    return;
  }

  console.log('[HMR] Restoring state from', new Date(savedState.capturedAt));

  const runtime = window.__HMR__.runtime;

  // Restore core game state
  runtime.mutateState((state: any) => {
    Object.assign(state, savedState.gameState);
  });

  // Restore sprites (handled by scene's onChange listener)
  // The PhaserAdapter will automatically recreate sprites from state

  console.log('[HMR] State restored successfully');
}
```

---

### Task 3.2: HMR Protocol Implementation (4 hours)

**Objective**: Reload code without losing state

#### Step 1: Update sandbox runtime with HMR logic
```typescript
// In apps/web/static/sandbox-runtime.html

let currentGame = null;
let isFirstLoad = true;

// HMR globals
window.__HMR__ = {
  runtime: null,
  adapter: null,
  savedState: null
};

/**
 * Load user code with HMR support
 */
async function loadUserCode(code, roomId, isHost) {
  try {
    console.log('[HMR] Loading code...', { isFirstLoad });

    // STEP 1: Capture state (skip on first load)
    if (!isFirstLoad && window.__HMR__.runtime) {
      console.log('[HMR] Capturing current state...');
      window.__HMR__.savedState = captureState();
      console.log('[HMR] State captured:', window.__HMR__.savedState);
    }

    // STEP 2: Destroy existing game
    if (currentGame) {
      console.log('[HMR] Destroying previous game...');
      currentGame.destroy(true);
      currentGame = null;

      // Small delay to ensure cleanup
      await new Promise((resolve) => setTimeout(resolve, 100));
    }

    // STEP 3: Clear old references
    window.__HMR__.runtime = null;
    window.__HMR__.adapter = null;

    // STEP 4: Inject multiplayer config
    window.__ROOM_ID__ = roomId;
    window.__IS_HOST__ = isHost;

    // STEP 5: Execute new user code
    console.log('[HMR] Executing new code...');
    eval(code);

    // Wait for game to initialize
    await new Promise((resolve) => setTimeout(resolve, 200));

    // STEP 6: Restore state (skip on first load)
    if (!isFirstLoad && window.__HMR__.savedState) {
      console.log('[HMR] Restoring state...');
      restoreState(window.__HMR__.savedState);
      window.__HMR__.savedState = null;
    }

    isFirstLoad = false;

    // STEP 7: Notify parent
    parent.postMessage({ type: 'READY' }, '*');
    console.log('[HMR] Reload complete');

  } catch (error) {
    console.error('[HMR] Error during reload:', error);
    reportError(error);
  }
}
```

#### Step 2: Update user template to expose runtime/adapter
```typescript
// Update apps/web/src/lib/server/templates/martini-typescript-starter.ts
// In /src/main.ts template:

export const martiniTypeScriptStarter = [
  // ... game.ts, scene.ts unchanged ...
  {
    path: '/src/main.ts',
    content: `/**
 * Entry Point - Auto-wired by Martini
 */

import Phaser from 'phaser';
import { GameRuntime, TrysteroTransport } from '@martini/phaser';
import { myGame } from './game';
import { createGameScene } from './scene';

// Get multiplayer config from URL params
const roomId = (window as any).__ROOM_ID__ || 'default-room';
const isHost = (window as any).__IS_HOST__ || false;

// Create P2P transport
const transport = new TrysteroTransport({
  roomId,
  isHost,
  appId: 'martini-game',
  strategy: 'mqtt'
});

// Create game runtime
const runtime = new GameRuntime(myGame, transport, { isHost });

// Expose for HMR (CRITICAL!)
if ((window as any).__HMR__) {
  (window as any).__HMR__.runtime = runtime;
}

// Create Phaser game
const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  parent: 'game',
  backgroundColor: '#87ceeb',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { x: 0, y: 400 },
      debug: false
    }
  },
  scene: createGameScene(runtime)
});

// Notify parent that game is ready
if (window.parent !== window) {
  window.parent.postMessage({ type: 'READY' }, '*');
}
`
  },
  {
    path: '/src/scene.ts',
    content: `/**
 * Phaser Scene - Rendering and input
 */

import Phaser from 'phaser';
import { PhaserAdapter } from '@martini/phaser';
import type { GameRuntime } from '@martini/phaser';

export function createGameScene(runtime: GameRuntime) {
  return class GameScene extends Phaser.Scene {
    adapter!: PhaserAdapter;
    sprites: Map<string, Phaser.GameObjects.Sprite> = new Map();

    create() {
      // Initialize Phaser adapter
      this.adapter = new PhaserAdapter(runtime, this);

      // Expose for HMR (CRITICAL!)
      if ((window as any).__HMR__) {
        (window as any).__HMR__.adapter = this.adapter;
      }

      // Background
      this.add.rectangle(400, 300, 800, 600, 0x87ceeb);

      // Platform
      const platform = this.add.rectangle(400, 550, 600, 20, 0x8b4513);
      this.physics.add.existing(platform, true);

      // UI
      this.add.text(10, 10, 'Use Arrow Keys to Move', {
        fontSize: '16px',
        color: '#000000'
      });

      // Listen for state changes to create/update sprites
      this.adapter.onChange((state) => {
        for (const [playerId, player] of Object.entries(state.players)) {
          if (!this.sprites.has(playerId)) {
            // Create sprite
            const color = playerId === this.adapter.myId ? 0x00ff00 : 0xff0000;
            const sprite = this.add.circle(player.x, player.y, 20, color);
            this.physics.add.existing(sprite);
            (sprite.body as Phaser.Physics.Arcade.Body).setCollideWorldBounds(true);
            this.physics.add.collider(sprite, platform);

            this.sprites.set(playerId, sprite);

            // Track my sprite for auto-sync
            if (playerId === this.adapter.myId) {
              this.adapter.trackSprite(sprite, \`player-\${playerId}\`);
            } else {
              this.adapter.registerRemoteSprite(\`player-\${playerId}\`, sprite);
            }
          }
        }
      });
    }

    update() {
      // Smooth interpolation for remote players
      this.adapter.updateInterpolation();

      // Input handling
      const cursors = this.input.keyboard!.createCursorKeys();
      const mySprite = this.sprites.get(this.adapter.myId);

      if (mySprite) {
        // Apply physics
        const body = mySprite.body as Phaser.Physics.Arcade.Body;
        body.setVelocityX(0);

        if (cursors.left.isDown) {
          body.setVelocityX(-200);
        } else if (cursors.right.isDown) {
          body.setVelocityX(200);
        }

        if (cursors.up.isDown && body.touching.down) {
          body.setVelocityY(-400);
        }

        // Send input state to other players
        this.adapter.submitAction('input', {
          left: cursors.left.isDown,
          right: cursors.right.isDown,
          up: cursors.up.isDown
        });
      }
    }
  };
}
`
  }
];
```

---

### Task 3.3: Auto-Reload on Save (2 hours)

**Objective**: Trigger HMR automatically when user saves file

#### Step 1: Update GamePreview component
```svelte
<!-- apps/web/src/routes/editor/[projectId]/GamePreview.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';

  let {
    projectId,
    onRunGame,
    hotReloadEnabled = $bindable(true),
    iframeEl = $bindable()
  } = $props<{
    projectId: string;
    onRunGame: () => Promise<void>;
    hotReloadEnabled?: boolean;
    iframeEl?: HTMLIFrameElement | null;
  }>();

  let gameError = $state<{ message: string; stack?: string } | null>(null);
  let isReady = $state(false);
  let isLoading = $state(false);

  async function runGame() {
    console.log('ğŸ® [HMR] Triggering reload...');
    isLoading = true;
    gameError = null;

    try {
      // Fetch bundled code
      const codeResponse = await fetch(`/api/projects/${projectId}/bundle`, {
        method: 'POST'
      });

      if (!codeResponse.ok) {
        const error = await codeResponse.json();
        throw new Error(error.details || error.error || 'Failed to bundle code');
      }

      const { code } = await codeResponse.json();

      // Send to iframe
      if (iframeEl?.contentWindow) {
        iframeEl.contentWindow.postMessage(
          {
            type: 'LOAD_CODE',
            payload: {
              code,
              roomId: 'dev-room-' + Math.random().toString(36).slice(2),
              isHost: true
            }
          },
          '*'
        );
      }

      await onRunGame();

    } catch (error) {
      gameError = {
        message: error instanceof Error ? error.message : String(error)
      };
      isLoading = false;
    }
  }

  // Listen for READY message from iframe
  onMount(() => {
    const handleMessage = (event: MessageEvent) => {
      if (!event.data || !event.data.type) return;

      const { type, payload } = event.data;

      switch (type) {
        case 'READY':
          console.log('âœ… [HMR] Game ready');
          isReady = true;
          isLoading = false;
          gameError = null;
          break;

        case 'ERROR':
          gameError = payload;
          isLoading = false;
          break;
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  });

  // Expose runGame for parent
  export { runGame };
</script>

<div class="h-full flex flex-col">
  <!-- HMR Toggle -->
  <div class="flex items-center gap-2 border-b px-4 py-2 bg-muted/30">
    <label class="flex items-center gap-2 text-sm">
      <input type="checkbox" bind:checked={hotReloadEnabled} />
      <span>Hot Reload</span>
    </label>

    {#if isLoading}
      <span class="text-xs text-muted-foreground">Reloading...</span>
    {:else if isReady}
      <span class="text-xs text-green-600">â— Ready</span>
    {/if}
  </div>

  <!-- Game iframe -->
  <div class="flex-1 relative">
    <iframe
      bind:this={iframeEl}
      src="/sandbox-runtime.html"
      class="w-full h-full border-0"
      title="Game Preview"
    />

    {#if gameError}
      <div class="absolute inset-0 bg-black/80 flex items-center justify-center p-8">
        <div class="bg-red-900 text-white p-6 rounded-lg max-w-2xl">
          <h3 class="font-bold text-lg mb-2">Error</h3>
          <p class="mb-4">{gameError.message}</p>
          {#if gameError.stack}
            <pre class="text-xs overflow-auto">{gameError.stack}</pre>
          {/if}
        </div>
      </div>
    {/if}
  </div>
</div>
```

#### Step 2: Trigger reload on save
```svelte
<!-- In apps/web/src/routes/editor/[projectId]/+page.svelte -->
<script lang="ts">
  let hotReloadEnabled = $state(true);
  let gamePreview: any;

  async function saveFile(path: string) {
    const file = filesMap[path];
    if (!file?.dirty) return;

    saveStatus = 'saving';

    try {
      const response = await fetch(`/api/projects/${data.project.id}/files`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path, content: file.content })
      });

      if (!response.ok) {
        throw new Error('Failed to save file');
      }

      filesMap[path] = { ...file, dirty: false };
      saveStatus = 'saved';

      // Hot reload: auto-run game after save if enabled
      if (hotReloadEnabled && gamePreview) {
        console.log('ğŸ”¥ Hot reload: triggering game reload after save');
        await gamePreview.runGame();
      }
    } catch (error) {
      console.error('Error saving file:', error);
      saveStatus = 'unsaved';
    }
  }
</script>
```

**Validation**:
1. Run game
2. Move player to specific position
3. Edit code (e.g., change background color)
4. Save file
5. Game should reload with background color changed BUT player stays in same position

---

## Testing Checklist

- [ ] First load: Game starts from initial state
- [ ] Edit code â†’ Save â†’ Game reloads with new code
- [ ] Player positions preserved across reload
- [ ] Scores preserved across reload
- [ ] Multiplayer connections stay active (if possible)
- [ ] Errors during reload show meaningful message
- [ ] HMR toggle works (can disable if needed)
- [ ] No memory leaks (check DevTools memory tab)
- [ ] Console shows HMR logs (capture/restore state)

---

## Limitations & Trade-offs

### What HMR CAN Preserve
âœ… Player positions (x, y)
âœ… Scores and simple state
âœ… Sprite properties (rotation, alpha, scale)

### What HMR CANNOT Preserve
âŒ Phaser physics state (velocity, acceleration) - too complex
âŒ Timers and tweens - need recreation
âŒ Audio state - will restart
âŒ Multiplayer connections - may need reconnect

### When to Force Full Reload
- Changing game definition (setup function)
- Adding/removing actions
- Changing multiplayer transport config
- Structural scene changes (new sprites)

---

## Performance Considerations

| Operation | Time |
|-----------|------|
| Capture state | <10ms |
| Destroy game | ~100ms |
| Execute new code | ~50ms |
| Restore state | <10ms |
| **Total HMR cycle** | **~200ms** |

Compare to full reload: ~2-3 seconds (destroy â†’ create transport â†’ reconnect â†’ load assets)

---

## Common Issues

### Issue: State not preserved
**Solution**: Check `window.__HMR__.runtime` is exposed in main.ts

### Issue: Sprites duplicate on reload
**Solution**: Clear `sprites` Map in scene.create()

### Issue: Multiplayer disconnects
**Solution**: Preserve transport state or mark as "requires reconnect"

### Issue: Physics behaves incorrectly
**Solution**: Don't preserve velocity, let physics system recalculate

---

## Next Steps

Proceed to [Phase 4: Polish & Documentation](5.polish-documentation.md)
