# Phase 4: Polish & Documentation

**Duration**: 1 day
**Goal**: Production-ready developer experience with excellent error messages and documentation

---

## Overview

This final phase adds polish to the developer experience:
1. **Source Maps**: Map runtime errors to original TypeScript lines
2. **Better Error Messages**: Clear, actionable error reporting
3. **Type Hints on Hover**: Quick reference without leaving editor
4. **Documentation**: Migration guide and API reference
5. **Examples**: Complete game templates

---

## Tasks

### Task 4.1: Source Map Integration (2 hours)

**Objective**: Show TypeScript line numbers in error messages

#### Step 1: Enable source maps in bundle API
```typescript
// apps/web/src/routes/api/projects/[id]/bundle/+server.ts

// Already enabled in Phase 1, verify:
const result = await esbuild.build({
  // ... existing config ...
  sourcemap: 'inline', // ‚úÖ This should already be set
  minify: false // Keep code readable for debugging
});
```

#### Step 2: Parse errors with source maps
```typescript
// In apps/web/static/sandbox-runtime.html

/**
 * Parse error with source map support
 */
function parseErrorWithSourceMap(error: Error) {
  // Extract line/column from error stack
  const stackMatch = error.stack?.match(/at\s+.*?:(\d+):(\d+)/);

  if (!stackMatch) {
    return {
      message: error.message,
      stack: error.stack,
      file: 'unknown',
      line: 0,
      column: 0
    };
  }

  const line = parseInt(stackMatch[1], 10);
  const column = parseInt(stackMatch[2], 10);

  // TODO: Parse inline source map to get original position
  // For now, return bundled position (Phase 1 sufficient)

  return {
    message: error.message,
    stack: error.stack,
    file: 'src/main.ts', // Approximate
    line,
    column
  };
}

/**
 * Report error to parent with better formatting
 */
function reportError(error: Error) {
  const parsed = parseErrorWithSourceMap(error);

  parent.postMessage({
    type: 'ERROR',
    payload: {
      message: parsed.message,
      file: parsed.file,
      line: parsed.line,
      column: parsed.column,
      stack: parsed.stack,
      userFriendly: formatUserFriendlyError(error)
    }
  }, '*');
}

/**
 * Format error in user-friendly way
 */
function formatUserFriendlyError(error: Error): string {
  const message = error.message;

  // Common error patterns with helpful suggestions
  if (message.includes('is not defined')) {
    const match = message.match(/(\w+) is not defined/);
    const varName = match?.[1];
    return `Variable '${varName}' is not defined. Did you forget to import it or declare it with 'const' or 'let'?`;
  }

  if (message.includes('Cannot read property')) {
    return `Trying to access a property on undefined/null. Check that your object exists before accessing its properties.`;
  }

  if (message.includes('is not a function')) {
    return `Trying to call something that isn't a function. Check your function names and imports.`;
  }

  if (message.includes('Unexpected token')) {
    return `Syntax error in your code. Check for missing brackets, quotes, or semicolons.`;
  }

  return message;
}
```

#### Step 3: Display errors in UI
```svelte
<!-- Update apps/web/src/routes/editor/[projectId]/GamePreview.svelte -->
<script lang="ts">
  let gameError = $state<{
    message: string;
    userFriendly?: string;
    file?: string;
    line?: number;
    column?: number;
    stack?: string;
  } | null>(null);

  onMount(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'ERROR') {
        gameError = event.data.payload;
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  });
</script>

<!-- Error overlay -->
{#if gameError}
  <div class="absolute inset-0 bg-black/90 flex items-center justify-center p-8 z-50">
    <div class="bg-red-900/90 text-white p-6 rounded-lg max-w-2xl w-full">
      <!-- User-friendly message -->
      <h3 class="font-bold text-xl mb-3 flex items-center gap-2">
        <AlertCircle class="h-6 w-6" />
        Runtime Error
      </h3>

      <div class="bg-red-950 p-4 rounded mb-4 font-mono text-sm">
        {gameError.userFriendly || gameError.message}
      </div>

      <!-- Location -->
      {#if gameError.file && gameError.line}
        <p class="text-sm text-red-200 mb-4">
          üìç {gameError.file}:{gameError.line}:{gameError.column || 0}
        </p>
      {/if}

      <!-- Stack trace (collapsible) -->
      <details class="mb-4">
        <summary class="cursor-pointer text-sm text-red-200 hover:text-white">
          View stack trace
        </summary>
        <pre class="mt-2 text-xs overflow-auto bg-black/50 p-3 rounded max-h-48">{gameError.stack}</pre>
      </details>

      <!-- Actions -->
      <div class="flex gap-3">
        <button
          onclick={() => gameError = null}
          class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded text-sm"
        >
          Dismiss
        </button>
        <button
          onclick={() => {
            if (onSendErrorToAI) {
              onSendErrorToAI(gameError.userFriendly || gameError.message);
            }
          }}
          class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded text-sm flex items-center gap-2"
        >
          <Sparkles class="h-4 w-4" />
          Fix with AI
        </button>
      </div>
    </div>
  </div>
{/if}
```

---

### Task 4.2: Type Hints on Hover (2 hours)

**Objective**: Show type information when hovering over code

#### Step 1: Add hover provider to CodeMirror
```svelte
<!-- Update apps/web/src/routes/editor/[projectId]/CodeEditor.svelte -->
<script lang="ts">
  import { hoverTooltip } from '@codemirror/view';

  let tsWorker: Worker;

  // Create hover tooltip extension
  const typeHover = hoverTooltip(async (view, pos) => {
    return new Promise((resolve) => {
      const handler = (event: MessageEvent) => {
        if (event.data.type === 'QUICK_INFO') {
          tsWorker.removeEventListener('message', handler);

          const info = event.data.payload.info;
          if (!info) {
            resolve(null);
            return;
          }

          resolve({
            pos,
            end: pos + 1,
            above: true,
            create() {
              const dom = document.createElement('div');
              dom.className = 'cm-type-tooltip';

              // Display name
              const name = document.createElement('div');
              name.className = 'font-mono text-sm font-bold mb-1';
              name.textContent = info.displayParts?.map((p: any) => p.text).join('') || '';
              dom.appendChild(name);

              // Documentation
              if (info.documentation) {
                const docs = document.createElement('div');
                docs.className = 'text-xs text-gray-300';
                docs.textContent = info.documentation.map((d: any) => d.text).join('');
                dom.appendChild(docs);
              }

              return { dom };
            }
          });
        }
      };

      tsWorker.addEventListener('message', handler);
      tsWorker.postMessage({
        type: 'GET_QUICK_INFO',
        payload: { filePath, position: pos }
      });

      // Timeout after 500ms
      setTimeout(() => {
        tsWorker.removeEventListener('message', handler);
        resolve(null);
      }, 500);
    });
  });

  onMount(() => {
    // ... existing setup ...

    view = new EditorView({
      // ... existing config ...
      extensions: [
        basicSetup,
        javascript({ typescript: true }),
        biomeLinter,
        tsLinter,
        formatKeymap,
        typeHover, // Add hover tooltips
        EditorView.updateListener.of(/* ... */)
      ],
      parent: editorEl
    });
  });
</script>

<style>
  :global(.cm-type-tooltip) {
    background: #1e1e1e;
    color: #d4d4d4;
    border: 1px solid #3e3e3e;
    border-radius: 6px;
    padding: 8px 12px;
    max-width: 400px;
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
  }
</style>
```

#### Step 2: Add GET_QUICK_INFO handler to TypeScript worker
```typescript
// Update apps/web/src/lib/workers/typescript.worker.ts

function getQuickInfo(filePath: string, position: number) {
  if (!env) return null;

  const info = env.languageService.getQuickInfoAtPosition(filePath, position);

  if (!info) return null;

  return {
    displayParts: info.displayParts,
    documentation: info.documentation,
    kind: info.kind
  };
}

self.addEventListener('message', (event) => {
  const { type, payload } = event.data;

  switch (type) {
    // ... existing cases ...

    case 'GET_QUICK_INFO':
      const info = getQuickInfo(payload.filePath, payload.position);
      self.postMessage({
        type: 'QUICK_INFO',
        payload: { info }
      });
      break;
  }
});
```

---

### Task 4.3: Migration Guide (2 hours)

**Objective**: Document how to migrate existing projects and write new ones

#### Step 1: Create user documentation
```markdown
<!-- Create docs/user-guide.md -->

# Martini Game Development Guide

## Quick Start

### Creating Your First Game

1. Click "New Project"
2. Choose "Martini TypeScript" template
3. Edit `src/game.ts` to define your game logic
4. Edit `src/scene.ts` to add Phaser rendering
5. Click "Run" to test

### Project Structure

```
/src/
  game.ts       # Game logic (state, actions)
  scene.ts      # Phaser rendering
  main.ts       # Auto-generated (don't edit)
```

---

## Game Logic (`game.ts`)

Define your game state and rules using `defineGame`:

```typescript
import { defineGame } from '@martini/phaser';

export const myGame = defineGame({
  // Initial state
  setup: ({ playerIds }) => ({
    players: Object.fromEntries(
      playerIds.map(id => [id, { x: 400, y: 300, score: 0 }])
    )
  }),

  // Actions (how state changes)
  actions: {
    move: {
      apply: (state, context, input) => {
        const player = state.players[context.targetId];
        player.x = input.x;
        player.y = input.y;
      }
    },

    addScore: {
      apply: (state, context, points: number) => {
        state.players[context.targetId].score += points;
      }
    }
  },

  // Handle players joining/leaving
  onPlayerJoin: (state, playerId) => {
    state.players[playerId] = { x: 400, y: 300, score: 0 };
  },

  onPlayerLeave: (state, playerId) => {
    delete state.players[playerId];
  }
});
```

---

## Phaser Rendering (`scene.ts`)

Render your game state using Phaser:

```typescript
import Phaser from 'phaser';
import { PhaserAdapter } from '@martini/phaser';
import type { GameRuntime } from '@martini/phaser';

export function createGameScene(runtime: GameRuntime) {
  return class GameScene extends Phaser.Scene {
    adapter!: PhaserAdapter;
    sprites: Map<string, Phaser.GameObjects.Sprite> = new Map();

    create() {
      this.adapter = new PhaserAdapter(runtime, this);

      // Listen for state changes
      this.adapter.onChange((state) => {
        // Create sprites for each player
        for (const [playerId, player] of Object.entries(state.players)) {
          if (!this.sprites.has(playerId)) {
            const sprite = this.physics.add.sprite(player.x, player.y, 'player');
            this.sprites.set(playerId, sprite);

            // Track my sprite (auto-syncs to other players)
            if (playerId === this.adapter.myId) {
              this.adapter.trackSprite(sprite, `player-${playerId}`);
            } else {
              this.adapter.registerRemoteSprite(`player-${playerId}`, sprite);
            }
          }
        }
      });
    }

    update() {
      // Smooth remote sprite movement
      this.adapter.updateInterpolation();

      // Handle input
      const cursors = this.input.keyboard!.createCursorKeys();
      const mySprite = this.sprites.get(this.adapter.myId);

      if (mySprite && cursors.left.isDown) {
        // Submit action to update state
        this.adapter.submitAction('move', {
          x: mySprite.x - 5,
          y: mySprite.y
        });
      }
    }
  };
}
```

---

## PhaserAdapter API

### Methods

| Method | Description |
|--------|-------------|
| `trackSprite(sprite, key)` | Auto-sync sprite position to other players |
| `registerRemoteSprite(key, sprite)` | Track remote player sprite for interpolation |
| `submitAction(name, payload)` | Send action to update game state |
| `onChange(callback)` | Listen for state changes |
| `updateInterpolation()` | Smooth remote sprite movement (call in update) |
| `myId` | Get your player ID |
| `isHost()` | Check if you're the host |

---

## Hot Module Replacement

HMR preserves game state across code changes:

‚úÖ Player positions
‚úÖ Scores
‚úÖ Sprite properties

‚ùå Physics velocity (recalculated)
‚ùå Timers (restarted)
‚ùå Audio (restarted)

Toggle HMR in the top-right corner of the preview panel.

---

## Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| `Cmd+S` | Save file |
| `Shift+Cmd+F` | Format code |
| `Cmd+Enter` | Run game |

---

## Multiplayer

Multiplayer is automatic! Just share your game:

1. Click "Publish"
2. Copy the join link
3. Send to friends
4. They click the link and play together

Your game uses P2P (peer-to-peer) so there's no server cost.

---

## Troubleshooting

### "Cannot find module '@martini/phaser'"
Make sure you're using `import` statements, not `require()`.

### Sprites not syncing
Check that you called `adapter.trackSprite()` for your player.

### Type errors
Hover over red squiggles to see the error message.

### Game won't load
Check the browser console (F12) for errors.
```

---

### Task 4.4: Example Games (2 hours)

**Objective**: Provide complete, working example games

#### Step 1: Create platformer example
```typescript
// Create apps/web/src/lib/server/templates/examples/platformer.ts

export const platformerExample = [
  {
    path: '/src/game.ts',
    content: `/**
 * Platformer Game - Cooperative multiplayer
 */

import { defineGame } from '@martini/phaser';

export const platformerGame = defineGame({
  setup: ({ playerIds }) => ({
    players: Object.fromEntries(
      playerIds.map((id, index) => [
        id,
        {
          x: 100 + index * 200,
          y: 400,
          score: 0,
          coinsCollected: 0
        }
      ])
    ),
    coins: [
      { x: 200, y: 300, collected: false },
      { x: 400, y: 250, collected: false },
      { x: 600, y: 300, collected: false }
    ]
  }),

  actions: {
    move: {
      apply: (state, context, input) => {
        const player = state.players[context.targetId];
        player.x = input.x;
        player.y = input.y;
      }
    },

    collectCoin: {
      apply: (state, context, coinIndex: number) => {
        const coin = state.coins[coinIndex];
        if (!coin.collected) {
          coin.collected = true;
          state.players[context.targetId].coinsCollected += 1;
          state.players[context.targetId].score += 10;
        }
      }
    }
  },

  onPlayerJoin: (state, playerId) => {
    const count = Object.keys(state.players).length;
    state.players[playerId] = {
      x: 100 + count * 200,
      y: 400,
      score: 0,
      coinsCollected: 0
    };
  },

  onPlayerLeave: (state, playerId) => {
    delete state.players[playerId];
  }
});
`
  },
  {
    path: '/src/scene.ts',
    content: `/**
 * Platformer Scene
 */

import Phaser from 'phaser';
import { PhaserAdapter } from '@martini/phaser';
import type { GameRuntime } from '@martini/phaser';

export function createGameScene(runtime: GameRuntime) {
  return class PlatformerScene extends Phaser.Scene {
    adapter!: PhaserAdapter;
    sprites: Map<string, Phaser.GameObjects.Sprite> = new Map();
    coinSprites: Phaser.GameObjects.Sprite[] = [];
    scoreText!: Phaser.GameObjects.Text;

    create() {
      this.adapter = new PhaserAdapter(runtime, this);

      if ((window as any).__HMR__) {
        (window as any).__HMR__.adapter = this.adapter;
      }

      // Background
      this.add.rectangle(400, 300, 800, 600, 0x87ceeb);

      // Platforms
      const platforms = this.physics.add.staticGroup();
      platforms.create(400, 550, 'platform').setScale(2).refreshBody();
      platforms.create(200, 400, 'platform');
      platforms.create(600, 300, 'platform');

      // Score UI
      this.scoreText = this.add.text(16, 16, '', {
        fontSize: '20px',
        color: '#000000'
      });

      // Listen for state changes
      this.adapter.onChange((state) => {
        // Create player sprites
        for (const [playerId, player] of Object.entries(state.players)) {
          if (!this.sprites.has(playerId)) {
            const color = playerId === this.adapter.myId ? 0x00ff00 : 0xff0000;
            const sprite = this.add.circle(player.x, player.y, 20, color);
            this.physics.add.existing(sprite);
            const body = sprite.body as Phaser.Physics.Arcade.Body;
            body.setCollideWorldBounds(true);
            body.setBounce(0.2);
            this.physics.add.collider(sprite, platforms);

            this.sprites.set(playerId, sprite);

            if (playerId === this.adapter.myId) {
              this.adapter.trackSprite(sprite, \`player-\${playerId}\`);
            } else {
              this.adapter.registerRemoteSprite(\`player-\${playerId}\`, sprite);
            }
          }
        }

        // Create coins
        for (let i = 0; i < state.coins.length; i++) {
          const coin = state.coins[i];
          if (!this.coinSprites[i] && !coin.collected) {
            const sprite = this.add.circle(coin.x, coin.y, 12, 0xffff00);
            this.physics.add.existing(sprite);
            this.coinSprites[i] = sprite;
          } else if (this.coinSprites[i] && coin.collected) {
            this.coinSprites[i].destroy();
          }
        }

        // Update score
        const myPlayer = state.players[this.adapter.myId];
        if (myPlayer) {
          this.scoreText.setText(\`Score: \${myPlayer.score} | Coins: \${myPlayer.coinsCollected}\`);
        }
      });
    }

    update() {
      this.adapter.updateInterpolation();

      const cursors = this.input.keyboard!.createCursorKeys();
      const mySprite = this.sprites.get(this.adapter.myId);

      if (mySprite) {
        const body = mySprite.body as Phaser.Physics.Arcade.Body;
        body.setVelocityX(0);

        if (cursors.left.isDown) {
          body.setVelocityX(-200);
        } else if (cursors.right.isDown) {
          body.setVelocityX(200);
        }

        if (cursors.up.isDown && body.touching.down) {
          body.setVelocityY(-400);
        }

        // Check coin collisions
        const state = this.adapter.runtime.getState();
        for (let i = 0; i < state.coins.length; i++) {
          const coin = state.coins[i];
          if (!coin.collected) {
            const dist = Phaser.Math.Distance.Between(
              mySprite.x,
              mySprite.y,
              coin.x,
              coin.y
            );
            if (dist < 32) {
              this.adapter.submitAction('collectCoin', i);
            }
          }
        }

        // Submit position update
        this.adapter.submitAction('move', {
          x: mySprite.x,
          y: mySprite.y
        });
      }
    }
  };
}
`
  },
  {
    path: '/src/main.ts',
    content: `// Auto-generated - same as starter template`
  }
];
```

---

## Testing Checklist

- [ ] Error messages show TypeScript file and line number
- [ ] User-friendly error explanations appear
- [ ] "Fix with AI" button sends error to AI chat
- [ ] Hovering over code shows type information
- [ ] Type hints include documentation
- [ ] User guide is complete and accurate
- [ ] Example games run without errors
- [ ] Example games demonstrate key features

---

## Next Steps

Migration complete! üéâ

Review checklist:
- [ ] All 4 phases implemented
- [ ] TypeScript compilation works
- [ ] Martini SDK integrated
- [ ] HMR preserves state
- [ ] Developer experience polished
- [ ] Documentation written
- [ ] Examples provided

Deploy to production and monitor for issues.
