# Phase 2: Editor Experience

**Duration**: 2 days
**Goal**: Add real-time TypeScript checking, formatting, and linting to CodeMirror

---

## Overview

This phase enhances the developer experience by adding:
1. **Biome WASM**: Instant formatting and linting (50ms response time)
2. **TypeScript Worker**: Background type checking with inline diagnostics
3. **CodeMirror Integration**: Red squiggles, autocomplete, and error messages

---

## Tasks

### Task 2.1: Add Biome WASM (3 hours)

**Objective**: Format and lint TypeScript code instantly in the browser

#### Step 1: Install Biome
```bash
cd apps/web
pnpm add @biomejs/wasm-web @biomejs/js-api
```

#### Step 2: Create Biome worker
```typescript
// apps/web/src/lib/workers/biome.worker.ts

import { Biome, Distribution } from '@biomejs/wasm-web';

let biome: Biome | null = null;

// Initialize Biome
async function initBiome() {
  if (biome) return biome;

  biome = await Biome.create({
    distribution: Distribution.NODE
  });

  // Configure Biome
  biome.applyConfiguration({
    formatter: {
      enabled: true,
      indentStyle: 'space',
      indentWidth: 2,
      lineWidth: 100
    },
    linter: {
      enabled: true,
      rules: {
        recommended: true,
        style: {
          useConst: 'error',
          noUnusedVariables: 'warn'
        },
        suspicious: {
          noExplicitAny: 'warn'
        }
      }
    },
    javascript: {
      formatter: {
        quoteStyle: 'single',
        semicolons: 'always'
      }
    }
  });

  return biome;
}

// Message handler
self.addEventListener('message', async (event) => {
  const { type, payload } = event.data;

  const b = await initBiome();

  switch (type) {
    case 'FORMAT':
      try {
        const result = b.formatContent(payload.code, {
          filePath: payload.filePath || 'file.ts'
        });

        self.postMessage({
          type: 'FORMAT_RESULT',
          payload: {
            formatted: result.content,
            success: true
          }
        });
      } catch (error) {
        self.postMessage({
          type: 'FORMAT_RESULT',
          payload: {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          }
        });
      }
      break;

    case 'LINT':
      try {
        const result = b.lintContent(payload.code, {
          filePath: payload.filePath || 'file.ts'
        });

        const diagnostics = result.diagnostics.map((d) => ({
          severity: d.severity,
          message: d.message,
          line: d.location?.span?.start.line || 0,
          column: d.location?.span?.start.column || 0,
          code: d.code
        }));

        self.postMessage({
          type: 'LINT_RESULT',
          payload: {
            diagnostics,
            success: true
          }
        });
      } catch (error) {
        self.postMessage({
          type: 'LINT_RESULT',
          payload: {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          }
        });
      }
      break;
  }
});
```

#### Step 3: Integrate in CodeEditor
```svelte
<!-- apps/web/src/routes/editor/[projectId]/CodeEditor.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { EditorView, basicSetup } from 'codemirror';
  import { javascript } from '@codemirror/lang-javascript';
  import { linter, type Diagnostic } from '@codemirror/lint';
  import type { ViewUpdate } from '@codemirror/view';

  let {
    content = $bindable(''),
    onChange,
    filePath
  }: {
    content: string;
    onChange: (newContent: string) => void;
    filePath: string;
  } = $props();

  let editorEl: HTMLDivElement;
  let view: EditorView;
  let biomeWorker: Worker;
  let formatOnSave = $state(true);

  onMount(() => {
    // Initialize Biome worker
    biomeWorker = new Worker(
      new URL('$lib/workers/biome.worker.ts', import.meta.url),
      { type: 'module' }
    );

    // Create linter
    const biomeLinter = linter((view) => {
      return new Promise((resolve) => {
        const handler = (event: MessageEvent) => {
          if (event.data.type === 'LINT_RESULT') {
            biomeWorker.removeEventListener('message', handler);

            if (event.data.payload.success) {
              const diagnostics: Diagnostic[] = event.data.payload.diagnostics.map((d: any) => ({
                from: view.state.doc.line(d.line + 1).from + d.column,
                to: view.state.doc.line(d.line + 1).from + d.column + 1,
                severity: d.severity === 'error' ? 'error' : 'warning',
                message: d.message
              }));
              resolve(diagnostics);
            } else {
              resolve([]);
            }
          }
        };

        biomeWorker.addEventListener('message', handler);
        biomeWorker.postMessage({
          type: 'LINT',
          payload: {
            code: view.state.doc.toString(),
            filePath
          }
        });
      });
    });

    // Create editor
    view = new EditorView({
      doc: content,
      extensions: [
        basicSetup,
        javascript({ typescript: true }),
        biomeLinter,
        EditorView.updateListener.of((update: ViewUpdate) => {
          if (update.docChanged) {
            const newContent = update.state.doc.toString();
            onChange(newContent);
          }
        })
      ],
      parent: editorEl
    });
  });

  onDestroy(() => {
    view?.destroy();
    biomeWorker?.terminate();
  });

  // Format code
  export function format() {
    return new Promise<void>((resolve) => {
      const handler = (event: MessageEvent) => {
        if (event.data.type === 'FORMAT_RESULT') {
          biomeWorker.removeEventListener('message', handler);

          if (event.data.payload.success) {
            const formatted = event.data.payload.formatted;
            view.dispatch({
              changes: {
                from: 0,
                to: view.state.doc.length,
                insert: formatted
              }
            });
          }
          resolve();
        }
      };

      biomeWorker.addEventListener('message', handler);
      biomeWorker.postMessage({
        type: 'FORMAT',
        payload: {
          code: view.state.doc.toString(),
          filePath
        }
      });
    });
  }
</script>

<div class="h-full" bind:this={editorEl}></div>
```

**Validation**: Type code → see linting errors in real-time → press Cmd+Shift+F → code formats

---

### Task 2.2: Add TypeScript Worker (4 hours)

**Objective**: Show TypeScript errors inline in editor

#### Step 1: Install TypeScript
```bash
cd apps/web
pnpm add typescript @typescript/vfs
```

#### Step 2: Create TypeScript worker
```typescript
// apps/web/src/lib/workers/typescript.worker.ts

import ts from 'typescript';
import { createSystem, createVirtualTypeScriptEnvironment } from '@typescript/vfs';

let env: ReturnType<typeof createVirtualTypeScriptEnvironment> | null = null;
let fileMap = new Map<string, string>();

/**
 * Initialize TypeScript virtual environment
 */
function initTypeScript(files: Record<string, string>) {
  fileMap.clear();

  // Add user files
  for (const [path, content] of Object.entries(files)) {
    fileMap.set(path, content);
  }

  // Add lib files (DOM, ES2020)
  const compilerOptions: ts.CompilerOptions = {
    target: ts.ScriptTarget.ES2020,
    module: ts.ModuleKind.ESNext,
    lib: ['lib.es2020.d.ts', 'lib.dom.d.ts'],
    moduleResolution: ts.ModuleResolutionKind.Bundler,
    strict: true,
    esModuleInterop: true,
    skipLibCheck: true,
    types: ['phaser']
  };

  const system = createSystem(fileMap);
  env = createVirtualTypeScriptEnvironment(
    system,
    Array.from(fileMap.keys()),
    ts,
    compilerOptions
  );

  return env;
}

/**
 * Get diagnostics for a file
 */
function getDiagnostics(filePath: string) {
  if (!env) return [];

  const diagnostics = [
    ...env.languageService.getSyntacticDiagnostics(filePath),
    ...env.languageService.getSemanticDiagnostics(filePath)
  ];

  return diagnostics.map((d) => {
    const start = d.start || 0;
    const length = d.length || 1;

    return {
      start,
      length,
      message: ts.flattenDiagnosticMessageText(d.messageText, '\n'),
      category: d.category,
      code: d.code
    };
  });
}

/**
 * Get completions at position
 */
function getCompletions(filePath: string, position: number) {
  if (!env) return null;

  const completions = env.languageService.getCompletionsAtPosition(
    filePath,
    position,
    {}
  );

  if (!completions) return null;

  return completions.entries.map((entry) => ({
    name: entry.name,
    kind: entry.kind,
    sortText: entry.sortText
  }));
}

// Message handler
self.addEventListener('message', (event) => {
  const { type, payload } = event.data;

  switch (type) {
    case 'INIT':
      initTypeScript(payload.files);
      self.postMessage({ type: 'INIT_DONE' });
      break;

    case 'UPDATE_FILE':
      if (env) {
        fileMap.set(payload.filePath, payload.content);
        env.updateFile(payload.filePath, payload.content);
      }
      break;

    case 'GET_DIAGNOSTICS':
      const diagnostics = getDiagnostics(payload.filePath);
      self.postMessage({
        type: 'DIAGNOSTICS',
        payload: { filePath: payload.filePath, diagnostics }
      });
      break;

    case 'GET_COMPLETIONS':
      const completions = getCompletions(payload.filePath, payload.position);
      self.postMessage({
        type: 'COMPLETIONS',
        payload: { completions }
      });
      break;
  }
});
```

#### Step 3: Integrate TypeScript diagnostics
```svelte
<!-- Update CodeEditor.svelte -->
<script lang="ts">
  // ... existing imports ...
  import { linter, type Diagnostic } from '@codemirror/lint';

  let tsWorker: Worker;
  let allFiles = $state<Record<string, string>>({});

  onMount(() => {
    // ... existing Biome worker setup ...

    // Initialize TypeScript worker
    tsWorker = new Worker(
      new URL('$lib/workers/typescript.worker.ts', import.meta.url),
      { type: 'module' }
    );

    // Initialize with all project files
    tsWorker.postMessage({
      type: 'INIT',
      payload: { files: allFiles }
    });

    // Create TypeScript linter
    const tsLinter = linter((view) => {
      return new Promise((resolve) => {
        const handler = (event: MessageEvent) => {
          if (event.data.type === 'DIAGNOSTICS' && event.data.payload.filePath === filePath) {
            tsWorker.removeEventListener('message', handler);

            const diagnostics: Diagnostic[] = event.data.payload.diagnostics.map((d: any) => ({
              from: d.start,
              to: d.start + d.length,
              severity: d.category === 1 ? 'error' : 'warning',
              message: d.message
            }));

            resolve(diagnostics);
          }
        };

        tsWorker.addEventListener('message', handler);
        tsWorker.postMessage({
          type: 'GET_DIAGNOSTICS',
          payload: { filePath }
        });
      });
    });

    // Create editor with both linters
    view = new EditorView({
      doc: content,
      extensions: [
        basicSetup,
        javascript({ typescript: true }),
        biomeLinter,
        tsLinter, // Add TypeScript linter
        EditorView.updateListener.of((update: ViewUpdate) => {
          if (update.docChanged) {
            const newContent = update.state.doc.toString();
            onChange(newContent);

            // Update TypeScript worker
            tsWorker.postMessage({
              type: 'UPDATE_FILE',
              payload: { filePath, content: newContent }
            });
          }
        })
      ],
      parent: editorEl
    });
  });

  onDestroy(() => {
    view?.destroy();
    biomeWorker?.terminate();
    tsWorker?.terminate();
  });
</script>
```

**Validation**:
- Type `const x: number = "string"` → see red squiggle
- Hover over error → see TypeScript message
- Fix error → squiggle disappears

---

### Task 2.3: Add Format on Save (1 hour)

**Objective**: Auto-format code when user saves

#### Step 1: Add format button and toggle
```svelte
<!-- In apps/web/src/routes/editor/[projectId]/+page.svelte -->
<script lang="ts">
  let formatOnSave = $state(true);
  let codeEditor: any;

  async function saveFile(path: string) {
    const file = filesMap[path];
    if (!file?.dirty) return;

    // Format before save if enabled
    if (formatOnSave && codeEditor) {
      await codeEditor.format();
    }

    saveStatus = 'saving';

    try {
      const response = await fetch(`/api/projects/${data.project.id}/files`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path, content: file.content })
      });

      // ... rest of save logic ...
    } catch (error) {
      // ... error handling ...
    }
  }
</script>

<!-- Add format button in header -->
<header class="flex items-center gap-4 border-b bg-background px-4 py-3">
  <!-- ... existing header content ... -->

  <div class="flex items-center gap-2">
    <label class="text-xs">
      <input type="checkbox" bind:checked={formatOnSave} />
      Format on save
    </label>

    <button
      onclick={() => codeEditor?.format()}
      class="rounded px-2 py-1 text-xs border hover:bg-muted"
    >
      Format (⇧⌘F)
    </button>
  </div>
</header>
```

#### Step 2: Add keyboard shortcut
```svelte
<!-- Update CodeEditor.svelte -->
<script lang="ts">
  import { keymap } from '@codemirror/view';

  onMount(() => {
    // ... existing setup ...

    // Add format shortcut
    const formatKeymap = keymap.of([
      {
        key: 'Shift-Mod-f',
        run: () => {
          format();
          return true;
        }
      }
    ]);

    view = new EditorView({
      // ... existing config ...
      extensions: [
        basicSetup,
        javascript({ typescript: true }),
        biomeLinter,
        tsLinter,
        formatKeymap, // Add keyboard shortcut
        EditorView.updateListener.of(/* ... */)
      ],
      parent: editorEl
    });
  });
</script>
```

**Validation**:
- Press Shift+Cmd+F → code formats
- Enable "Format on save" → save file → code auto-formats

---

## Testing Checklist

- [ ] Biome formats TypeScript code correctly
- [ ] Biome shows lint warnings inline
- [ ] TypeScript worker shows type errors with red squiggles
- [ ] Hover over error shows full TypeScript message
- [ ] Format on save works when enabled
- [ ] Keyboard shortcut (Shift+Cmd+F) formats code
- [ ] Both Biome and TypeScript linters work simultaneously
- [ ] Workers don't block main thread (smooth editing)
- [ ] Errors clear when code is fixed

---

## Performance Targets

| Operation | Target | Acceptable |
|-----------|--------|------------|
| Biome format | <50ms | <100ms |
| Biome lint | <100ms | <200ms |
| TypeScript check | <200ms | <500ms |
| First load (worker init) | <1s | <2s |

---

## Common Issues

### Issue: Workers fail to load
**Solution**: Check Vite config allows `?worker` imports

### Issue: TypeScript shows errors for Phaser
**Solution**: Bundle Phaser type definitions with project

### Issue: Formatting breaks imports
**Solution**: Configure Biome to preserve import order

### Issue: Linters conflict
**Solution**: Disable Biome rules that overlap with TypeScript (e.g., `noUnusedVariables`)

---

## Next Steps

Proceed to [Phase 3: Hot Module Replacement](4.hot-module-replacement.md)
